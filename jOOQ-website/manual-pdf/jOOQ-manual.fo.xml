<?xml version="1.0" encoding="UTF-8"?><fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format">
<fo:layout-master-set>
<fo:simple-page-master master-name="simple" page-width="210mm" page-height="297mm">
<fo:region-body margin="17mm" region-name="xsl-region-body"/>
<fo:region-before extent="17mm" region-name="xsl-region-before"/>
<fo:region-after extent="17mm" region-name="xsl-region-after"/>
</fo:simple-page-master>
</fo:layout-master-set>
<fo:page-sequence master-reference="simple">
<fo:flow font-family="Helvetica" flow-name="xsl-region-body">
<fo:block font-family="Georgia" margin-right="20mm" margin-left="20mm" width="100%">
<fo:block padding-top="60mm" font-size="36pt" text-align="center" width="100%">The jOOQ User Manual</fo:block>
<fo:block padding-top="20mm" color="#555555" font-size="12pt" text-align="justify" width="100%">SQL was never meant to be abstracted. To be confined in the narrow 
	   						boundaries of heavy mappers, hiding the beauty and simplicity of relational data. 
	   						SQL was never meant to be object-oriented. SQL was never meant to be anything 
	   						other than... SQL!</fo:block>
<fo:block padding-top="20mm" text-align="center" width="100%">
<fo:external-graphic padding-top="10pt" padding-bottom="10pt" src="url('C:/Users/lukas/workspace/jOOQ-website/img/logo.png')"/>
</fo:block>
</fo:block>
</fo:flow>
</fo:page-sequence>
<fo:page-sequence master-reference="simple">
<fo:static-content font-family="Helvetica" flow-name="xsl-region-before">
<fo:block>
<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="proportional-column-width(1)"/>
<fo:table-column column-width="150mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell padding-top="11.333333333333334mm" padding-left="17mm">
<fo:block font-size="7pt" color="#555555">
							      			The jOOQ User Manual
							      			</fo:block>
</fo:table-cell>
<fo:table-cell text-align="right" padding-top="11.333333333333334mm" padding-right="17mm">
<fo:block font-size="7pt" color="#555555">
<fo:retrieve-marker retrieve-class-name="section"/>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>
</fo:block>
</fo:static-content>
<fo:static-content font-family="Helvetica" flow-name="xsl-region-after">
<fo:block>
<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="150mm"/>
<fo:table-column column-width="proportional-column-width(1)"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell padding-left="17mm">
<fo:block font-size="7pt" color="#555555">
							      			jOOQ is brought to you by Lukas Eder. Distributed under the Apache 2 licence
							      			</fo:block>
</fo:table-cell>
<fo:table-cell text-align="right" padding-right="17mm">
<fo:block font-size="7pt" color="#555555">Page <fo:page-number/> / <fo:page-number-citation ref-id="last-page"/>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>
</fo:block>
</fo:static-content>
<fo:flow font-family="Helvetica" flow-name="xsl-region-body">
			
			<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Overview</fo:block>
			<fo:block font-size="11pt">This manual is divided into four main sections:</fo:block>
			<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
				<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
					<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="JOOQ">jOOQ classes and their usage</fo:basic-link>
					<fo:block font-size="11pt">
						See these chapters for an overview of the jOOQ internal architecture
						and all types that are involved with jOOQ's query creation and
						execution. This is the important part for you, also, if you wish to
						extend jOOQ
					</fo:block>
				</fo:block>
</fo:list-item-body>
</fo:list-item>
				<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
					<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="META">Meta model code generation</fo:basic-link>
					<fo:block font-size="11pt">
						See these chapters to understand how you can use jOOQ as a source code
						generator, and what type of artefacts are generated by jOOQ
					</fo:block>
				</fo:block>
</fo:list-item-body>
</fo:list-item>
				<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
					<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="DSL">DSL or fluent API. Where SQL meets Java</fo:basic-link>
					<fo:block font-size="11pt">
						See these chapters to learn about how to use jOOQ in every day's work. The
						jOOQ DSL is the main way to create and execute jOOQ queries almost as
						if SQL was embedded in Java directly
					</fo:block>
				</fo:block>
</fo:list-item-body>
</fo:list-item>
				<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
					<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="ADVANCED">Advanced topics</fo:basic-link>
					<fo:block font-size="11pt">
						Some advanced topics including not-everyday functionality
					</fo:block>
				</fo:block>
</fo:list-item-body>
</fo:list-item>
			</fo:list-block>
</fo:block>
		<fo:block break-after="page"/>
<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Table of contents</fo:block>
<fo:block margin-bottom="6pt">
<fo:list-block>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">1.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="JOOQ">jOOQ classes and their usage<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="JOOQ"/>
</fo:basic-link>
</fo:inline>
</fo:block>
<fo:block margin-bottom="6pt">
<fo:list-block>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">1.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="ExampleDatabase">The example database<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="ExampleDatabase"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">2.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Factory">The Factory class<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Factory"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">3.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Table">Tables and Fields<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Table"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">4.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Result">Results and Records<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Result"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">5.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="UpdatableRecord">Updatable Records<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="UpdatableRecord"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">6.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Query">The Query and its various subtypes<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Query"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">7.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="ResultQuery">ResultQuery and various ways of fetching data<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="ResultQuery"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">8.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="BindValues">Bind values<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="BindValues"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">9.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="QueryPart">QueryParts and the global architecture<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="QueryPart"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">10.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Serializability">Serializability of QueryParts and Results<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Serializability"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">11.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Extend">Extend jOOQ with custom types<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Extend"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
</fo:list-block>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">2.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="META">Meta model code generation<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="META"/>
</fo:basic-link>
</fo:inline>
</fo:block>
<fo:block margin-bottom="6pt">
<fo:list-block>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">1.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Configuration">Configuration and setup of the generator<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Configuration"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">2.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="SCHEMA">The schema, top-level generated artefact<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="SCHEMA"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">3.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="TABLE">Tables, views and their corresponding records<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="TABLE"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">4.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="PROCEDURE">Procedures and packages<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="PROCEDURE"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">5.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="UDT">UDT's including ARRAY and ENUM types<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="UDT"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">6.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="SEQUENCE">Sequences<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="SEQUENCE"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
</fo:list-block>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">3.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="DSL">DSL or fluent API. Where SQL meets Java<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="DSL"/>
</fo:basic-link>
</fo:inline>
</fo:block>
<fo:block margin-bottom="6pt">
<fo:list-block>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">1.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="SELECT">Complete SELECT syntax<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="SELECT"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">2.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="CONDITION">Conditions<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="CONDITION"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">3.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="ALIAS">Aliased tables and fields<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="ALIAS"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">4.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="IN">Nested SELECT using the IN operator<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="IN"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">5.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="EXISTS">Nested SELECT using the EXISTS operator<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="EXISTS"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">6.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="NESTED">Other types of nested SELECT<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="NESTED"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">7.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="UNION">UNION and other set operations<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="UNION"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">8.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="FUNCTIONS">Functions and aggregate operators<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="FUNCTIONS"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">9.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="PROCEDURES">Stored procedures and functions<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="PROCEDURES"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">10.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="ARITHMETIC">Arithmetic operations and concatenation<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="ARITHMETIC"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">11.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="CASE">The CASE clause<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="CASE"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">12.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="CAST">Type casting<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="CAST"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">13.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="SQL">When it's just easier: Plain SQL<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="SQL"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
</fo:list-block>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">4.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="ADVANCED">Advanced topics<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="ADVANCED"/>
</fo:basic-link>
</fo:inline>
</fo:block>
<fo:block margin-bottom="6pt">
<fo:list-block>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">1.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="MasterData">Master data generation. Enumeration tables<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="MasterData"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">2.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="SchemaMapping">Mapping generated schemata and tables<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="SchemaMapping"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">3.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="OracleHints">Adding Oracle hints to queries<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="OracleHints"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">4.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="CONNECTBY">The Oracle CONNECT BY clause<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="CONNECTBY"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">5.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="PIVOT">The Oracle 11g PIVOT clause<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="PIVOT"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">6.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Export">Exporting to XML, CSV, JSON, HTML, Text<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Export"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">7.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Import">Importing data from XML, CSV<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Import"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">8.</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:block text-align-last="justify">
<fo:inline>
<fo:basic-link internal-destination="Batch">Using JDBC batch operations<fo:leader leader-pattern="dots"/>
<fo:page-number-citation ref-id="Batch"/>
</fo:basic-link>
</fo:inline>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
</fo:list-block>
</fo:block>
</fo:block>
</fo:list-item-body>
</fo:list-item>
</fo:list-block>
</fo:block>
<fo:block break-after="page"/>
<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="JOOQ">
<fo:marker marker-class-name="section">
<fo:block>1. jOOQ classes and their usage</fo:block>
</fo:marker>1. jOOQ classes and their usage</fo:block>
<fo:block font-size="11pt">
					In these sections, you will learn about how to use jOOQ object
					factories and the jOOQ query model, to express
					your SQL in jOOQ
				</fo:block>
					<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Overview</fo:block>
					<fo:block font-size="11pt">jOOQ essentially has two packages:</fo:block>
					<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
						<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">org.jooq: the jOOQ API. Here you will find interfaces for all
							SQL concepts
						</fo:block>
</fo:list-item-body>
</fo:list-item>
						<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">org.jooq.impl: the jOOQ implementation and factories. Most
							implementation classes are package private, you can only access
							them using the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Factory">org.jooq.impl.Factory</fo:basic-link>
						</fo:block>
</fo:list-item-body>
</fo:list-item>
					</fo:list-block>
</fo:block>
					<fo:block font-size="11pt">
						This section is about the main jOOQ classes and the global
						architecture. Most of the time, however, you will be using the
						<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="DSL">DSL or fluent API. Where SQL meets Java</fo:basic-link>
						in order to create queries
						the way you're used to in SQL
					</fo:block>
				<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="ExampleDatabase">
<fo:marker marker-class-name="section">
<fo:block>1.1. The example database</fo:block>
</fo:marker>1.1. The example database</fo:block>
<fo:block font-size="11pt">
							For the examples in this manual, the same database will always be
							referred to. It essentially consists of these entities created using
							the Oracle dialect
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example CREATE TABLE statements</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">CREATE TABLE t_language (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  cd CHAR(2) NOT NULL,
  description VARCHAR2(50)
)

CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50) NOT NULL,
  date_of_birth DATE,
  year_of_birth NUMBER(7)
)

CREATE TABLE t_book (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  author_id NUMBER(7) NOT NULL,
  title VARCHAR2(400) NOT NULL,
  published_in NUMBER(7) NOT NULL,
  language_id NUMBER(7) NOT NULL,
  FOREIGN KEY (AUTHOR_ID) REFERENCES T_AUTHOR(ID),
  FOREIGN KEY (LANGUAGE_ID) REFERENCES T_LANGUAGE(ID)
)

CREATE TABLE t_book_store (
  name VARCHAR2(400) NOT NULL UNIQUE
)

CREATE TABLE t_book_to_book_store (
  book_store_name VARCHAR2(400) NOT NULL,
  book_id INTEGER NOT NULL,
  stock INTEGER,
  PRIMARY KEY(book_store_name, book_id),
  CONSTRAINT b2bs_book_store_id
    FOREIGN KEY (book_store_name)
    REFERENCES t_book_store (name)
    ON DELETE CASCADE,
  CONSTRAINT b2bs_book_id
    FOREIGN KEY (book_id)
    REFERENCES t_book (id)
    ON DELETE CASCADE
)</fo:block>
							<fo:block font-size="11pt">
								More entities, types (e.g. UDT's, ARRAY types, ENUM types, etc),
								stored procedures and packages are introduced for specific examples
							</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Factory">
<fo:marker marker-class-name="section">
<fo:block>1.2. The Factory class</fo:block>
</fo:marker>1.2. The Factory class</fo:block>
<fo:block font-size="11pt">
							jOOQ hides most implementation facts from you by letting you
							use the jOOQ Factory as a single entry point to all of the jOOQ API.
							This way, you can discover all of the API using syntax auto-completion, for
							instance.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The Factory and the jOOQ API</fo:block>
							<fo:block font-size="11pt">
								jOOQ exposes a lot of interfaces and hides most implementation facts
								from client code. The reasons for this are:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Interface-driven design. This allows for modelling queries in a fluent API most efficiently</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Reduction of complexity for client code.</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">API guarantee. You only depend on the exposed interfaces, not concrete (potentially dialect-specific) implementations.</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">
								The <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/Factory.java')">org.jooq.impl.Factory</fo:basic-link>
								class is the main class from where you will create all jOOQ objects.
								The Factory implements <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Configuration.java')">org.jooq.Configuration</fo:basic-link>
								and needs to be instanciated with the Configuration's properties:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SQLDialect.java')">org.jooq.SQLDialect</fo:basic-link> :
								The dialect of your database. This may be any of the currently
								supported database types</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/Connection.html')">java.sql.Connection</fo:basic-link> :
								A JDBC Connection that will be re-used for the whole
    							lifecycle of your Factory</fo:block>
</fo:list-item-body>
</fo:list-item>
    							<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SchemaMapping.java')">org.jooq.SchemaMapping</fo:basic-link> :
    							An optional mapping of schemata. Check out the
    							<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="SchemaMapping">SchemaMapping</fo:basic-link>
    							page for details</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">If you are planning on using several RDBMS (= SQLDialects) or
								several distinct JDBC Connections in your software, this will mean
								that you have to create a new Factory every time. </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Factory subclasses</fo:block>
							<fo:block font-size="11pt">
								There are a couple of subclasses for the general Factory. Each SQL
								dialect has its own dialect-specific factory. For instance, if you're
								only using the MySQL dialect, you can choose to create a new Factory
								using any of the following types:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// A general, dialect-unspecific factory
Factory create = new Factory(connection, SQLDialect.MYSQL);

// A MySQL-specific factory
MySQLFactory create = new MySQLFactory(connection);</fo:block>
							<fo:block font-size="11pt">
								The advantage of using a dialect-specific Factory lies in the fact,
								that you have access to more proprietary RDMBS functionality. This may
								include:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Oracle's <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="CONNECTBY">CONNECT BY</fo:basic-link>
								    pseudo columns and functions</fo:block>
</fo:list-item-body>
</fo:list-item>
    							<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">MySQL's encryption functions</fo:block>
</fo:list-item-body>
</fo:list-item>
    							<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">PL/SQL constructs, pgplsql, or any other dialect's ROUTINE-language (maybe in the future)</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">
								Another type of Factory subclasses are each generated schema's
								factories. If you generate your schema TEST, then you will have access
								to a TestFactory. This will be useful in the future, when access to
								schema artefacts will be unified. Currently, this has no use.
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Static Factory methods</fo:block>
							<fo:block font-size="11pt">
								With jOOQ 2.0, static factory methods have been introduced in order to
								make your code look more like SQL. Ideally, when working with jOOQ, you
								will simply static import all methods from the Factory class:
							</fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">import static org.jooq.impl.Factory.*;</fo:block>
							<fo:block font-size="11pt">
								This will allow to access functions even more fluently:
							</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">concat(trim(FIRST_NAME), trim(LAST_NAME));
// ... which is in fact the same as:
Factory.concat(Factory.trim(FIRST_NAME), Factory.trim(LAST_NAME));</fo:block>
							<fo:block font-size="11pt">
								Objects created statically from the Factory do not need a reference to
								any factory, as they can be constructed independently from your Configuration
								(connection, dialect, schema mapping). They will access that information at
								render / bind time. See
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="QueryPart">more details on the QueryParts' internals</fo:basic-link>
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Potential problems</fo:block>
							<fo:block font-size="11pt">
								The jOOQ Factory expects its underlying
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/Connection.html')">java.sql.Connection</fo:basic-link>
								to be <fo:inline font-weight="bold">open and ready</fo:inline>
								for
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html')">java.sql.PreparedStatement</fo:basic-link>
								creation. You are responsible yourself for the
								lifecycle dependency between Factory and Connection. This means:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">jOOQ will never close the Connection.</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">jOOQ will never commit or rollback on the Connection
									(Except for CSV-imports, if explicitly configured in the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Import">Import API</fo:basic-link>)</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">jOOQ will never start any transactions.</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
									jOOQ does not know the concept of a session as for instance
									<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/architecture.html#architecture-current-session')">Hibernate</fo:basic-link>
								</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">jOOQ does not know the concept of a second-level cache. SQL is
									executed directly on the underlying RDBMS.</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">jOOQ does not make assumptions about the origin of the Connection.
									If it is container managed, that is fine.</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">
								So if you want your queries to run in separate transactions, if you
								want to roll back a transaction, if you want to close a Connection and
								return it to your container, you will have to take care of that
								yourself. jOOQ's Factory will always expect its Connection to be in a
								ready state for creating new PreparedStatements. If it is not, you have
								to create a new Factory.
							</fo:block>
							<fo:block font-size="11pt">
								Please keep in mind that many jOOQ objects will reference your Factory
								for their whole lifecycle. This is especially interesting, when dealing
								with <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="UpdatableRecord">Updatable Records</fo:basic-link>,
								that can perform CRUD operations on the
								Factory's underlying Connection.
							</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Table">
<fo:marker marker-class-name="section">
<fo:block>1.3. Tables and Fields</fo:block>
</fo:marker>1.3. Tables and Fields</fo:block>
<fo:block font-size="11pt">
							Tables and their Fields are probably the most important objects in
							jOOQ. Tables represent any entity in your underlying RDBMS, that holds
							data for selection, insertion, updates, and deletion. In other words,
							views are also considered tables by jOOQ.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The Table</fo:block>
							<fo:block font-size="11pt">The formal definition of a <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Table.java')">org.jooq.Table</fo:basic-link> starts with </fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public interface Table&lt;R extends Record&gt; // [...]</fo:block>
							<fo:block font-size="11pt">
								This means that every table is associated with a subtype of the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Record.java')">org.jooq.Record</fo:basic-link>
								class (see also
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Result">Results and Records</fo:basic-link>
								). For anonymous or ad-hoc tables,
								&lt;R&gt; will always bind to Record itself.
							</fo:block>
							<fo:block font-size="11pt">
								Unlike in the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javaee/6/tutorial/doc/gjitv.html')">JPA CriteriaQuery API</fo:basic-link>,
								this generic type
								&lt;R&gt;
								is not given so much importance as far as
								type-safety is concerned.
								SQL itself is highly typesafe. You have
								incredible flexibility of creating anonymous or ad-hoc
								types and
								reusing them from
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="NESTED">NESTED SELECT statements</fo:basic-link>
								or from many other
								use-cases. There is no way that this typesafety can be
								mapped to the Java world in a convenient way. If
								&lt;R&gt; would play a role as important
								as in JPA, jOOQ would suffer from the same verbosity, or inflexibility
								that JPA CriteriaQueries may have.
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The Field</fo:block>
							<fo:block font-size="11pt">The formal definition of a Field starts with </fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public interface Field&lt;T&gt; // [...]</fo:block>
							<fo:block font-size="11pt">
								Fields are generically parameterised with a Java type
								&lt;T&gt;
								that reflects the closest match to the RDMBS's underlying datatype for that
								field. For instance, if you have a VARCHAR2 type Field in Oracle,
								&lt;T&gt;
								would bind to
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/lang/String.html')">java.lang.String</fo:basic-link>
								for that Field in jOOQ. Oracle's NUMBER(7) would
								let
								&lt;T&gt;
								bind to
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/lang/Integer.html')">java.lang.Integer</fo:basic-link>,
								etc. This generic type is useful for two purposes:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">It allows you to write type safe queries. For instance, you cannot
									compare Field
									&lt;String&gt;
									with Field
									&lt;Integer&gt;</fo:block>
</fo:list-item-body>
</fo:list-item>

								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">It
									allows you to fetch correctly cast and converted values from
									your database result set. This is especially useful when &lt;T&gt; binds
									to
									advanced data types, such as
									<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="UDT">UDT's, ARRAY or ENUM types</fo:basic-link>
									, where jOOQ
									does the difficult non-standardised JDBC data type conversions for you.
								</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Fields and tables put into action</fo:block>
							<fo:block font-size="11pt">The Field itself is a very broad concept. Other tools, or databases
								refer to it as expression or column. When you just want to </fo:block>

							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT 1 FROM DUAL</fo:block>
							<fo:block font-size="11pt">
								Then 1 is considered a Field or more explicitly, a
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/Constant.java')">org.jooq.impl.Constant</fo:basic-link>,
								which implements Field, and DUAL is considered a Table or more explicitly
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/Dual.java')">org.jooq.impl.Dual</fo:basic-link>, which implements Table
							</fo:block>
							<fo:block font-size="11pt">
								More advanced uses become clear quickly, when you do things like
							</fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT 1 + 1 FROM DUAL</fo:block>
							<fo:block font-size="11pt">
								Where 1 + 1 itself is a Field or more explicitly, an
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/Expression.java')">org.jooq.impl.Expression</fo:basic-link>
								joining two Constants together.
							</fo:block>
							<fo:block font-size="11pt">
								See some details about how to create these queries in the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Query">Query section</fo:basic-link> of the manual
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">TableFields</fo:block>
							<fo:block font-size="11pt">
								A specific type of field is the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/TableField.java')">org.jooq.TableField</fo:basic-link>,
								which represents a physical
								Field in a physical Table. Both the
								TableField and its referenced Table
								know each other. The physical aspect
								of their nature is represented in
								jOOQ by
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="TABLE">meta model code generation</fo:basic-link>,
								where every entity in your database
								schema will be generated into a
								corresponding Java class.
							</fo:block>
							<fo:block font-size="11pt">
								TableFields join both &lt;R&gt; and &lt;T&gt; generic parameters into their specification:
							</fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public interface TableField&lt;R extends Record, T&gt; // [...]</fo:block>
							<fo:block font-size="11pt">
								This can be used for additional type safety in the future, or by client code.
							</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Result">
<fo:marker marker-class-name="section">
<fo:block>1.4. Results and Records</fo:block>
</fo:marker>1.4. Results and Records</fo:block>
<fo:block font-size="11pt">
							Results and their Records come into play, when SELECT statements are
							executed. There are various ways to fetch data from a jOOQ SELECT
							statement. Essentially, the query results are always provided in the
							Result API
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The Result</fo:block>
							<fo:block font-size="11pt">
								The
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Result.java')">Result</fo:basic-link>&lt;R extends <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Record.java')">Record</fo:basic-link>&gt;
								is essentially a wrapper for a List&lt;R extends Record&gt;
								providing
								many convenience methods for accessing single elements in
								the result
								set. Depending on the type of SELECT statement,
								&lt;R&gt; can be bound
								to a sub-type of Record, for instance to an
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/UpdatableRecord.java')">org.jooq.UpdatableRecord</fo:basic-link>.
								See the section on
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="UpdatableRecord">Updatable Records</fo:basic-link>
								for further details.
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The Cursor</fo:block>
							<fo:block font-size="11pt">
								A similar object is the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Cursor.java')">Cursor</fo:basic-link>&lt;R extends Record&gt;.
								Unlike the Result, the cursor has not fetched all data from the database yet.
								This means, you save memory (and potentially speed), but you can only access
								data sequentially and you have to keep a JDBC ResultSet alive. Cursors behave
								very much like the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html')">java.util.Iterator</fo:basic-link>,
								by providing a very simple API. Some sample methods are:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Check whether there are any more records to be fetched
boolean hasNext() throws SQLException;

// Fetch the next record from the underlying JDBC ResultSet
R fetchOne() throws SQLException;

// Close the underlying JDBC ResultSet. Don't forget to call this, before disposing the Cursor.
void close() throws SQLException;</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The Record</fo:block>
							<fo:block font-size="11pt">
								The Record itself holds all the data from your selected tuple. If it is
								a <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/TableRecord.java')">org.jooq.TableRecord</fo:basic-link>, then it corresponds exactly to the type of one of your
								physical tables in your database. But any anonymous or ad-hoc tuple can
								be represented by the plain Record. A record mainly provides access to
								its data and adds convenience methods for data type conversion. These
								are the main access ways:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// If you can keep a reference of the selected field, then you can get the corresponding value type-safely
&lt;T&gt; T getValue(Field&lt;T&gt; field);

// If you know the name of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(String fieldName);

// If you know the index of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(int index);</fo:block>
							<fo:block font-size="11pt">
								In some cases, you will not be able to reference the selected Fields
								both when you create the SELECT statement and when you fetch data from
								Records. Then you might use field names or indexes, as with JDBC.
								However, of course, the type information will then be lost as well. If
								you know what type you want to get, you can always use the Record's
								convenience methods for type conversion, however. Some examples:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// These methods will try to convert a value to a BigDecimal.
// This will work for all numeric types and for CHAR/VARCHAR types, if they contain numeric values:
BigDecimal getValueAsBigDecimal(String fieldName);
BigDecimal getValueAsBigDecimal(int fieldIndex);

// This method can perform arbitrary conversions
&lt;T&gt; T getValue(String fieldName, Class&lt;? extends T&gt; type);
&lt;T&gt; T getValue(int fieldIndex, Class&lt;? extends T&gt; type);</fo:block>

							<fo:block font-size="11pt">
								For more information about the type conversions that are supported by
								jOOQ, read the Javadoc on
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/tools/Convert.java')">org.jooq.tools.Convert</fo:basic-link>
							</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="UpdatableRecord">
<fo:marker marker-class-name="section">
<fo:block>1.5. Updatable Records</fo:block>
</fo:marker>1.5. Updatable Records</fo:block>
<fo:block font-size="11pt">
							UpdatableRecords are a specific subtype of TableRecord that have
							primary key information associated with them.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">CRUD Operations</fo:block>
							<fo:block font-size="11pt">As of jOOQ 1.5, the UpdatableRecord essentially contains three additional
							 methods <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://de.wikipedia.org/wiki/CRUD')">CRUD</fo:basic-link>
							 (Create Read Update Delete) operations: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Store any changes made to this record to the database.
// The record executes an INSERT if the PRIMARY KEY is NULL or has been changed. Otherwise, an UPDATE is performed.
int store();

// Deletes the record from the database.
int delete();

// Reflects changes made in the database to this Record
void refresh();</fo:block>
							<fo:block font-size="11pt">An example lifecycle of a book can be implemented as such:</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.store();

// Update it with new values
book.setPublishedIn(2010);
book.store();

// Delete it
book.delete();</fo:block>
							<fo:block font-size="11pt">These operations are very simple utilities. They do not
							reflect the functionality offered by <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://www.hibernate.org/')">Hibernate</fo:basic-link>
							or other persistence managers. </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Performing CRUD on non-updatable records</fo:block>
							<fo:block font-size="11pt">
								If the jOOQ code-generator cannot detect any PRIMARY KEY, or UNIQUE KEY
								on your tables, then the generated artefacts implement TableRecord,
								instead of UpdatableRecord. A TableRecord can perform the same CRUD
								operations as we have seen before, if you provide it with the necessary
								key fields. The API looks like this:
							</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// INSERT or UPDATE the record using the provided keys
int storeUsing(TableField&lt;R, ?&gt;... keys)

// DELETE a record using the provided keys
int deleteUsing(TableField&lt;R, ?&gt;... keys);

// Reflects changes made in the database to this Record
void refreshUsing(TableField&lt;R, ?&gt;... keys);</fo:block>

							<fo:block font-size="11pt">
								This is useful if your RDBMS does not support referential constraints (e.g. MySQL's
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://en.wikipedia.org/wiki/MyISAM')">MyISAM</fo:basic-link>), or if you want to
								store records to an unconstrained view. An example lifecycle of a book without
								any keys can then be implemented as such:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.storeUsing(TBook.ID);

// Update it with new values
book.setPublishedIn(2010);
book.storeUsing(TBook.ID);

// Delete it
book.deleteUsing(TBook.ID);</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Query">
<fo:marker marker-class-name="section">
<fo:block>1.6. The Query and its various subtypes</fo:block>
</fo:marker>1.6. The Query and its various subtypes</fo:block>
<fo:block font-size="11pt">
							The Query type hierarchy is what you use to execute queries. It has the
							following subtypes for each kind of operation
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">SELECT statements</fo:block>
							<fo:block font-size="11pt">
								There are essentially two ways of creating SELECT statements in jOOQ.
								For historical reasons, you can create
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SimpleSelectQuery.java')">org.jooq.SimpleSelectQuery</fo:basic-link> or
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectQuery.java')">org.jooq.SelectQuery</fo:basic-link>
								objects and add additional query clauses, such as
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Condition.java')">Conditions</fo:basic-link> or
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SortField.java')">SortFields</fo:basic-link> to it.
								Since jOOQ 1.3, there is also the possibility to
								create SELECT statements using jOOQ's
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="DSL">DSL API</fo:basic-link> in a much more intuitive
								and SQL-like way.
							</fo:block>
							<fo:block font-size="11pt">Use the DSL API when: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">You want your code to look like SQL</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">You want your IDE to help you with auto-completion (you will not be able to write select .. order by .. where .. join or any of that stuff) </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">Use the regular API when: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">You want to create your query step-by-step, creating query parts one-by-one</fo:block>
</fo:list-item-body>
</fo:list-item>
							    <fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">You need to assemble your query from various places, passing the query around, adding new conditions and joins on the way </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">In any case, all API's will construct the same underlying
								implementation object, and in many cases, you can combine the two
								approaches. Let's check out the various SELECT statement types: </fo:block>

							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java')">org.jooq.Select</fo:basic-link>:
								    This Query subtype stands for a general type of SELECT statement.
								    It is also the main Select type for the
								    <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="DSL">DSL API</fo:basic-link>. When executed, this object
								    will hold a <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Result">Result containing the resulting Records</fo:basic-link>.
								    This type is further subtyped for the various uses of a SELECT statement as such:</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SimpleSelectQuery.java')">org.jooq.SimpleSelectQuery</fo:basic-link>:
									This Query will allow for selecting from single physical Tables only.
									It therefore has access to the Table's generic type parameter
									&lt;R extends Record&gt; and will provide a matching Result&lt;R&gt;.
									This is especially useful if &lt;R&gt; is a subtype of
									<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="UpdatableRecord">UpdatableRecord</fo:basic-link>.
									Then you will be able to perform updates on your result set immediately.</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectQuery.java')">org.jooq.SelectQuery</fo:basic-link>:
									This Query will allow for selecting a subset of Fields from several
									Tables. Because the results of such a query are considered of an anonymous
									or ad-hoc type, this Query will bind &lt;R&gt; to the general type Record
									itself. The purpose of this Query type is to allow for full SQL support,
									including SELECT, JOIN and GROUP BY clauses. </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: SQL query and DSL query</fo:block>
							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- Select all books by authors born after 1920, named "Paulo"
-- from a catalogue consisting of authors and books:


SELECT *
  FROM t_author
  JOIN t_book
    ON t_author.id = t_book.author_id
 WHERE t_author.year_of_birth &gt; 1920
   AND t_author.first_name = 'Paulo'
 ORDER BY t_book.title</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Instanciate your factory using a JDBC connection.
Factory create = new Factory(connection, SQLDialect.ORACLE);

// Execute the query "on a single line"
Result&lt;Record&gt; result = create.select()
    .from(T_AUTHOR)
    .join(T_BOOK)
    .on(T_AUTHOR.ID.equal(T_BOOK.AUTHOR_ID))
    .where(T_AUTHOR.YEAR_OF_BIRTH.greaterThan(1920)
    .and(T_AUTHOR.FIRST_NAME.equal("Paulo")))
    .orderBy(T_BOOK.TITLE).fetch();</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-size="11pt">
								In the above example, some generated artefacts are used for querying.
								In this case, T_AUTHOR and T_BOOK are instances of types
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/test/oracle/generatedclasses/tables/TAuthor.java')">TAuthor</fo:basic-link> and
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/test/oracle/generatedclasses/tables/TBook.java')">TBook</fo:basic-link> respectively.
								Their full qualification would read TAuthor.T_AUTHOR and TBook.T_BOOK, but in many cases,
								it's useful to static import elements involved with queries, in order to decrease verbosity:
								<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">import static com.example.jooq.Tables.*;</fo:block>
							</fo:block>

							<fo:block font-size="11pt">
								Apart from the singleton Table instances TAuthor.T_AUTHOR and
								TBook.T_BOOK, these generated classes also contain one member
								for every physical field, such as TAuthor.ID or TBook.TAUTHOR_ID, etc.
								Depending on your configuration, those members can be static members
								(better for static imports) or instance members (better for aliasing)
							</fo:block>

							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">For more information about code generation, check out the manual's section about
									<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="META">Meta model source code generation</fo:basic-link>.</fo:block>
</fo:list-item-body>
</fo:list-item>
    							<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">For more DSL examples, please consider the manual's section about the
    								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="DSL">DSL API</fo:basic-link>.</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: Non-DSL query</fo:block>
							<fo:block font-size="11pt">
								If you choose not to use the DSL API (for instance, because you don't
								want to add Query parts in the order SQL expects them), you can use
								this syntax:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Re-use the factory to create a SelectQuery. This example will not make use of static imports...
SelectQuery q = create.selectQuery();
q.addFrom(T_AUTHOR);

// This example shows some "mixed" API usage, where the JOIN is added with the standard API, and the
// Condition is created using the DSL API
q.addJoin(T_BOOK, T_AUTHOR.ID.equal(T_BOOK.AUTHOR_ID));

// The AND operator between Conditions is implicit here
q.addConditions(T_AUTHOR.YEAR_OF_BIRTH.greaterThan(1920));
q.addConditions(T_AUTHOR.FIRST_NAME.equal("Paulo"));
q.addOrderBy(T_BOOK.TITLE);</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Fetching data</fo:block>
							<fo:block font-size="11pt">
								The <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java')">org.jooq.Select</fo:basic-link> interface extends
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/ResultQuery.java')">org.jooq.ResultQuery</fo:basic-link>,
								which provides a range of methods to fetch data from the database.
								Once you have constructed your SELECT query (see examples above), you
								may choose to either simply execute() it, or use a variety of convenience
								fetchXXX() methods.
							</fo:block>
							<fo:block font-size="11pt">
								See the manual's
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="ResultQuery">section on the ResultQuery</fo:basic-link>
								for more details.
							</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">INSERT Statements</fo:block>
							<fo:block font-size="11pt">jOOQ supports two modes for INSERT statements.
							The INSERT VALUES and the INSERT SELECT syntax</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: SQL query and DSL query</fo:block>
							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">INSERT INTO T_AUTHOR
    (ID, FIRST_NAME, LAST_NAME)
VALUES
    (100, 'Hermann', 'Hesse'),
    (101, 'Alfred', 'Döblin');</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.insertInto(T_AUTHOR,
        T_AUTHOR.ID, T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .values(100, "Hermann", "Hesse")
      .values(101, "Alfred", "Döblin")
      .execute();</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-size="11pt">The DSL syntax tries to stay close to actual SQL. In detail,
								however, Java is limited in its possibilities. That's why the
								.values() clause is repeated for every record in multi-record inserts.
								Some RDBMS support
								inserting several records at the same time. This is also supported in
								jOOQ, and simulated using UNION clauses for those RDBMS that don't
								support this syntax.
								<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">INSERT INTO .. SELECT .. UNION ALL SELECT ..</fo:block>
							</fo:block>
							<fo:block font-size="11pt">Note: Just like in SQL itself, you can have syntax errors when you
								don't have matching numbers of fields/values. Also, you can run into
								runtime problems, if your field/value types don't match. </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: DSL Query, alternative syntax</fo:block>
							<fo:block font-size="11pt">MySQL (and some other RDBMS) allow for using an UPDATE-like syntax
								for INSERT statements. This is also supported in jOOQ, should you
								prefer that syntax. The above INSERT statement can also be expressed
								as follows: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.insertInto(T_AUTHOR)
      .set(T_AUTHOR.ID, 100)
      .set(T_AUTHOR.FIRST_NAME, "Hermann")
      .set(T_AUTHOR.LAST_NAME, "Hesse")
      .newRecord()
      .set(T_AUTHOR.ID, 101)
      .set(T_AUTHOR.FIRST_NAME, "Alfred")
      .set(T_AUTHOR.LAST_NAME, "Döblin")
      .execute();</fo:block>
							<fo:block font-size="11pt">As you can see, this syntax is a bit more verbose, but also more
								type-safe, as every field can be matched with its value.</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: ON DUPLICATE KEY UPDATE clause</fo:block>
							<fo:block font-size="11pt">The MySQL database supports a very convenient way to INSERT or
								UPDATE a record. This is a non-standard extension to the SQL syntax,
								which is supported by jOOQ and simulated in other RDBMS, where this is
								possible. Here is an example how to use the ON DUPLICATE KEY UPDATE
								clause: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Add a new author called "Koontz" with ID 3.
// If that ID is already present, update the author's name
create.insertInto(T_AUTHOR, T_AUTHOR.ID, T_AUTHOR.LAST_NAME)
      .values(3, "Koontz")
      .onDuplicateKeyUpdate()
      .set(T_AUTHOR.LAST_NAME, "Koontz")
      .execute();</fo:block>

      						<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: INSERT .. RETURNING clause</fo:block>
							<fo:block font-size="11pt">The Postgres database has native support for an INSERT .. RETURNING
								clause. This is a very powerful concept that is simulated for all
								other dialects using JDBC's
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/Statement.html#getGeneratedKeys()')">getGeneratedKeys()</fo:basic-link>
								method. Take this example:</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Add another author, with a generated ID
Record&lt;?&gt; record =
create.insertInto(T_AUTHOR, T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .values("Charlotte", "Roche")
      .returning(T_AUTHOR.ID)
      .fetchOne();

System.out.println(record.getValue(T_AUTHOR.ID));

// For some RDBMS, this also works when inserting several values
// The following should return a 2x2 table
Result&lt;?&gt; result =
create.insertInto(T_AUTHOR, T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .values("Johann Wolfgang", "von Goethe")
      .values("Friedrich", "Schiller")
      // You can request any field. Also trigger-generated values
      .returning(T_AUTHOR.ID, T_AUTHOR.CREATION_DATE)
      .fetch();</fo:block>

      						<fo:block font-size="11pt">
      							Be aware though, that this can lead to race-conditions
      							in those databases that cannot properly return generated
      							ID values.
      						</fo:block>

      						<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: Non-DSL Query</fo:block>
      						<fo:block font-size="11pt">You can always use the more verbose regular syntax of the InsertQuery, if you need more control: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(T_AUTHOR.ID, 100);
i.addValue(T_AUTHOR.FIRST_NAME, "Hermann");
i.addValue(T_AUTHOR.LAST_NAME, "Hesse");

i.newRecord();
i.addValue(T_AUTHOR.ID, 101);
i.addValue(T_AUTHOR.FIRST_NAME, "Alfred");
i.addValue(T_AUTHOR.LAST_NAME, "Döblin");
i.execute();</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: INSERT Query combined with SELECT statements</fo:block>
							<fo:block font-size="11pt">The InsertQuery.addValue() method is overloaded, such that you can
								also provide a Field, potentially containing an expression: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(T_AUTHOR.ID, create.select(max(T_AUTHOR.ID).add(1)).from(T_AUTHOR).asField())
i.addValue(T_AUTHOR.FIRST_NAME, "Hermann");
i.addValue(T_AUTHOR.LAST_NAME, "Hesse");
i.execute();</fo:block>
							<fo:block font-size="11pt">Note that especially MySQL (and some other RDBMS) has some
								limitations regarding that syntax. You may not be able to
								select from the same table you're inserting into</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: INSERT SELECT syntax support</fo:block>
							<fo:block font-size="11pt">In some occasions, you may prefer the INSERT SELECT syntax, for instance, when
								you copy records from one table to another: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Insert i = create.insertInto(T_AUTHOR_ARCHIVE,
           create.selectFrom(T_AUTHOR).where(T_AUTHOR.DECEASED.equal(1)));
i.execute();</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">UPDATE Statements</fo:block>
							<fo:block font-size="11pt">UPDATE statements are only possible on single tables. Support for
							multi-table updates will be implemented in the near future. </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: SQL query and DSL query</fo:block>
							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">UPDATE T_AUTHOR
   SET FIRST_NAME = 'Hermann',
       LAST_NAME = 'Hesse'
 WHERE ID = 3;
 </fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.update(T_AUTHOR)
      .set(T_AUTHOR.FIRST_NAME, "Hermann")
      .set(T_AUTHOR.LAST_NAME, "Hesse")
      .where(T_AUTHOR.ID.equal(3))
      .execute();</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: Non-DSL Query</fo:block>
							<fo:block font-size="11pt">Using the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/UpdateQuery.java')">org.jooq.UpdateQuery</fo:basic-link> class,
							this is how you could express an UPDATE statement:</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">UpdateQuery&lt;TAuthorRecord&gt; u = create.updateQuery(T_AUTHOR);
u.addValue(T_AUTHOR.FIRST_NAME, "Hermann");
u.addValue(T_AUTHOR.FIRST_NAME, "Hesse");
u.addConditions(T_AUTHOR.ID.equal(3));
u.execute();</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">DELETE Statements</fo:block>
							<fo:block font-size="11pt">DELETE statements are only possible on single tables. Support for
							multi-table deletes will be implemented in the near future. </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: SQL query and DSL query</fo:block>
							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">DELETE T_AUTHOR
 WHERE ID = 100;
 </fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.delete(T_AUTHOR)
      .where(T_AUTHOR.ID.equal(100))
      .execute();</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: Non-DSL Query</fo:block>
							<fo:block font-size="11pt">Using the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/DeleteQuery.java')">org.jooq.DeleteQuery</fo:basic-link> class,
							this is how you could express a DELETE statement: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">DeleteQuery&lt;TAuthorRecord&gt; d = create.deleteQuery(T_AUTHOR);
d.addConditions(T_AUTHOR.ID.equal(100));
d.execute();</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">MERGE Statement</fo:block>
							<fo:block font-size="11pt">
								The MERGE statement is one of the most advanced standardised SQL
								constructs, which is supported by DB2, HSQLDB, Oracle, SQL Server and
								Sybase (MySQL has the similar INSERT .. ON DUPLICATE KEY UPDATE
								construct. H2's MERGE variant is currently not supported.)
							</fo:block>
							<fo:block font-size="11pt">
								The point of the standard MERGE statement is to take a TARGET table, and
								merge (INSERT, UPDATE) data from a SOURCE table into it. DB2, Oracle,
								SQL Server and Sybase also allow for DELETING some data and for adding
								many additional clauses. With jOOQ 2.0.1, only Oracle's MERGE extensions are supported.
								Here is an example:
							</fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- Check if there is already an author called 'Hitchcock'
-- If there is, rename him to John. If there isn't add him.

MERGE INTO T_AUTHOR
USING (SELECT 1 FROM DUAL)
ON (LAST_NAME = 'Hitchcock')
WHEN MATCHED THEN UPDATE SET FIRST_NAME = 'John'
WHEN NOT MATCHED THEN INSERT (LAST_NAME)
                      VALUES ('Hitchcock')</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.mergeInto(T_AUTHOR)
      .using(create().selectOne())
      .on(T_AUTHOR.LAST_NAME.equal("Hitchcock"))
      .whenMatchedThenUpdate()
      .set(T_AUTHOR.FIRST_NAME, "John")
      .whenNotMatchedThenInsert(T_AUTHOR.LAST_NAME)
      .values("Hitchcock")
      .execute();

</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">TRUNCATE Statement</fo:block>
							<fo:block font-size="11pt">
								The syntax is trivial:
							</fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">TRUNCATE TABLE T_AUTHOR;</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.truncate(T_AUTHOR).execute();</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>
							<fo:block font-size="11pt">This is not supported by Ingres and SQLite. jOOQ will execute a DELETE FROM
								T_AUTHOR statement instead. </fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="ResultQuery">
<fo:marker marker-class-name="section">
<fo:block>1.7. ResultQuery and various ways of fetching data</fo:block>
</fo:marker>1.7. ResultQuery and various ways of fetching data</fo:block>
<fo:block font-size="11pt">
							Various jOOQ query type extend the ResultQuery which provides many means of
							fetching data. In general, fetching means executing and returning some
							sort of result.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The ResultQuery provides many convenience methods</fo:block>
							<fo:block font-size="11pt">These methods allow for fetching a jOOQ Result or parts of it.</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// Fetch the whole result
Result<R> fetch();

// Fetch a single field from the result
<T> List<T> fetch(Field<T> field);
    List<?> fetch(int fieldIndex);
<T> List<T> fetch(int fieldIndex, Class<? extends T> type);
    List<?> fetch(String fieldName);
<T> List<T> fetch(String fieldName, Class<? extends T> type);

// Fetch the first Record
R fetchAny();

// Fetch exactly one Record
R fetchOne();

// Fetch a single field of exactly one Record
<T> T  fetchOne(Field<T> field);
Object fetchOne(int fieldIndex);
<T> T  fetchOne(int fieldIndex, Class<? extends T> type);
Object fetchOne(String fieldName);
<T> T  fetchOne(String fieldName, Class<? extends T> type);]]></fo:block>

							<fo:block font-size="11pt">These methods transform the result into another form, if org.jooq.Result is not optimal</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// Fetch the resulting records as Maps
List<Map<String, Object>> fetchMaps();
     Map<String, Object>  fetchOneMap();

// Fetch the result as a Map
<K>    Map<K, R> fetchMap(Field<K> key);
<K, V> Map<K, V> fetchMap(Field<K> key, Field<V> value);

// Fetch the resulting records as arrays
Object[][] fetchArrays();
Object[]   fetchOneArray();

// Fetch a single field as an array
<T>  T[] fetchArray(Field<T> field);
Object[] fetchArray(int fieldIndex);
<T>  T[] fetchArray(int fieldIndex, Class<? extends T> type);
Object[] fetchArray(String fieldName);
<T>  T[] fetchArray(String fieldName, Class<? extends T> type);]]></fo:block>

							<fo:block font-size="11pt">These methods transform the result into a user-defined form, if org.jooq.Result is not optimal</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// Fetch the resulting records into a custom POJO
// type, which may or may not be JPA-annotated
<E> List<E> fetchInto(Class<? extends E> type);

// Fetch the resulting records into a custom
// record handler, similar to how Spring JdbcTemplate's
// RowMapper or the Ollin Framework works.
<H extends RecordHandler<R>> H fetchInto(H handler);

// These change the behaviour of fetching itself,
// especially, when not all data should be
// fetched at once
// ----------------------------------------------

// Fetch a Cursor for lazy iteration
Cursor<R> fetchLazy();

// Fetch data asynchronously and let client code
// decide, when the data must be available.
// This makes use of the java.util.concurrent API,
// Similar to how Avajé Ebean works.
FutureResult<R> fetchLater();
FutureResult<R> fetchLater(ExecutorService executor);]]></fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="BindValues">
<fo:marker marker-class-name="section">
<fo:block>1.8. Bind values</fo:block>
</fo:marker>1.8. Bind values</fo:block>
<fo:block font-size="11pt">
							Variable binding has a great impact on how you design your SQL queries.
							It will influence your SQL queries' security aspect as well as execution speed.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Bind values</fo:block>
							<fo:block font-size="11pt">
								Bind values are used in SQL / JDBC for various reasons. Among the most
								obvious ones are:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
									Protection against SQL injection. Instead of inlining values
									possibly originating from user input, you bind those values to
									your prepared statement and let the JDBC driver / database take
									care of handling security aspects.
								</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
									Increased speed. Advanced databases such as Oracle can keep
									execution plans of similar queries in a dedicated cache to prevent
									hard-parsing your query again and again. In many cases, the actual
									value of a bind variable does not influence the execution plan, hence
									it can be reused. Preparing a statement will thus be faster
								</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
									On a JDBC level, you can also reuse the SQL string and prepared statement
									object instead of constructing it again, as you can bind new values to
									the prepared statement. This is currently not supported by jOOQ, though
								</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Ways to introduce bind values with jOOQ</fo:block>
							<fo:block font-size="11pt">
								Bind values are omni-present in jOOQ. Whenever you create a condition,
								you're actually also adding a bind value:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// In jOOQ, "Poe" will be the bind value bound to the condition
LAST_NAME.equal("Poe");</fo:block>


							<fo:block font-size="11pt">
								The above notation is actually convenient way to explicitly create
								a bind value for "Poe". You could also write this, instead:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// The Factory allows for explicitly creating bind values
LAST_NAME.equal(Factory.val("Poe"));

// Or, when static importing Factory.val:
LAST_NAME.equal(val("Poe"))</fo:block>

							<fo:block font-size="11pt">
								Once created, bind values are part of the query's syntax tree (see
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="QueryPart">the manual's section about jOOQ's architecture</fo:basic-link>
							    for more information about jOOQ's internals),
								and cannot be modified directly anymore. If you wish to reuse a query and
								modify bind values between subsequent query executions, you can access them again
								through the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Query.java')">org.jooq.Query</fo:basic-link> interface:
							</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// Access the first bind value from a query. Indexes are counted from 1, just as with JDBC
Query query = create.select().from(T_AUTHOR).where(LAST_NAME.equal("Poe"));
Param<?> param = query.getParam("1");

// You could now modify the Query's underlying bind value:
if ("Poe".equal(param.getValue())) {
    param.setConverted("Orwell");
}]]></fo:block>

							<fo:block font-size="11pt">
								The <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Param.java')">org.jooq.Param</fo:basic-link> type can also be named explicitly
								using the Factory's param() methods:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// Create a query with a named parameter. You can then use that name for accessing the parameter again
Query query1 = create.select().from(T_AUTHOR).where(LAST_NAME.equal(param("lastName", "Poe")));
Param<?> param1 = query.getParam("lastName");

// Or, keep a reference to the typed parameter in order not to lose the <T> type information:
Param<String> param2 = param("lastName", "Poe");
Query query2 = create.select().from(T_AUTHOR).where(LAST_NAME.equal(param2));

// You can now change the bind value directly on the Param reference:
param2.setValue("Orwell");
]]></fo:block>

							<fo:block font-size="11pt">
								The <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Query.java')">org.jooq.Query</fo:basic-link> interface also allows for
								setting new bind values directly, without accessing the Param type:
							</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Query query1 = create.select().from(T_AUTHOR).where(LAST_NAME.equal("Poe"));
query1.bind(1, "Orwell");

// Or, with named parameters
Query query2 = create.select().from(T_AUTHOR).where(LAST_NAME.equal(param("lastName", "Poe")));
query2.bind("lastName", "Orwell");</fo:block>

							<fo:block font-size="11pt">
								NOTE: Should you wish to use jOOQ only as a query builder and execute
								queries with another tool, such as Spring Data instead, you can also
								use the Factory's renderNamedParams() method, to actually render named
								parameter names in generated SQL:
							</fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- The named bind variable can be rendered

SELECT *
FROM T_AUTHOR
WHERE LAST_NAME = :lastName
</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.renderNamedParams(
    create.select()
          .from(T_AUTHOR)
          .where(LAST_NAME.equal(
                 param("lastName", "Poe"))));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="QueryPart">
<fo:marker marker-class-name="section">
<fo:block>1.9. QueryParts and the global architecture</fo:block>
</fo:marker>1.9. QueryParts and the global architecture</fo:block>
<fo:block font-size="11pt">When constructing Query objects in jOOQ, everything is
							considered a QueryPart. The purpose of this quickly becomes clear when
							checking out the QueryPart API essentials</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Everything is a QueryPart</fo:block>
							<fo:block font-size="11pt">
								A
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Query.java')">org.jooq.Query</fo:basic-link>
								and all its contained objects is a
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/QueryPart.java')">org.jooq.QueryPart</fo:basic-link>.
								QueryParts essentially provide this functionality:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">they can render SQL using the toSQL(RenderContext) method</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">they can bind variables using the bind(BindContext) method</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-size="11pt">Both of these methods are contained in jOOQ's internal API's
							   <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/QueryPartInternal.java')">org.jooq.QueryPartInternal</fo:basic-link>, which is
							   internally implemented by every QueryPart. QueryPart internals are best
							   illustrated with an example.</fo:block>

						   <fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: CompareCondition</fo:block>
						   <fo:block font-size="11pt">A simple example can be provided by checking out jOOQ's internal
								representation of a
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/CompareCondition.java')">org.jooq.impl.CompareCondition</fo:basic-link>.
								It is used for any condition
								comparing two fields as for example the T_AUTHOR.ID = T_BOOK.AUTHOR_ID
								condition here: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- [...]
FROM T_AUTHOR
JOIN T_BOOK ON T_AUTHOR.ID = T_BOOK.AUTHOR_ID
-- [...]</fo:block>

							<fo:block font-size="11pt">This is how jOOQ implements such a condition: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[@Override
public final void bind(BindContext context) throws SQLException {
    // The CompareCondition itself does not bind any variables.
    // But the two fields involved in the condition might do so...
    context.bind(field1).bind(field2);
}

@Override
public final void toSQL(RenderContext context) {
    // The CompareCondition delegates rendering of the Fields to the Fields
    // themselves and connects them using the Condition's comparator operator:
    context.sql(field1)
           .sql(" ");

    // If the second field is null, some convenience behaviour can be
    // implemented here
    if (field2.isNullLiteral()) {
        switch (comparator) {
            case EQUALS:
                context.sql("is null");
                break;

            case NOT_EQUALS:
                context.sql("is not null");
                break;

            default:
                throw new IllegalStateException("Cannot compare null with " + comparator);
        }
    }

    // By default, also delegate the right hand side's SQL rendering to the
    // underlying field
    else {
        context.sql(comparator.toSQL())
               .sql(" ")
               .sql(field2);
    }
}
]]></fo:block>
							<fo:block font-size="11pt">For more complex examples, please refer to the codebase, directly</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Serializability">
<fo:marker marker-class-name="section">
<fo:block>1.10. Serializability of QueryParts and Results</fo:block>
</fo:marker>1.10. Serializability of QueryParts and Results</fo:block>
<fo:block font-size="11pt">Most of the jOOQ API implements the Serializable interface.
							This helps storing queries and partial queries in files, transferring
							queries or result data over TCP/IP, etc. </fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Attaching QueryParts</fo:block>
							<fo:block font-size="11pt">
								The only transient element in any jOOQ object is the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Factory">The Factory class</fo:basic-link>'s
								underlying
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/Connection.html')">java.sql.Connection</fo:basic-link>. When you want to execute queries after
								de-serialisation, or when you want to store/refresh/delete
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="UpdatableRecord">Updatable Records</fo:basic-link>,
								you will have to "import" or "re-attach" them to a Factory
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Deserialise a SELECT statement
ObjectInputStream in = new ObjectInputStream(...);
Select&lt;?&gt; select = (Select&lt;?&gt;) in.readObject();

// This will throw a DetachedException:
select.execute();

// In order to execute the above select, attach it first
Factory create = new Factory(connection, SQLDialect.ORACLE);
create.attach(select);</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Automatically attaching QueryParts</fo:block>
							<fo:block font-size="11pt">In simple cases, you can register a ConfigurationProvider in jOOQ's ConfigurationRegistry</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Create your own custom ConfigurationProvider that will make
// your default Factory available to jOOQ
ConfigurationProvider provider = new CustomConfigurationProvider();

// Statically register the provider to jOOQ's ConfigurationRegistry
ConfigurationRegistry.setProvider(provider);</fo:block>

							<fo:block font-size="11pt">Once you have executed these steps, all subsequent deserialisations
								will try to access a Configuration (containing a JDBC Connection) from
								your ConfigurationProvider. This may be useful when </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">transporting jOOQ QueryParts or Records via TCP/IP, RMI, etc (e.g.
									between client and server), before immediately executing queries,
									storing UpdatableRecords</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
									Using automatic mechanisms as known in
									<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://wicket.apache.org/')">Wicket</fo:basic-link>
								</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Extend">
<fo:marker marker-class-name="section">
<fo:block>1.11. Extend jOOQ with custom types</fo:block>
</fo:marker>1.11. Extend jOOQ with custom types</fo:block>
<fo:block font-size="11pt">Maybe jOOQ is missing functionality that you would like to see,
							or you can't wait for the next release... In this case, you can extend
							any of the following open jOOQ implementation classes</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Write your own QueryPart implementations</fo:block>
							<fo:block font-size="11pt">If a SQL clause is too complex to express with jOOQ, you can extend
								either one of the following types for use directly in a jOOQ query:</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public abstract class CustomField&lt;T&gt; extends AbstractField&lt;T&gt; {
  // [...]
}
public abstract class CustomCondition extends AbstractCondition {
  // [...]
}</fo:block>

							<fo:block font-size="11pt">These two classes are declared public and covered by integration
								tests. When you extend these classes, you will have to provide your
								own implementations for the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="QueryPart">QueryParts</fo:basic-link>'
								bind(<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/BindContext.java')">BindContext</fo:basic-link>) and
								toSQL(<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/RenderContext.java')">RenderContext</fo:basic-link>) methods:</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// This method must produce valid SQL. If your QueryPart contains other QueryParts, you may delegate SQL code generation to them
// in the correct order, passing the render context.
//
// If context.inline() is true, you must inline all bind variables
// If context.inline() is false, you must generate ? for your bind variables
public void toSQL(RenderContext context);

// This method must bind all bind variables to a PreparedStatement. If your QueryPart contains other QueryParts, you may delegate
// variable binding to them in the correct order, passing the bind context.
//
// Every QueryPart must ensure, that it starts binding its variables at context.nextIndex().
public void bind(BindContext context) throws DataAccessException;</fo:block>

							<fo:block font-size="11pt">The above contract may be a bit tricky to understand at first. The
								best thing is to check out jOOQ source code and have a look at a
								couple of QueryParts, to see how it's done.</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Plain SQL as an alternative</fo:block>
							<fo:block font-size="11pt">If you don't need integration of rather complex QueryParts into
								jOOQ, then you might be safer using simple
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="SQL">Plain SQL</fo:basic-link> functionality,
								where you can provide jOOQ with a simple String representation of your
								embedded SQL. </fo:block>
						<fo:block break-after="page"/>
<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="META">
<fo:marker marker-class-name="section">
<fo:block>2. Meta model code generation</fo:block>
</fo:marker>2. Meta model code generation</fo:block>
<fo:block font-size="11pt">In these sections you will learn about how to configure and use
					jOOQ's source code generator</fo:block>
					<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Overview</fo:block>
					<fo:block font-size="11pt">
						In the previous chapter, we have seen how to use the
						<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Factory">Factory</fo:basic-link> in order to create
						<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Query">Queries</fo:basic-link> and fetch data in
						<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Result">Results</fo:basic-link>. The strength of jOOQ not
						only lies in its object-oriented
						<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="QueryPart">Query model</fo:basic-link>,
						but also in the fact
						that Java source code is generated from your database schema into the
						META data model. jOOQ follows the paradigm, that your database comes
						first (see also <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('&lt;?=$root?&gt;/')">home page</fo:basic-link>).
						This means that you should not modify
						generated source code, but only adapt entities in your database. Every
						change in your database is reflected in a corresponding change in your
						generated meta-model.
					</fo:block>
					<fo:block font-size="11pt">
						Artefacts, such as tables, views, user defined types, sequences, stored
						procedures, packages have a corresponding artefact in Java.
					</fo:block>
				<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Configuration">
<fo:marker marker-class-name="section">
<fo:block>2.1. Configuration and setup of the generator</fo:block>
</fo:marker>2.1. Configuration and setup of the generator</fo:block>
<fo:block font-size="11pt">jOOQ uses a simple configuration file to configure source code generation.</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The deliverables</fo:block>
							<fo:block font-size="11pt">
								There are three binaries available with jOOQ, to be downloaded from
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://sourceforge.net/projects/jooq/')">SourceForge</fo:basic-link>
								or from Maven central:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
									<fo:inline font-weight="bold">jOOQ.jar</fo:inline>
									<fo:block/>
									The main library that you will include in your application to run jOOQ
								</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
									<fo:inline font-weight="bold">jOOQ-meta.jar</fo:inline>
									<fo:block/>
									The utility that you will include in your build to navigate your
									database schema for code generation. This can be used as a schema
									crawler as well.
								</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
									<fo:inline font-weight="bold">jOOQ-codegen.jar</fo:inline>
									<fo:block/>
									The utility that you will include in your build to generate your
									database schema
								</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Dependencies</fo:block>
							<fo:block font-size="11pt">All of jOOQ's dependencies are "optional", i.e. you can run
								jOOQ without any of those libraries.
								For instance, jOOQ maintains an "optional" dependency on log4j and slf4j.
								This means, that jOOQ tries to find log4j (and /log4j.xml) or slf4j on the
								classpath. If they are not present, then java.util.logging.Logger is
								used instead.
							</fo:block>
							<fo:block font-size="11pt">
								Other optional dependencies are the JPA API, and the Oracle JDBC driver,
								which is needed for Oracle's advanced data types, only
							</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Configure jOOQ</fo:block>
							<fo:block font-size="11pt">You need to tell jOOQ some things about your database connection.
								Here's an example of how to do it for a MySQL database </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">#Configure the database connection here
jdbc.Driver=com.mysql.jdbc.Driver
jdbc.URL=jdbc:mysql://[your jdbc URL]
jdbc.User=[your database user]
jdbc.Password=[your database password]

#The default code generator. You can override this one, to generate your own code style
#Defaults to org.jooq.util.DefaultGenerator
generator=org.jooq.util.DefaultGenerator

#The database type. The format here is:
#generator.database=org.util.[database].[database]Database
generator.database=org.jooq.util.mysql.MySQLDatabase

#The schema that is used locally as a source for meta information. This could be your
#development schema or the production schema, etc:
generator.database.input-schema=[your database schema / owner / name]

#All elements that are generated from your schema (several Java regular expressions, separated by comma)
#Watch out for case-sensitivity. Depending on your database, this might be important!
#You can create case-insensitive regular expressions using this syntax: (?i:expr)
generator.database.includes=.*

#All elements that are excluded from your schema (several Java regular expressions, separated by comma). Excludes match before includes
generator.database.excludes=

#Primary key / foreign key relations should be generated and used.
#This will be a prerequisite for various advanced features
#Defaults to false
generator.generate.relations=true

#Generate deprecated code for backwards compatibility
#Defaults to true
generator.generate.deprecated=false

#The destination package of your generated classes (within the destination directory)
generator.target.package=[org.jooq.your.package]

#The destination directory of your generated classes
generator.target.directory=[/path/to/your/dir]</fo:block>

							<fo:block font-size="11pt">And you can add some optional advanced configuration parameters: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">#The schema that is used in generated source code. This will be the production schema
#Use this to override your local development schema name for source code generation
#If not specified, this will be the same as the input-schema.
generator.database.output-schema=[your database schema / owner / name]

#Generate java.sql.Timestamp fields for DATE columns. This is particularly useful for Oracle databases
#Defaults to false
generator.database.date-as-timestamp=true

#Generate instance fields in your tables, as opposed to static fields. This simplifies aliasing
#Defaults to true
generator.generate.instance-fields=true

#Generate the javax.annotation.Generated annotation to indicate jOOQ version used for source code
#generation. Defaults to true
generator.generate.generated-annotation=true

#Generate jOOU data types for your unsigned data types, which are not natively supported in Java
#Defaults to true
generator.generate.unsigned-types=true

#Generate a master data table enum classes (several Java regular expressions, separated by comma)
generator.generate.master-data-tables=[a list of tables]

#For every master data table, specify two special columns
generator.generate.master-data-table-literal.[master data table]=[column used for enum literals]
generator.generate.master-data-table-description.[master data table]=[column used for documentation]</fo:block>
							<fo:block font-size="11pt">Check out the manual's section about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="MasterData">master data</fo:basic-link>
								 to find out more
								about those advanced configuration parameters. </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Run jOOQ code generation</fo:block>
							<fo:block font-size="11pt">Code generation works by calling this class with the above property file as argument.</fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">org.jooq.util.GenerationTool /jooq-config.properties</fo:block>
							<fo:block font-size="11pt">Be sure that these elements are located on the classpath: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">The property file</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">jooq.jar, jooq-meta.jar, jooq-codegen.jar</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">The JDBC driver you configured</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">A command-line example (For Windows, unix/linux/etc will be similar)</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Put the property file, jooq*.jar and the JDBC driver into
									a directory, e.g. C:\temp\jooq</fo:block>
</fo:list-item-body>
</fo:list-item>
							    <fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Go to C:\temp\jooq</fo:block>
</fo:list-item-body>
</fo:list-item>
							    <fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Run java -cp jooq.jar;jooq-meta.jar;jooq-codegen.jar;[JDBC-driver].jar;. org.jooq.util.GenerationTool /[property file] </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">Note that the property file must be passed as a classpath resource</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Run code generation from Eclipse</fo:block>
							<fo:block font-size="11pt">Of course, you can also run code generation from your IDE. In
								Eclipse, set up a project like this. Note that this example uses
								jOOQ's log4j support by adding log4j.xml and log4j.jar to the project
								classpath: </fo:block>
							<fo:block font-size="11pt">
							<fo:block text-align="center">
<fo:external-graphic padding-top="10pt" padding-bottom="10pt" src="url('C:/Users/lukas/workspace/jOOQ-website/img/eclipse-example-01.png')"/>
</fo:block>
							</fo:block>

							<fo:block font-size="11pt">Once the project is set up correctly with all required artefacts on
								the classpath, you can configure an Eclipse Run Configuration for
								org.jooq.util.GenerationTool. </fo:block>
							<fo:block font-size="11pt">
							<fo:block text-align="center">
<fo:external-graphic padding-top="10pt" padding-bottom="10pt" src="url('C:/Users/lukas/workspace/jOOQ-website/img/eclipse-example-02.png')"/>
</fo:block>
							</fo:block>

							<fo:block font-size="11pt">With the properties file as an argument </fo:block>
							<fo:block font-size="11pt">
							<fo:block text-align="center">
<fo:external-graphic padding-top="10pt" padding-bottom="10pt" src="url('C:/Users/lukas/workspace/jOOQ-website/img/eclipse-example-03.png')"/>
</fo:block>
							</fo:block>

							<fo:block font-size="11pt">And the classpath set up correctly</fo:block>
							<fo:block font-size="11pt">
							<fo:block text-align="center">
<fo:external-graphic padding-top="10pt" padding-bottom="10pt" src="url('C:/Users/lukas/workspace/jOOQ-website/img/eclipse-example-04.png')"/>
</fo:block>
							</fo:block>

							<fo:block font-size="11pt">Finally, run the code generation and see your generated artefacts</fo:block>
							<fo:block font-size="11pt">
							<fo:block text-align="center">
<fo:external-graphic padding-top="10pt" padding-bottom="10pt" src="url('C:/Users/lukas/workspace/jOOQ-website/img/eclipse-example-05.png')"/>
</fo:block>
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Run generation with ant</fo:block>
							<fo:block font-size="11pt">
								You can also use an ant task to generate your classes. As a rule of thumb,
								remove the dots "." and dashes "-" from the .properties file's property names to get the
								ant task's arguments:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[<!-- Task definition -->
<taskdef name="generate-classes" classname="org.jooq.util.GenerationTask">
  <classpath>
    <fileset dir="${path.to.jooq.distribution}">
      <include name="jOOQ.jar"/>
      <include name="jOOQ-meta.jar"/>
      <include name="jOOQ-codegen.jar"/>
    </fileset>
    <fileset dir="${path.to.mysql.driver}">
      <include name="${mysql.driver}.jar"/>
    </fileset>
  </classpath>
</taskdef>

<!-- Run the code generation task -->
<target name="generate-test-classes">
  <generate-classes
      jdbcurl="jdbc:mysql://localhost/test"
      jdbcuser="root"
      jdbcpassword=""
      generatordatabaseinputschema="test"
      generatortargetpackage="org.jooq.test.generatedclasses"
      generatortargetdirectory="${basedir}/src"/>
</target>]]></fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Integrate generation with Maven</fo:block>
							<fo:block font-size="11pt">Using the official jOOQ-codegen-maven plugin, you can integrate
								source code generation in your Maven build process: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[<plugin>

  <!-- Specify the maven code generator plugin -->
  <groupId>org.jooq</groupId>
  <artifactId>jooq-codegen-maven</artifactId>
  <version>1.6.7</version>

  <!-- The plugin should hook into the generate goal -->
  <executions>
    <execution>
      <goals>
        <goal>generate</goal>
      </goals>
    </execution>
  </executions>

  <!-- Manage the plugin's dependency. In this example, we'll use a Postgres database -->
  <dependencies>
    <dependency>
      <groupId>postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <version>8.4-702.jdbc4</version>
    </dependency>
  </dependencies>

  <!-- Specify the plugin configuration -->
  <configuration>

    <!-- JDBC connection parameters -->
    <jdbc>
      <driver>org.postgresql.Driver</driver>
      <url>jdbc:postgresql:postgres</url>
      <user>postgres</user>
      <password>test</password>
    </jdbc>

    <!-- Generator parameters -->
    <generator>
      <name>org.jooq.util.DefaultGenerator</name>
      <database>
        <name>org.jooq.util.postgres.PostgresDatabase</name>
        <includes>.*</includes>
        <excludes></excludes>
        <inputSchema>public</inputSchema>
      </database>
      <generate>
        <relations>true</relations>
        <deprecated>false</deprecated>
      </generate>
      <target>
        <packageName>org.jooq.util.maven.example</packageName>
        <directory>target/generated-sources/jooq</directory>
      </target>
      <masterDataTables>
        <masterDataTable>
          <name>t_language</name>
          <literal>cd</literal>
          <description>description</description>
        </masterDataTable>
      </masterDataTables>
    </generator>
  </configuration>
</plugin>
]]></fo:block>
							<fo:block font-size="11pt">See the full example of a pom.xml including the jOOQ-codegen artefact here:
							<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ-codegen-maven-example/pom.xml')">https://github.com/lukaseder/jOOQ/blob/master/jOOQ-codegen-maven-example/pom.xml</fo:basic-link>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Use jOOQ generated classes in your application</fo:block>
							<fo:block font-size="11pt">Be sure, both jOOQ.jar and your generated package (see
								configuration) are located on your classpath. Once this is done, you
								can execute SQL statements with your generated classes.</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="SCHEMA">
<fo:marker marker-class-name="section">
<fo:block>2.2. The schema, top-level generated artefact</fo:block>
</fo:marker>2.2. The schema, top-level generated artefact</fo:block>
<fo:block font-size="11pt">The schema is the top-level generated object in jOOQ. In many
							RDBMS, the schema coincides with the owner of tables and other objects
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The Schema</fo:block>
							<fo:block font-size="11pt">
								As of jOOQ 1.5, the top-level generated object is the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Schema.java')">org.jooq.Schema</fo:basic-link>.
								The Schema itself has no relevant functionality, except for holding
								the schema name for all dependent generated artefacts. jOOQ queries try
								to always fully qualify an entity within the database using that Schema
							</fo:block>

							<fo:block font-size="11pt">
								Currently, it is not possible to link generated artefacts from various
								schemata. If you have a stored function from Schema A, which returns a
								UDT from Schema B, the types cannot be linked. This enhancement is on
								the roadmap, though: <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://sourceforge.net/apps/trac/jooq/ticket/282')">#282</fo:basic-link>.
							</fo:block>

							<fo:block font-size="11pt">
								When you have several schemata that are logically equivalent (i.e. they
								contain identical entities, but the schemata stand for different
								users/customers/clients, etc), there is a solution for that. Check out
								the manual's section on support for
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="SchemaMapping">multiple equivalent schemata</fo:basic-link>
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Schema contents</fo:block>
							<fo:block font-size="11pt">The schema can be used to dynamically discover generate database
								artefacts. Tables, sequences, and other items are accessible from the
								schema. For example:</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public final java.util.List&lt;org.jooq.Sequence&lt;?&gt;&gt; getSequences();
public final java.util.List&lt;org.jooq.Table&lt;?&gt;&gt; getTables();</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="TABLE">
<fo:marker marker-class-name="section">
<fo:block>2.3. Tables, views and their corresponding records</fo:block>
</fo:marker>2.3. Tables, views and their corresponding records</fo:block>
<fo:block font-size="11pt">
							The most important generated artefacts are Tables and TableRecords.
							Every Table has a Record type associated with it that models a single tuple
							of that entity: Table&lt;R extends Record&gt;.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Tables and TableRecords</fo:block>
							<fo:block font-size="11pt">
								The most important generated artefacts are
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Table.java')">Tables</fo:basic-link> and
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/TableRecord.java')">TableRecords</fo:basic-link>. As
								discussed in previous chapters about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Table">Tables</fo:basic-link> and
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Result">Results</fo:basic-link>, jOOQ uses the
								Table class to model entities (both tables and views) in your database
								Schema. Every Table has a Record type associated with it that models a
								single tuple of that entity: Table&lt;R extends Record&gt;. This
								couple of Table&lt;R&gt; and R are generated as such:
							</fo:block>
							<fo:block font-size="11pt">
								Suppose we have the tables as defined in the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="ExampleDatabase">example database</fo:basic-link>.
								Then, using a
								default configuration, these (simplified for the example) classes will
								be generated:
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The Table as an entity meta model</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public class TAuthor extends UpdatableTableImpl&lt;TAuthorRecord&gt; {

    // The singleton instance of the Table
    public static final TAuthor T_AUTHOR = new TAuthor();

    // The Table's fields.
    // Depending on your jooq-codegen configuraiton, they can also be static
    public final TableField&lt;TAuthorRecord, Integer&gt; ID =            // [...]
    public final TableField&lt;TAuthorRecord, String&gt; FIRST_NAME =     // [...]
    public final TableField&lt;TAuthorRecord, String&gt; LAST_NAME =      // [...]
    public final TableField&lt;TAuthorRecord, Date&gt; DATE_OF_BIRTH =    // [...]
    public final TableField&lt;TAuthorRecord, Integer&gt; YEAR_OF_BIRTH = // [...]

    // When you don't choose the static meta model, you can typesafely alias your tables.
    // Aliased tables will then hold references to the above final fields, too
    public TAuthor as(String alias) {
      // [...]
    }
}</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The Table's associated TableRecord</fo:block>
							<fo:block font-size="11pt">If you use the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Query">SimpleSelectQuery</fo:basic-link>
								 syntax (both in standard and DSL
								mode), then your SELECT statement will return the single Table&lt;R
								extends Record&gt;'s associated Record type &lt;R&gt;. In the case of
								the above TAuthor Table, this will be a TAuthorRecord. </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public class TAuthorRecord extends UpdatableRecordImpl&lt;TAuthorRecord&gt; {

    // Getters and setters for the various fields
    public void setId(Integer value) {       // [...]
    public Integer getId() {                 // [...]
    public void setFirstName(String value) { // [...]
    public String getFirstName() {           // [...]
    public void setLastName(String value) {  // [...]
    public String getLastName() {            // [...]
    public void setDateOfBirth(Date value) { // [...]
    public Date getDateOfBirth() {           // [...]

    // Navigation methods for foreign keys
    public List&lt;TBookRecord&gt; fetchTBooks() { // [...]
}</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="PROCEDURE">
<fo:marker marker-class-name="section">
<fo:block>2.4. Procedures and packages</fo:block>
</fo:marker>2.4. Procedures and packages</fo:block>
<fo:block font-size="11pt">
							Procedure support is one of the most important reasons why you should consider
							jOOQ. jOOQ heavily facilitates the use of stored procedures and
							functions via its source code generation.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Stored procedures in modern RDBMS</fo:block>
							<fo:block font-size="11pt">This is one of the most important reasons why you should consider
								jOOQ. Read also my
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://java.dzone.com/articles/2011-great-year-stored')">article on dzone</fo:basic-link>
								about why stored procedures become
								more and more important in future versions of RDMBS. In this section
								of the manual, we will learn how jOOQ handles stored procedures in
								code generation. Especially before
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="UDT">UDT and ARRAY support</fo:basic-link> was
								introduced to major RDBMS, these procedures tend to have dozens of
								parameters, with IN, OUT, IN OUT parameters mixed in all variations.
								JDBC only knows very basic, low-level support for those constructs.
								jOOQ heavily facilitates the use of stored procedures and functions
								via its source code generation. Essentially, it comes down to this:
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">"Standalone" stored procedures and functions</fo:block>
							<fo:block font-size="11pt">Let's say you have these stored procedures and functions in your Oracle database </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- Check whether there is an author in T_AUTHOR by that name
CREATE OR REPLACE FUNCTION f_author_exists (author_name VARCHAR2) RETURN NUMBER;

-- Check whether there is an author in T_AUTHOR by that name
CREATE OR REPLACE PROCEDURE p_author_exists (author_name VARCHAR2, result OUT NUMBER);

-- Check whether there is an author in T_AUTHOR by that name and get his ID
CREATE OR REPLACE PROCEDURE p_author_exists_2 (author_name VARCHAR2, result OUT NUMBER, id OUT NUMBER);</fo:block>

							<fo:block font-size="11pt">jOOQ will essentially generate two artefacts for every procedure/function: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">A class holding a formal Java representation of the procedure/function</fo:block>
</fo:list-item-body>
</fo:list-item>
    							<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Some convenience methods to facilitate calling that procedure/function </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">Let's see what these things look like, in Java. The classes (simplified for the example): </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// The function has a generic type parameter &lt;T&gt; bound to its return value
public class FAuthorExists extends org.jooq.impl.AbstractRoutine&lt;BigDecimal&gt; {

    // Much like Tables, functions have static parameter definitions
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]

    // And much like TableRecords, they have setters for their parameters
    public void setAuthorName(String value) { // [...]
    public void setAuthorName(Field&lt;String&gt; value) { // [...]
}

public class PAuthorExists extends org.jooq.impl.AbstractRoutine&lt;java.lang.Void&gt; {

    // In procedures, IN, OUT, IN OUT parameters are all represented
    // as static parameter definitions as well
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]
    public static final Parameter&lt;BigDecimal&gt; RESULT = // [...]

    // IN and IN OUT parameters have generated setters
    public void setAuthorName(String value) { // [...]

    // OUT and IN OUT parameters have generated getters
    public BigDecimal getResult() { // [...]
}

public class PAuthorExists_2 extends org.jooq.impl.AbstractRoutine&lt;java.lang.Void&gt; {
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]
    public static final Parameter&lt;BigDecimal&gt; RESULT = // [...]
    public static final Parameter&lt;BigDecimal&gt; ID = // [...]

    // the setters...
    public void setAuthorName(String value) { // [...]

    // the getters...
    public BigDecimal getResult() { // [...]
    public BigDecimal getId() { // [...]
}</fo:block>

							<fo:block font-size="11pt">An example invocation of such a stored procedure might look like this: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">PAuthorExists p = new PAuthorExists();
p.setAuthorName("Paulo");
p.execute(configuration);
assertEquals(BigDecimal.ONE, p.getResult());</fo:block>

							<fo:block font-size="11pt">
								The above configuration is a
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Factory">Factory</fo:basic-link>,
								holding a reference to a JDBC connection, as discussed in a previous section.

								If you use the generated convenience methods, however, things are much simpler, still:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Every schema has a single Routines class with convenience methods
public final class Routines {

    // Convenience method to directly call the stored function
    public static BigDecimal fAuthorExists(Configuration configuration, String authorName) { // [...]

    // Convenience methods to transform the stored function into a
    // Field&lt;BigDecimal&gt;, such that it can be used in SQL
    public static Field&lt;BigDecimal&gt; fAuthorExists(Field&lt;String&gt; authorName) { // [...]
    public static Field&lt;BigDecimal&gt; fAuthorExists(String authorName) { // [...]

    // Procedures with 0 OUT parameters create void methods
    // Procedures with 1 OUT parameter create methods as such:
    public static BigDecimal pAuthorExists(Configuration configuration, String authorName) { // [...]

    // Procedures with more than 1 OUT parameter return the procedure
    // object (see above example)
    public static PAuthorExists_2 pAuthorExists_2(Configuration configuration, String authorName) { // [...]
}</fo:block>

							<fo:block font-size="11pt">An sample invocation, equivalent to the previous example:</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">assertEquals(BigDecimal.ONE, Procedures.pAuthorExists(configuration, "Paulo"));</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">jOOQ's understanding of procedures vs functions</fo:block>
							<fo:block font-size="11pt">
								jOOQ does not formally distinguish procedures from functions.
								jOOQ only knows about routines, which can have return values
								and/or OUT parameters. This is the best option to handle the
								variety of stored procedure / function support across the
								various supported RDBMS. For more details, read on about this
								topic, here:
							</fo:block>
							<fo:block font-size="11pt">
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://lukaseder.wordpress.com/2011/10/17/what-are-procedures-and-functions-after-all/')">lukaseder.wordpress.com/2011/10/17/what-are-procedures-and-functions-after-all/</fo:basic-link>
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Packages in Oracle</fo:block>
							<fo:block font-size="11pt">
								Oracle uses the concept of a PACKAGE to group several
								procedures/functions into a sort of namespace. The
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt')">SQL standard</fo:basic-link>
								talks about "modules", to represent this concept, even if this is
								rarely implemented. This is reflected in jOOQ by the use of Java
								sub-packages in the source code generation destination package. Every
								Oracle package will be reflected by
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">A Java package holding classes for formal Java representations of
									the procedure/function in that package
								</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">A Java class holding convenience methods to facilitate calling
									those procedures/functions
								</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">
								Apart from this, the generated source code looks exactly like the
								one for
								standalone procedures/functions.
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Member functions and procedures in Oracle</fo:block>
							<fo:block font-size="11pt">
								Oracle UDT's can have object-oriented structures including member functions
								and procedures. With Oracle, you can do things like this:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">CREATE OR REPLACE TYPE u_author_type AS OBJECT (
  id NUMBER(7),
  first_name VARCHAR2(50),
  last_name VARCHAR2(50),

  MEMBER PROCEDURE LOAD,
  MEMBER FUNCTION count_books RETURN NUMBER
)

-- The type body is omitted for the example
</fo:block>

							<fo:block font-size="11pt">
								These member functions and procedures can simply be mapped to Java
								methods:
							</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">
// Create an empty, attached UDT record from the Factory
UAuthorType author = create.newRecord(U_AUTHOR_TYPE);

// Set the author ID and load the record using the LOAD procedure
author.setId(1);
author.load();

// The record is now updated with the LOAD implementation's content
assertNotNull(author.getFirstName());
assertNotNull(author.getLastName());</fo:block>

							<fo:block font-size="11pt">For more details about UDT's see the Manual's section on
							<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="UDT">User Defined Types</fo:basic-link>
</fo:block>

						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="UDT">
<fo:marker marker-class-name="section">
<fo:block>2.5. UDT's including ARRAY and ENUM types</fo:block>
</fo:marker>2.5. UDT's including ARRAY and ENUM types</fo:block>
<fo:block font-size="11pt">
							Databases become more powerful when you can structure your data in user
							defined types. It's time for Java developers to give some credit to
							that.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Increased RDBMS support for UDT's</fo:block>
							<fo:block font-size="11pt">
								In recent years, most RDBMS have started to implement some support for
								advanced data types. This support has not been adopted very well by
								database users in the Java world, for several reasons:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">They are usually orthogonal to relational concepts. It is not easy
									to modify a UDT once it is referenced by a table column.</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">There is little standard support of accessing them from JDBC (and
									probably other database connectivity standards). </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">
								On the other hand, especially with stored procedures, these data types
								are likely to become more and more useful in the future. If you have a
								look at Postgres' capabilities of dealing with advanced data types
								(<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://www.postgresql.org/docs/9.0/interactive/datatype-enum.html')">ENUMs</fo:basic-link>,
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://www.postgresql.org/docs/9.0/interactive/arrays.html')">ARRAYs</fo:basic-link>,
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://www.postgresql.org/docs/9.0/interactive/rowtypes.html')">UDT's</fo:basic-link>),
								 this becomes more and more obvious.
							</fo:block>
							<fo:block font-size="11pt">It is a central strategy for jOOQ, to standardise access to these
								kinds of types (as well as to
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="PROCEDURE">stored procedures</fo:basic-link>, of course) across all
								RDBMS, where these types are supported. </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">UDT types</fo:block>
							<fo:block font-size="11pt">User Defined Types (UDT) are helpful in major RDMBS with lots
							of proprietary functionality. The biggest player is clearly Oracle.
							Currently, jOOQ provides UDT support for only two databases: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Oracle</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Postgres</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">Apart from that, </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
									DB2 UDT's are not supported as they are very tough to
									serialise/deserialise. We don't think that this is a big enough
									requirement to put more effort in those, right now (see also the
									developers' discussion on
									<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://sourceforge.net/apps/trac/jooq/ticket/164')">#164</fo:basic-link>)
								</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-size="11pt">In Oracle, you would define UDTs like this: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">CREATE TYPE u_street_type AS OBJECT (
  street VARCHAR2(100),
  no VARCHAR2(30)
)

CREATE TYPE u_address_type AS OBJECT (
  street u_street_type,
  zip VARCHAR2(50),
  city VARCHAR2(50),
  country VARCHAR2(50),
  since DATE,
  code NUMBER(7)
)</fo:block>

							<fo:block font-size="11pt">These types could then be used in tables and/or stored procedures like such: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  -- [...]
  address u_address_type
)

CREATE OR REPLACE PROCEDURE p_check_address (address IN OUT u_address_type);</fo:block>

							<fo:block font-size="11pt">
								Standard JDBC UDT support encourages JDBC-driver developers to implement
								interfaces such as
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/SQLData.html')">java.sql.SQLData</fo:basic-link>,
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/SQLInput.html')">java.sql.SQLInput</fo:basic-link> and
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/SQLOutput.html')">java.sql.SQLOutput</fo:basic-link>.
								Those interfaces are non-trivial to implement, or
								to hook into. Also access to
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/Struct.html')">java.sql.Struct</fo:basic-link>
								is not really simple. Due
								to the lack of a well-defined JDBC standard, Oracle's JDBC driver
								rolls their own proprietary methods of dealing with these types. jOOQ
								goes a different way, it hides those facts from you entirely. With
								jOOQ, the above UDT's will be generated in simple
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/UDT.java')">UDT meta-model classes</fo:basic-link> and
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/UDTRecord.java')">UDT record classes</fo:basic-link> as such:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// There is an analogy between UDT/Table and UDTRecord/TableRecord...
public class UAddressType extends UDTImpl&lt;UAddressTypeRecord&gt; {

    // The UDT meta-model singleton instance
    public static final UAddressType U_ADDRESS_TYPE = new UAddressType();

    // UDT attributes are modeled as static members. Nested UDT's
    // behave similarly
    public static final UDTField&lt;UAddressTypeRecord, UStreetTypeRecord&gt; STREET = // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; ZIP =               // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; CITY =              // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; COUNTRY =           // [...]
    public static final UDTField&lt;UAddressTypeRecord, Date&gt; SINCE =               // [...]
    public static final UDTField&lt;UAddressTypeRecord, Integer&gt; CODE =             // [...]
}</fo:block>

							<fo:block font-size="11pt">Now, when you interact with entities or procedures that hold UDT's, that's very simple as well. Here is an example: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Fetch any author from the T_AUTHOR table
TAuthorRecord author = create.selectFrom(T_AUTHOR).fetchAny();

// Print out the author's address's house number
System.out.println(author.getAddress().getStreet().getNo());</fo:block>

							<fo:block font-size="11pt">A similar thing can be achieved when interacting with the example stored procedure: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Create a new UDTRecord of type U_ADDRESS_TYPE
UAddressTypeRecord address = new UAddressTypeRecord();
address.setCountry("Switzerland");

// Call the stored procedure with IN OUT parameter of type U_ADDRESS_TYPE
address = Procedures.pCheckAddress(connection, address);</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">ARRAY types</fo:block>
							<fo:block font-size="11pt">
								The notion of ARRAY types in RDBMS is not standardised at all. Very
								modern databases (especially the Java-based ones) have implemented
								ARRAY types exactly as what they are. "ARRAYs of something". In other
								words, an ARRAY OF VARCHAR would be something very similar to Java's
								notion of String[]. An ARRAY OF ARRAY OF VARCHAR would then be a
								String[][] in Java. Some RDMBS, however, enforce stronger typing and
								need the explicit creation of types for every ARRAY as well. These are
								example String[] ARRAY types in various SQL dialects supported by jOOQ
								1.5.4:
							</fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Oracle: VARRAY OF VARCHAR2. A strongly typed object encapsulating an ARRAY of a given type. See the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/docs/cd/B19306_01/appdev.102/b14261/collection_definition.htm')">documentation.</fo:basic-link>
</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Postgres: text[]. Any data type can be turned into an array by suffixing it with []. See the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://www.postgresql.org/docs/9.0/interactive/arrays.html')">documentation</fo:basic-link>
</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">HSQLDB: VARCHAR ARRAY. Any data type can be turned into an array by suffixing it with ARRAY. See the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://hsqldb.org/doc/2.0/guide/sqlgeneral-chapt.html#N1070F')">documentation</fo:basic-link>
</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">H2: ARRAY. H2 does not know of typed arrays. All ARRAYs are mapped to Object[]. See the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://www.h2database.com/html/datatypes.html#array_type')">documentation</fo:basic-link>
</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">Soon to be supported: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">DB2: Knows a similar strongly-typed ARRAY type, like Oracle </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">
								From jOOQ's perspective, the ARRAY types fit in just like any other
								type wherever the
								&lt;T&gt; generic type parameter is existent. It integrates well with tables
									and stored procedures.
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: General ARRAY types</fo:block>
							<fo:block font-size="11pt">An example usage of ARRAYs is given here for the Postgres dialect </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">CREATE TABLE t_arrays (
  id integer not null primary key,
  string_array VARCHAR(20)[],
  number_array INTEGER[]
)

CREATE FUNCTION f_arrays(in_array IN text[]) RETURNS text[]</fo:block>

							<fo:block font-size="11pt">When generating source code from the above entities, these artefacts will be created in Java: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public class TArrays extends UpdatableTableImpl&lt;TArraysRecord&gt; {

    // The generic type parameter &lt;T&gt; is bound to an array of a matching type
    public static final TableField&lt;TArraysRecord, String[]&gt; STRING_ARRAY =  // [...]
    public static final TableField&lt;TArraysRecord, Integer[]&gt; NUMBER_ARRAY = // [...]
}

// The convenience class is enhanced with these methods
public final class Functions {
    public static String[] fArrays(Connection connection, String[] inArray) { // [...]
    public static Field&lt;String[]&gt; fArrays(String[] inArray) {                                     // [...]
    public static Field&lt;String[]&gt; fArrays(Field&lt;String[]&gt; inArray) {                              // [...]
}</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Example: Oracle VARRAY types</fo:block>
							<fo:block font-size="11pt">In Oracle, a VARRAY type is something slightly different than in
								other RDMBS. It is a type that encapsules the actual ARRAY and creates
								a new type from it. While all text[] types are equal and thus
								compatible in Postgres, this does not apply for all VARRAY OF VARCHAR2
								types. Hence, it is important to provide access to VARRAY types and
								generated objects from those types as well. The example above would
								read like this in Oracle: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">CREATE TYPE u_string_array AS VARRAY(4) OF VARCHAR2(20)
CREATE TYPE u_number_array AS VARRAY(4) OF NUMBER(7)

CREATE TABLE t_arrays (
  id NUMBER(7) not null primary key,
  string_array u_string_array,
  number_array u_number_array
)

CREATE OR REPLACE FUNCTION f_arrays (in_array u_string_array)
RETURN u_string_array</fo:block>

							<fo:block font-size="11pt">Note that it becomes clear immediately, that a mapping from
								U_STRING_ARRAY to String[] is obvious. But a mapping from String[] to
								U_STRING_ARRAY is not. These are the generated
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/ArrayRecord.java')">org.jooq.ArrayRecord</fo:basic-link> and other
								artefacts in Oracle: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public class UStringArrayRecord extends ArrayRecordImpl&lt;String&gt; {  // [...]
public class UNumberArrayRecord extends ArrayRecordImpl&lt;Integer&gt; { // [...]

public class TArrays extends UpdatableTableImpl&lt;TArraysRecord&gt; {
    public static final TableField&lt;TArraysRecord, UStringArrayRecord&gt; STRING_ARRAY = // [...]
    public static final TableField&lt;TArraysRecord, UNumberArrayRecord&gt; NUMBER_ARRAY = // [...]
}

public final class Functions {
    public static UStringArrayRecord fArrays3(Connection connection, UStringArrayRecord inArray) { // [...]
    public static Field&lt;UStringArrayRecord&gt; fArrays3(UStringArrayRecord inArray) {                 // [...]
    public static Field&lt;UStringArrayRecord&gt; fArrays3(Field&lt;UStringArrayRecord&gt; inArray) {          // [...]
}</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">ENUM types</fo:block>
							<fo:block font-size="11pt">True ENUM types are a rare species in the RDBMS world. Currently,
								MySQL and Postgres are the only RDMBS supported by jOOQ, that provide
								ENUM types. </fo:block>

							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">In MySQL, an ENUM type is declared directly upon a column. It cannot be reused as a type. See the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://dev.mysql.com/doc/refman/5.5/en/enum.html')">documentation.</fo:basic-link> </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">In Postgres, the ENUM type is declared independently and can be reused among tables, functions, etc. See the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://www.postgresql.org/docs/9.0/interactive/datatype-enum.html')">documentation.</fo:basic-link> </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Other RDMBS know about "ENUM constraints", such as the Oracle CHECK constraint. These are not true ENUMS, however. jOOQ refrains from using their information for source code generation </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-size="11pt">Some examples: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- An example enum type
CREATE TYPE u_book_status AS ENUM ('SOLD OUT', 'ON STOCK', 'ORDERED')

-- An example useage of that enum type
CREATE TABLE t_book (
  id INTEGER NOT NULL PRIMARY KEY,

  -- [...]
  status u_book_status
)</fo:block>

							<fo:block font-size="11pt">The above Postgres ENUM type will be generated as </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public enum UBookStatus implements EnumType {
    ORDERED("ORDERED"),
    ON_STOCK("ON STOCK"),
    SOLD_OUT("SOLD OUT");

    // [...]
}</fo:block>
							<fo:block font-size="11pt">Intuitively, the generated classes for the T_BOOK table in Postgres would look like this: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// The meta-model class
public class TBook extends UpdatableTableImpl&lt;TBookRecord&gt; {

    // The TableField STATUS binds &lt;T&gt; to UBookStatus
    public static final TableField&lt;TBookRecord, UBookStatus&gt; STATUS = // [...]

    // [...]
}

// The record class
public class TBookRecord extends UpdatableRecordImpl&lt;TBookRecord&gt; {

    // Corresponding to the Table meta-model, also setters and getters
    // deal with the generated UBookStatus
    public void setStatus(UBookStatus value) { // [...]
    public UBookStatus getStatus() {           // [...]
}</fo:block>

							<fo:block font-size="11pt">Note that jOOQ allows you to simulate ENUM types where this makes
								sense in your data model. See the section on
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="MasterData">master data</fo:basic-link> for more
								details. </fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="SEQUENCE">
<fo:marker marker-class-name="section">
<fo:block>2.6. Sequences</fo:block>
</fo:marker>2.6. Sequences</fo:block>
<fo:block font-size="11pt">
							jOOQ also generates convenience artefacts for sequences, where this is
							supported: DB2, Derby, H2, HSQLDB, Oracle, Postgres, and more.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Sequences as a source for identity values</fo:block>
							<fo:block font-size="11pt"> Sequences implement the
							<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Sequence.java')">org.jooq.Sequence</fo:basic-link> interface, providing essentially this functionality:</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Get a field for the CURRVAL sequence property
Field&lt;T&gt; currval();

// Get a field for the NEXTVAL sequence property
Field&lt;T&gt; nextval();</fo:block>
							<fo:block font-size="11pt">So if you have a sequence like this in Oracle: </fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">CREATE SEQUENCE s_author_id</fo:block>
							<fo:block font-size="11pt">This is what jOOQ will generate: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public final class Sequences {

    // A static sequence instance
    public static final Sequence&lt;BigInteger&gt; S_AUTHOR_ID = // [...]
}</fo:block>

							<fo:block font-size="11pt">Which you can use in a select statement as such: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Field&lt;BigInteger&gt; s = Sequences.S_AUTHOR_ID.nextval();
BigInteger nextID   = create.select(s).fetchOne(s);</fo:block>

							<fo:block font-size="11pt">Or directly fetch currval() and nextval() from the sequence using the Factory: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">BigInteger currval = create.currval(Sequences.S_AUTHOR_ID);
BigInteger nextval = create.nextval(Sequences.S_AUTHOR_ID);</fo:block>
						<fo:block break-after="page"/>
<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="DSL">
<fo:marker marker-class-name="section">
<fo:block>3. DSL or fluent API. Where SQL meets Java</fo:block>
</fo:marker>3. DSL or fluent API. Where SQL meets Java</fo:block>
<fo:block font-size="11pt">
					In these sections you will learn about how jOOQ makes SQL available to
					Java as if Java natively supported SQL
				</fo:block>
					<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Overview</fo:block>
					<fo:block font-size="11pt">jOOQ ships with its own DSL (or
						<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://en.wikipedia.org/wiki/Domain-specific_language')">Domain Specific Language</fo:basic-link>) that
						simulates SQL as good as possible in Java. This means, that you can
						write SQL statements almost as if Java natively supported that syntax
						just like .NET's C# does with <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://msdn.microsoft.com/en-us/library/bb425822.aspx')">LINQ to SQL.</fo:basic-link>
</fo:block>

					<fo:block font-size="11pt">Here is an example to show you what that means. When you want to write a query like this in SQL: </fo:block>
					<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- Select all books by authors born after 1920,
-- named "Paulo" from a catalogue:
SELECT *
  FROM t_author a
  JOIN t_book b ON a.id = b.author_id
 WHERE a.year_of_birth &gt; 1920
   AND a.first_name = 'Paulo'
 ORDER BY b.title</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Result&lt;Record&gt; result =
create.select()
      .from(T_AUTHOR.as("a"))
      .join(T_BOOK.as("b")).on(a.ID.equal(b.AUTHOR_ID))
      .where(a.YEAR_OF_BIRTH.greaterThan(1920)
      .and(a.FIRST_NAME.equal("Paulo")))
      .orderBy(b.TITLE)
      .fetch();</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

					<fo:block font-size="11pt">
						You couldn't come much closer to SQL itself in Java, without re-writing the compiler.
						We'll see how the aliasing works later in the section about
						<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="ALIAS">aliasing</fo:basic-link>
					</fo:block>
				<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="SELECT">
<fo:marker marker-class-name="section">
<fo:block>3.1. Complete SELECT syntax</fo:block>
</fo:marker>3.1. Complete SELECT syntax</fo:block>
<fo:block font-size="11pt">
							A SELECT statement is more than just the R in CRUD. It allows for
							transforming your relational data into any other form using concepts
							such as equi-join, semi-join, anti-join, outer-join and much more. jOOQ
							helps you think in precisely those relational concepts.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">SELECT from anonymous or ad-hoc types</fo:block>
							<fo:block font-size="11pt">When you don't just perform CRUD (i.e. SELECT * FROM your_table WHERE ID = ?),
							you're usually generating new types using custom projections. With jOOQ, this is
							as intuitive, as if using SQL directly. A more or less complete example of the "standard" SQL syntax, plus
							some extensions, is provided by a query like this:
							</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- get all authors' first and last names, and the number
-- of books they've written in German, if they have written
-- more than five books in German in the last three years
-- (from 2011), and sort those authors by last names
-- limiting results to the second and third row, locking
-- the rows for a subsequent update... whew!

  SELECT T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, COUNT(*)
    FROM T_AUTHOR
    JOIN T_BOOK ON T_AUTHOR.ID = T_BOOK.AUTHOR_ID
   WHERE T_BOOK.LANGUAGE = 'DE'
     AND T_BOOK.PUBLISHED &gt; '2008-01-01'
GROUP BY T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME
  HAVING COUNT(*) &gt; 5
ORDER BY T_AUTHOR.LAST_NAME ASC NULLS FIRST
   LIMIT 2
  OFFSET 1
     FOR UPDATE</fo:block>

     						<fo:block font-size="11pt">So that's daily business. How to do it with jOOQ: When you first create a SELECT statement using the Factory's select() methods </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectFromStep select(Field&lt;?&gt;... fields);

// Example:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count());</fo:block>

							<fo:block font-size="11pt">
								jOOQ will return an "intermediary" type to you, representing the
								SELECT statement about to be created (by the way, check out the
								section on <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="FUNCTIONS">aggregate operators</fo:basic-link>
								 to learn more about the COUNT(*)
								function). This type is the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectFromStep.java')">org.jooq.SelectFromStep</fo:basic-link>.
								When you have a reference
								to this type, you may add a FROM clause, although that clause is
								optional. This is reflected by the fact, that the SelectFromStep type
								extends
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectJoinStep.java')">org.jooq.SelectJoinStep</fo:basic-link>,
								which allows for adding the subsequent
								clauses. Let's say you do decide to add a FROM clause, then you can
								use this method for instance:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectJoinStep from(TableLike&lt;?&gt;... table);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR);</fo:block>

							<fo:block font-size="11pt">After adding the table-like structures (mostly just Tables) to
								select from, you may optionally choose to add a JOIN clause, as the
								type returned by jOOQ is the step where you can add JOINs. Again,
								adding these clauses is optional, as the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectJoinStep.java')">org.jooq.SelectJoinStep</fo:basic-link> extends
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectWhereStep.java')">org.jooq.SelectWhereStep</fo:basic-link>.
								But let's say we add a JOIN: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// These join types are supported
SelectOnStep                    join(Table&lt;?&gt; table);
SelectOnStep           leftOuterJoin(Table&lt;?&gt; table);
SelectOnStep          rightOuterJoin(Table&lt;?&gt; table);
SelectOnStep           fullOuterJoin(Table&lt;?&gt; table);
SelectJoinStep             crossJoin(Table&lt;?&gt; table);
SelectJoinStep           naturalJoin(Table&lt;?&gt; table);
SelectJoinStep  naturalLeftOuterJoin(Table&lt;?&gt; table);
SelectJoinStep naturalRightOuterJoin(Table&lt;?&gt; table);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK);</fo:block>

							<fo:block font-size="11pt">Now, if you do add a JOIN clause, you have to specify the JOIN .. ON
								condition before you can add more clauses. That's not an optional step
								for some JOIN types. This is reflected by the fact that
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectOnStep.java')">org.jooq.SelectOnStep</fo:basic-link>
								is a top-level interface. </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// These join conditions are supported
SelectJoinStep    on(Condition... conditions);
SelectJoinStep using(Field&lt;?&gt;... fields);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID));</fo:block>

							<fo:block font-size="11pt">See the section about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="CONDITION">Conditions</fo:basic-link>
								to learn more about the many ways
								to create Conditions in jOOQ. Now we're half way through. As you can
								see above, we're back to the SelectJoinStep. This means, we can
								re-iterate and add another JOIN clause, just like in SQL. Or we go on
								to the next step, adding conditions in the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectWhereStep.java')">org.jooq.SelectWhereStep</fo:basic-link>: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectConditionStep where(Condition... conditions);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"));</fo:block>

							<fo:block font-size="11pt">Now the returned type
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectConditionStep.java')">org.jooq.SelectConditionStep</fo:basic-link> is a special one, where
								you can add more conditions to the already existing WHERE clause.
								Every time you add a condition, you will return to that
								SelectConditionStep, as the number of additional conditions is
								unlimited. Note that of course you can also just add a single combined
								condition, if that is more readable or suitable for your use-case.
								Here's how we add another condition: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectConditionStep and(Condition condition);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')));</fo:block>

							<fo:block font-size="11pt">Let's assume we have that method parseDate() creating a
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://download.oracle.com/javase/6/docs/api/java/sql/Date.html')">java.sql.Date</fo:basic-link> for us.
								Then we'll continue adding the GROUP BY clause
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectHavingStep groupBy(Field&lt;?&gt;... fields);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME);</fo:block>

      						<fo:block font-size="11pt">and the HAVING clause: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectOrderByStep having(Condition... conditions);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5));</fo:block>

							<fo:block font-size="11pt">and the ORDER BY clause. Some RDBMS support NULLS FIRST and NULLS
								LAST extensions to the ORDER BY clause. If this is not supported by
								the RDBMS, then the behaviour is simulated with an additional CASE
								WHEN ... IS NULL THEN 1 ELSE 0 END clause. </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectLimitStep orderBy(Field&lt;?&gt;... fields);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(T_AUTHOR.LAST_NAME.asc().nullsFirst());</fo:block>

							<fo:block font-size="11pt">and finally the LIMIT clause. Most dialects have a means of limiting
								the number of result records (except Oracle). Some even support having
								an OFFSET to the LIMIT clause. Even if your RDBMS does not support the
								full LIMIT ... OFFSET ... (or TOP ... START AT ..., or FETCH FIRST ... ROWS ONLY, etc)
								clause, jOOQ will simulate the LIMIT clause using nested selects and filtering on
								ROWNUM (for Oracle), or on ROW_NUMBER() (for DB2 and SQL
								Server): </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectFinalStep limit(int offset, int numberOfRows);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(T_AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(1, 2);</fo:block>

							<fo:block font-size="11pt">In the final step, there are some proprietary extensions available
								only in some RDBMS. One of those extensions are the FOR UPDATE
								(supported in most RDBMS) and FOR SHARE clauses (supported only in
								MySQL and Postgres): </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectFinalStep forUpdate();

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(T_AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(1, 2)
      .forUpdate();</fo:block>

							<fo:block font-size="11pt">
								Now the most relevant super-type of the object we have just created is
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java')">org.jooq.Select</fo:basic-link>.
								This type can be reused in various expressions such as in the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="UNION">UNION and other set operations</fo:basic-link>,
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="EXISTS">Nested select statements using the EXISTS operator</fo:basic-link>,
								etc. If you just want to execute this select
								statement, you can choose any of these methods as discussed in the
								section about the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="ResultQuery">ResultQuery</fo:basic-link>:
							</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Just execute the query.
int execute();

// Execute the query and retrieve the results
Result&lt;Record&gt; fetch();

// Execute the query and retrieve the first Record
Record fetchAny();

// Execute the query and retrieve the single Record
// An Exception is thrown if more records were available
Record fetchOne();

// [...]</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">SELECT from single physical tables</fo:block>
							<fo:block font-size="11pt">A very similar, but limited API is available, if you want to select from single
								physical tables in order to retrieve TableRecords or even
								UpdatableRecords (see also the manual's section on
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Query">SelectQuery vs SimpleSelectQuery</fo:basic-link>).
								The decision, which type of select to create is
								already made at the very first step, when you create the SELECT
								statement with the Factory: </fo:block>

							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public &lt;R extends Record&gt; SimpleSelectWhereStep&lt;R&gt; selectFrom(Table&lt;R&gt; table);</fo:block>
							<fo:block font-size="11pt">As you can see, there is no way to further restrict/project the selected
								fields. This just selects all known TableFields in the supplied Table,
								and it also binds &lt;R extends Record&gt; to your Table's associated
								Record. An example of such a Query would then be: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">TBook book = create.selectFrom(T_BOOK)
                   .where(TBook.LANGUAGE.equal("DE"))
                   .orderBy(TBook.TITLE)
                   .fetchAny();</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="CONDITION">
<fo:marker marker-class-name="section">
<fo:block>3.2. Conditions</fo:block>
</fo:marker>3.2. Conditions</fo:block>
<fo:block font-size="11pt">
							The creation of conditions is the part of any database abstraction that
							attracts the most attention.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Conditions are the SELECT's core business</fo:block>
							<fo:block font-size="11pt">In your average application, you will typically have 3-4 SQL queries
								that have quite a long list of predicates (and possibly JOINs), such
								that you start to lose track over the overall boolean expression that
								you're trying to apply.</fo:block>
							<fo:block font-size="11pt">In jOOQ, most Conditions can be created and combined almost as
								easily as in SQL itself. The two main participants for creating
								Conditions are the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Field.java')">Field</fo:basic-link>,
								which is typically a participant of a
								condition, and the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Condition.java')">Condition</fo:basic-link>
								itself: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public interface Condition {
    Condition and(Condition other);
    Condition and(String sql);
    Condition and(String sql, Object... bindings);
    Condition andNot(Condition other);
    Condition andExists(Select&lt;?&gt; select);
    Condition andNotExists(Select&lt;?&gt; select);
    Condition or(Condition other);
    Condition or(String sql);
    Condition or(String sql, Object... bindings);
    Condition orNot(Condition other);
    Condition orExists(Select&lt;?&gt; select);
    Condition orNotExists(Select&lt;?&gt; select);
    Condition not();
}</fo:block>

							<fo:block font-size="11pt">The above example describes the essence of boolean logic in jOOQ. As
								soon as you have a Condition object, you can connect that to other
								Conditions, which will then give you a combined condition with exactly
								the same properties. There are also convenience methods to create an
								EXISTS clause and connect it to an existing condition. In order to
								create a new Condition you are going to depart from a Field in most
								cases. Here are some important API elements in the Field interface:
							</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[public interface Field<T> {
    Condition isNull();
    Condition isNotNull();
    Condition like(T value);
    Condition notLike(T value);
    Condition in(T... values);
    Condition in(Select<?> query);
    Condition notIn(Collection<T> values);
    Condition notIn(T... values);
    Condition notIn(Select<?> query);
    Condition in(Collection<T> values);
    Condition between(T minValue, T maxValue);
    Condition equal(T value);
    Condition equal(Field<T> field);
    Condition equal(Select<?> query);
    Condition equalAny(Select<?> query);
    Condition equalAny(T... array);
    Condition equalAny(Field<T[]> array);
    Condition equalAll(Select<?> query);
    Condition equalAll(T... array);
    Condition equalAll(Field<T[]> array);
    Condition notEqual(T value);
    Condition notEqual(Field<T> field);
    Condition notEqual(Select<?> query);
    Condition notEqualAny(Select<?> query);
    Condition notEqualAny(T... array);
    Condition notEqualAny(Field<T[]> array);
    Condition notEqualAll(Select<?> query);
    Condition notEqualAll(T... array);
    Condition notEqualAll(Field<T[]> array);

    // Subselects, ANY and ALL quantifiers are also supported for these:
    Condition lessThan(T value);
    Condition lessOrEqual(T value);
    Condition greaterThan(T value);
    Condition greaterOrEqual(T value);
}]]></fo:block>

							<fo:block font-size="11pt">As you see in the partially displayed API above, you can compare a
								Field either with other Fields, with constant values (which is a
								shortcut for calling Factory.val(T value)), or with a nested SELECT
								statement. See some more
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="NESTED">Examples of nested SELECTs</fo:basic-link>. </fo:block>
							<fo:block font-size="11pt">Combining the API of Field and Condition you can express complex predicates like this: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">(T_BOOK.TYPE_CODE IN (1, 2, 5, 8, 13, 21)       AND T_BOOK.LANGUAGE = 'DE') OR
(T_BOOK.TYPE_CODE IN (2, 3, 5, 7, 11, 13)       AND T_BOOK.LANGUAGE = 'FR') OR
(T_BOOK.TYPE_CODE IN (SELECT CODE FROM T_TYPES) AND T_BOOK.LANGUAGE = 'EN')</fo:block>

							<fo:block font-size="11pt">Just write: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">T_BOOK.TYPE_CODE.in(1, 2, 5, 8, 13, 21)                       .and(T_BOOK.LANGUAGE.equal("DE")).or(
T_BOOK.TYPE_CODE.in(2, 3, 5, 7, 11, 13)                       .and(T_BOOK.LANGUAGE.equal("FR")).or(
T_BOOK.TYPE_CODE.in(create.select(T_TYPES.CODE).from(T_TYPES)).and(T_BOOK.LANGUAGE.equal("EN"))));</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="ALIAS">
<fo:marker marker-class-name="section">
<fo:block>3.3. Aliased tables and fields</fo:block>
</fo:marker>3.3. Aliased tables and fields</fo:block>
<fo:block font-size="11pt">
							Aliasing is at the core of SQL and relational algebra. When you join
							the same entity multiple times, you can rename it to distinguish the
							various meanings of the same entity
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Aliasing Tables</fo:block>
							<fo:block font-size="11pt">A typical example of what you might want to do in SQL is this: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT a.ID, b.ID
  FROM T_AUTHOR a
  JOIN T_BOOK b on a.ID = b.AUTHOR_ID</fo:block>

  							<fo:block font-size="11pt">
  								In this example, we are aliasing Tables, calling them a and b.
  								The way aliasing works depends on how you generate your meta model
  								using jooq-codegen (see the manual's section about
  								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="TABLE">generating tables</fo:basic-link>). Things become
  								simpler when you choose the instance/dynamic model, instead of the
  								static one.
  								Here is how you can create Table aliases in jOOQ:
  							</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Table&lt;TBookRecord&gt; book = T_BOOK.as("b");
Table&lt;TAuthorRecord&gt; author = T_AUTHOR.as("a");

// If you choose not to generate a static meta model, this becomes even better
TBook book = T_BOOK.as("b");
TAuthor author = T_AUTHOR.as("a");</fo:block>

							<fo:block font-size="11pt">Now, if you want to reference any fields from those Tables, you may
								not use the original T_BOOK or T_AUTHOR meta-model objects anymore.
								Instead, you have to get the fields from the new book and author Table
								aliases: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[Field<Integer> bookID = book.getField(TBook.ID);
Field<Integer> authorID = author.getField(TAuthor.ID);

// Or with the instance field model:
Field<Integer> bookID = book.ID;
Field<Integer> authorID = author.ID;]]></fo:block>

							<fo:block font-size="11pt">
								So this is how the above SQL statement would read in jOOQ:
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(authorID, bookID)
      .from(author)
      .join(book).on(authorID.equal(book.getField(T_BOOK.AUTHOR_ID)));

// Or with the instance field model:
create.select(author.ID, book.ID)
      .from(author)
      .join(book).on(author.ID.equal(book.AUTHOR_ID))</fo:block>


      						<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Aliasing nested selects as tables</fo:block>
							<fo:block font-size="11pt">There is an interesting, more advanced example of how you can select
								from an aliased nested select in the manual's section about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="NESTED">nested selects</fo:basic-link>
</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Aliasing fields</fo:block>
							<fo:block font-size="11pt">Fields can also be aliased independently from Tables. Most often,
								this is done when using functions or aggregate operators. Here is an
								example: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">  SELECT FIRST_NAME || ' ' || LAST_NAME author, COUNT(*) books
    FROM T_AUTHOR
    JOIN T_BOOK ON T_AUTHOR.ID = AUTHOR_ID
GROUP BY FIRST_NAME, LAST_NAME;</fo:block>
							<fo:block font-size="11pt">Here is how it's done with jOOQ: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Record record = create.select(
         concat(T_AUTHOR.FIRST_NAME, " ", T_AUTHOR.LAST_NAME).as("author"),
         count().as("books"))
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_AUTHOR.ID.equal(T_BOOK.AUTHOR_ID))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME).fetchAny();</fo:block>
      						<fo:block font-size="11pt">When you alias Fields like above, you can access those Fields' values using the alias name: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">System.out.println("Author : " + record.getValue("author"));
System.out.println("Books  : " + record.getValue("books"));</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="IN">
<fo:marker marker-class-name="section">
<fo:block>3.4. Nested SELECT using the IN operator</fo:block>
</fo:marker>3.4. Nested SELECT using the IN operator</fo:block>
<fo:block font-size="11pt">
							Set equal operations are very common when you want to select multiple
							records. The IN operator can also be used for semi-joins, though
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The IN operator for use in semi-joins or anti-joins</fo:block>
							<fo:block font-size="11pt">
								In addition to a list of constant values, the IN operator in
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Field.java')">org.jooq.Field</fo:basic-link>
								also supports a
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java')">org.jooq.Select</fo:basic-link> as an argument.
								This can be any type of select as
								discussed in the manual's section about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Query">Query types</fo:basic-link>.
								However, you must
								ensure yourself, that the provided Select will only select a single
								Field.
							</fo:block>
							<fo:block font-size="11pt">Let's say you want to select books by authors born in 1920. Of
								course, this is possible with a plain JOIN as well, but let's say we
								want to use the IN operator. Then you have two possibilities: </fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT *
  FROM T_BOOK
 WHERE T_BOOK.AUTHOR_ID IN (
           SELECT ID FROM T_AUTHOR
            WHERE T_AUTHOR.BORN = 1920)

-- OR:

SELECT T_BOOK.*
  FROM T_BOOK
  JOIN T_AUTHOR ON (T_BOOK.AUTHOR_ID = T_AUTHOR.ID
                AND T_AUTHOR.BORN    = 1920)</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select()
      .from(T_BOOK)
      .where(T_BOOK.AUTHOR_ID.in(
          create.select(T_AUTHOR.ID).from(T_AUTHOR)
                .where(T_AUTHOR.BORN.equal(1920))));

// OR:

create.select(T_BOOK.getFields())
      .from(T_BOOK)
      .join(T_AUTHOR).on(T_BOOK.AUTHOR_ID.equal(TAuthor.ID)
                     .and(T_AUTHOR.BORN.equal(1920)));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="EXISTS">
<fo:marker marker-class-name="section">
<fo:block>3.5. Nested SELECT using the EXISTS operator</fo:block>
</fo:marker>3.5. Nested SELECT using the EXISTS operator</fo:block>
<fo:block font-size="11pt">The EXISTS operator is a bit different from all other SQL
							elements, as it cannot really be applied to any object in a DSL.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The EXISTS operator for use in semi-joins or anti-joins</fo:block>
							<fo:block font-size="11pt">The EXISTS operator is rather independent and can stand any place
								where there may be a new condition: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">It may be placed right after a WHERE keyword </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">It may be the right-hand-side of a boolean operator</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">It may be placed right after a ON or HAVING keyword (although, this is less likely to be done...) </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-size="11pt">This is reflected by the fact that an EXISTS clause is usually
								created directly from the Factory: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Condition exists(Select&lt;?&gt; query);
Condition notExists(Select&lt;?&gt; query);</fo:block>

							<fo:block font-size="11pt">When you create such a Condition, it can then be connected to any
								other condition using AND, OR operators (see also the manual's section
								on
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="CONDITION">Conditions</fo:basic-link>). There are also quite a few
								convenience methods, where they might be useful. For instance in the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Condition.java')">org.jooq.Condition</fo:basic-link> itself: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Condition andExists(Select&lt;?&gt; select);
Condition andNotExists(Select&lt;?&gt; select);
Condition orExists(Select&lt;?&gt; select);
Condition orNotExists(Select&lt;?&gt; select);</fo:block>

							<fo:block font-size="11pt">Or in the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectWhereStep.java')">org.jooq.SelectWhereStep</fo:basic-link>:</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectConditionStep whereExists(Select&lt;?&gt; select);
SelectConditionStep whereNotExists(Select&lt;?&gt; select);</fo:block>

							<fo:block font-size="11pt">Or in the <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectConditionStep.java')">org.jooq.SelectConditionStep</fo:basic-link>: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SelectConditionStep andExists(Select&lt;?&gt; select);
SelectConditionStep andNotExists(Select&lt;?&gt; select);
SelectConditionStep orExists(Select&lt;?&gt; select);
SelectConditionStep orNotExists(Select&lt;?&gt; select);</fo:block>

							<fo:block font-size="11pt">An example of how to use it is quickly given. Get all authors that haven't written any books: </fo:block>
							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT *
  FROM T_AUTHOR
 WHERE NOT EXISTS (SELECT 1
                     FROM T_BOOK
                    WHERE T_BOOK.AUTHOR_ID = T_AUTHOR.ID)</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select()
      .from(T_AUTHOR)
      .whereNotExists(create.selectOne()
            .from(T_BOOK)
            .where(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID)));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="NESTED">
<fo:marker marker-class-name="section">
<fo:block>3.6. Other types of nested SELECT</fo:block>
</fo:marker>3.6. Other types of nested SELECT</fo:block>
<fo:block font-size="11pt">Apart from the most common IN and EXISTS clauses that encourage
							the use of nested selects, SQL knows a few more syntaxes to make use
							of such constructs. </fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Comparison with single-field SELECT clause</fo:block>
							<fo:block font-size="11pt">If you can ensure that a nested SELECT will only return one Record
								with one Field, then you can test for equality. This is how it is done
								in SQL: </fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT *
  FROM T_BOOK
 WHERE T_BOOK.AUTHOR_ID = (
 		SELECT ID
          FROM T_AUTHOR
         WHERE LAST_NAME = 'Orwell')</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select()
      .from(T_BOOK)
      .where(T_BOOK.AUTHOR_ID.equal(create
             .select(T_AUTHOR.ID)
             .from(T_AUTHOR)
             .where(T_AUTHOR.LAST_NAME.equal("Orwell"))));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

                            <fo:block font-size="11pt">More examples like the above can be guessed from the
                            <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Field.java')">org.jooq.Field</fo:basic-link> API, as documented in the manual's section about
                            <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="CONDITION">Conditions</fo:basic-link>. For the = operator, the available comparisons are these:</fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Condition equal(Select&lt;?&gt; query);
Condition equalAny(Select&lt;?&gt; query);
Condition equalAll(Select&lt;?&gt; query);</fo:block>


                            <fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Selecting from a SELECT - SELECT acts as a Table</fo:block>
							<fo:block font-size="11pt">Often, you need to nest a SELECT statement simply because SQL is
								limited in power. For instance, if you want to find out which author
								has written the most books, then you cannot do this: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">  SELECT AUTHOR_ID, count(*) books
    FROM T_BOOK
GROUP BY AUTHOR_ID
ORDER BY books DESC</fo:block>

							<fo:block font-size="11pt">Instead, you have to do this (or something similar). For jOOQ, this
								is an excellent example, combining various SQL features into a single
								statement. Here's how to do it: </fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT nested.* FROM (
      SELECT AUTHOR_ID, count(*) books
        FROM T_BOOK
    GROUP BY AUTHOR_ID
) nested
ORDER BY nested.books DESC


</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Table&lt;Record&gt; nested =
    create.select(T_BOOK.AUTHOR_ID, count().as("books"))
          .from(T_BOOK)
          .groupBy(T_BOOK.AUTHOR_ID).asTable("nested");

create.select(nested.getFields())
      .from(nested)
      .orderBy(nested.getField("books"));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-size="11pt">You'll notice how some verbosity seems inevitable when you combine nested SELECT statements with aliasing. </fo:block>

	                    	<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Selecting a SELECT - SELECT acts as a Field</fo:block>
							<fo:block font-size="11pt">Now SQL is even more powerful than that. You can also have SELECT
								statements, wherever you can have Fields. It get's harder and harder
								to find good examples, because there is always an easier way to
								express the same thing. But why not just count the number of books the
								really hard way? :-) But then again, maybe you want to take advantage
								of <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://lukaseder.wordpress.com/2011/09/02/oracle-scalar-subquery-caching/')">Oracle Scalar Subquery Caching</fo:basic-link>
</fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">  SELECT LAST_NAME, (
      SELECT COUNT(*)
       FROM T_BOOK
      WHERE T_BOOK.AUTHOR_ID = T_AUTHOR.ID) books
    FROM T_AUTHOR
ORDER BY books DESC



</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// The type of books cannot be inferred from the Select&lt;?&gt;
Field&lt;Object&gt; books =
    create.selectCount()
          .from(T_BOOK)
          .where(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
          .asField("books");
create.select(T_AUTHOR.ID, books)
      .from(T_AUTHOR)
      .orderBy(books, T_AUTHOR.ID));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>
                    	<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="UNION">
<fo:marker marker-class-name="section">
<fo:block>3.7. UNION and other set operations</fo:block>
</fo:marker>3.7. UNION and other set operations</fo:block>
<fo:block font-size="11pt">Unions, differences and intersections are vital set operations taken from set theory.</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">jOOQ's set operation API</fo:block>
							<fo:block font-size="11pt">The
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java')">org.jooq.Select</fo:basic-link> API directly supports the UNION
								syntax for all types of Select as discussed in the manual's section about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Query">Queries and Query subtypes</fo:basic-link>.
								It consists of these methods: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public interface Select&lt;R extends Record&gt; {
    Select&lt;R&gt; union(Select&lt;R&gt; select);
    Select&lt;R&gt; unionAll(Select&lt;R&gt; select);
    Select&lt;R&gt; except(Select&lt;R&gt; select);
    Select&lt;R&gt; intersect(Select&lt;R&gt; select);
}</fo:block>

							<fo:block font-size="11pt">Hence, this is how you can write a simple UNION with jOOQ:</fo:block>
							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT TITLE
  FROM T_BOOK
 WHERE PUBLISHED_IN &gt; 1945
UNION
SELECT TITLE
  FROM T_BOOK
 WHERE AUTHOR_ID = 1</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(TBook.TITLE)
      .from(T_BOOK)
      .where(T_BOOK.PUBLISHED_IN.greaterThan(1945))
      .union(
create.select(T_BOOK.TITLE)
      .from(T_BOOK)
      .where(T_BOOK.AUTHOR_ID.equal(1)));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Nested UNIONs</fo:block>
							<fo:block font-size="11pt">In some SQL dialects, you can arbitrarily nest UNIONs to several
								levels. Be aware, though, that SQLite, Derby and MySQL have serious
								syntax limitations. jOOQ tries to render correct UNION SQL statements,
								but unfortunately, you can create situations that will cause syntax
								errors in the aforementioned dialects. </fo:block>

							<fo:block font-size="11pt">An example of advanced UNION usage is the following statement in jOOQ: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Create a UNION of several types of books
Select&lt;?&gt; union =
    create.select(T_BOOK.TITLE, T_BOOK.AUTHOR_ID).from(T_BOOK).where(T_BOOK.PUBLISHED_IN.greaterThan(1945)).union(
    create.select(T_BOOK.TITLE, T_BOOK.AUTHOR_ID).from(T_BOOK).where(T_BOOK.AUTHOR_ID.equal(1)));

// Now, re-use the above UNION and order it by author
create.select(union.getField(T_BOOK.TITLE))
      .from(union)
      .orderBy(union.getField(T_BOOK.AUTHOR_ID).descending());</fo:block>

							<fo:block font-size="11pt">This example does not seem surprising, when you have read the
								previous chapters about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="NESTED">nested SELECT statements</fo:basic-link>.
								But when you check
								out the rendered SQL: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- alias_38173 is an example of a generated alias,
-- generated by jOOQ for union queries
SELECT alias_38173.TITLE FROM (
  SELECT T_BOOK.TITLE, T_BOOK.AUTHOR_ID FROM T_BOOK WHERE T_BOOK.PUBLISHED_IN &gt; 1945
  UNION
  SELECT T_BOOK.TITLE, T_BOOK.AUTHOR_ID FROM T_BOOK WHERE T_BOOK.AUTHOR_ID = 1
) alias_38173
ORDER BY alias_38173.AUTHOR_ID DESC</fo:block>

							<fo:block font-size="11pt">You can see that jOOQ takes care of many syntax pitfalls, when
								you're not used to the various dialects' unique requirements. The
								above automatic aliasing was added in order to be compliant with
								MySQL's requirements about aliasing nested selects. </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Several UNIONs</fo:block>
							<fo:block font-size="11pt">It is no problem either for you to create SQL statements with several unions. Just write: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Select&lt;?&gt; part1;
Select&lt;?&gt; part2;
Select&lt;?&gt; part3;
Select&lt;?&gt; part4;

// [...]

part1.union(part2).union(part3).union(part4);</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">UNION and the ORDER BY clause</fo:block>
							<fo:block font-size="11pt">
								Strictly speaking, in SQL, you cannot order a subselect that is part
								of a UNION operation. You can only order the whole set. In set theory,
								or relational algebra, it wouldn't make sense to order subselects
								anyway, as a set operation cannot guarantee order correctness. Often,
								you still want to do it, because you apply a LIMIT to every subselect.
								Let's say, you want to find the employees with the highest salary in
								every department in Postgres syntax:
							</fo:block>
							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT * FROM (
  SELECT * FROM emp WHERE dept = 'IT'
  ORDER BY salary LIMIT 1
) UNION (
  SELECT * FROM emp WHERE dept = 'Marketing'
  ORDER BY salary LIMIT 1
) UNION (
  SELECT * FROM emp WHERE dept = 'R&amp;D'
  ORDER BY salary LIMIT 1
)</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.selectFrom(EMP).where(DEPT.equal("IT"))
      .orderBy(SALARY).limit(1)
      .union(
create.selectFrom(EMP).where(DEPT.equal("Marketing"))
      .orderBy(SALARY).limit(1))
      .union(
create.selectFrom(EMP).where(DEPT.equal("R&amp;D")
      .orderBy(SALARY).limit(1)))


</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-size="11pt">There is a subtle difference between the above two queries.
								In SQL, every UNION subselect is in fact a
							<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="NESTED">nested SELECT</fo:basic-link>, wrapped in parentheses.
							In this example, the notion of "nested SELECT" and "subselect" are slightly
							different.</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="FUNCTIONS">
<fo:marker marker-class-name="section">
<fo:block>3.8. Functions and aggregate operators</fo:block>
</fo:marker>3.8. Functions and aggregate operators</fo:block>
<fo:block font-size="11pt">
							Highly effective SQL cannot do without functions. Operations on
							VARCHAR, DATE, and NUMERIC types in GROUP BY or ORDER BY clauses allow
							for very elegant queries.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">jOOQ's strategy for supporting vendor-specific functions</fo:block>
							<fo:block font-size="11pt">jOOQ allows you to access native functions from your RDBMS. jOOQ
								follows two strategies: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Implement all SQL-92, SQL:1999, SQL:2003, and SQL:2008 standard
									functions, aggregate operators, and window functions. Standard
									functions could be
									<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://oreilly.com/catalog/sqlnut/chapter/ch04.html')">these functions as listed by O'Reilly</fo:basic-link>. </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Take the most useful of vendor-specific functions and simulate
									them for other RDBMS, where they may not be supported. An example for
									this are
									<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('http://psoug.org/reference/analytic_functions.html')">Oracle Analytic Functions</fo:basic-link>
</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Functions </fo:block>
							<fo:block font-size="11pt">These are just a few functions in the Factory, so you get the idea: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[Field<String> rpad(Field<String> field, Field<? extends Number> length);
Field<String> rpad(Field<String> field, int length);
Field<String> rpad(Field<String> field, Field<? extends Number> length, Field<String> c);
Field<String> rpad(Field<String> field, int length, char c);
Field<String> lpad(Field<String> field, Field<? extends Number> length);
Field<String> lpad(Field<String> field, int length);
Field<String> lpad(Field<String> field, Field<? extends Number> length, Field<String> c);
Field<String> lpad(Field<String> field, int length, char c);
Field<String> replace(Field<String> field, Field<String> search);
Field<String> replace(Field<String> field, String search);
Field<String> replace(Field<String> field, Field<String> search, Field<String> replace);
Field<String> replace(Field<String> field, String search, String replace);
Field<Integer> position(Field<String> field, String search);
Field<Integer> position(Field<String> field, Field<String> search);]]></fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Aggregate operators</fo:block>
							<fo:block font-size="11pt">Aggregate operators work just like functions, even if they have a
								slightly different semantics. Here are some examples from
								Factory: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// Every-day functions
AggregateFunction<Integer> count(Field<?> field);
AggregateFunction<T> max(Field<T> field);
AggregateFunction<T> min(Field<T> field);
AggregateFunction<BigDecimal> sum(Field<? extends Number> field);
AggregateFunction<BigDecimal> avg(Field<? extends Number> field);

// DISTINCT keyword in aggregate functions
AggregateFunction<Integer> countDistinct(Field<?> field);
AggregateFunction<T> maxDistinct(Field<T> field);
AggregateFunction<T> minDistinct(Field<T> field);
AggregateFunction<BigDecimal> sumDistinct(Field<? extends Number> field);
AggregateFunction<BigDecimal> avgDistinct(Field<? extends Number> field);

// Statistical functions
AggregateFunction<BigDecimal> median(Field<? extends Number> field);
AggregateFunction<BigDecimal> stddevPop(Field<? extends Number> field);
AggregateFunction<BigDecimal> stddevSamp(Field<? extends Number> field);
AggregateFunction<BigDecimal> varPop(Field<? extends Number> field);
AggregateFunction<BigDecimal> varSamp(Field<? extends Number> field);
]]></fo:block>

							<fo:block font-size="11pt">A typical example of how to use an aggregate operator is when
								generating the next key on insertion of an ID. When you want to
								achieve something like this </fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT MAX(ID) + 1 AS next_id
  FROM T_AUTHOR</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(max(ID).add(1).as("next_id"))
      .from(T_AUTHOR);</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-size="11pt">See also the section about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="ARITHMETIC">Arithmetic operations</fo:basic-link>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Window functions</fo:block>
							<fo:block font-size="11pt">Most major RDBMS support the concept of window functions. jOOQ knows
								of implementations in DB2, Oracle, Postgres, SQL Server, and Sybase
								SQL Anywhere,
								and supports most of their specific syntaxes. Window functions can be
								used for things like calculating a "running total". The following example
								fetches transactions and the running total for every transaction going
								back to the beginning of the transaction table (ordered by booked_at).

								They are accessible from the previously seen AggregateFunction type using
								the over() method:
							</fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT booked_at, amount,
   SUM(amount) OVER (PARTITION BY 1
                     ORDER BY booked_at
                     ROWS BETWEEN UNBOUNDED PRECEDING
                     AND CURRENT ROW) AS total
  FROM transactions</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(t.BOOKED_AT, t.AMOUNT,
         sum(t.AMOUNT).over().partitionByOne()
                      .orderBy(t.BOOKED_AT)
                      .rowsBetweenUnboundedPreceding()
                      .andCurrentRow().as("total")
      .from(TRANSACTIONS.as("t"));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="PROCEDURES">
<fo:marker marker-class-name="section">
<fo:block>3.9. Stored procedures and functions</fo:block>
</fo:marker>3.9. Stored procedures and functions</fo:block>
<fo:block font-size="11pt">
							The full power of your database's vendor-specific extensions can hardly
							be obtained outside of the
							database itself. Most modern RDBMS support
							their own procedural language. With jOOQ, stored procedures are
							integrated easily
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Interaction with stored procedures</fo:block>
							<fo:block font-size="11pt">The main way to interact with your RDBMS's stored procedures and
								functions is by using the generated artefacts. See the manual's
								section about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="PROCEDURE">generating procedures and packages</fo:basic-link>
							    for more details
								about the source code generation for stored procedures and functions.
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Stored functions</fo:block>
							<fo:block font-size="11pt">When it comes to DSL, stored functions can be very handy in SQL
								statements as well. Every stored function (this also applies to
								FUNCTIONS in Oracle PACKAGES) can generate a Field representing a call
								to that function. Typically, if you have this type of function in your
								database: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">CREATE OR REPLACE FUNCTION f_author_exists (author_name VARCHAR2)
RETURN NUMBER;</fo:block>

							<fo:block font-size="11pt">Then convenience methods like these are generated: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Create a field representing a function with another field as parameter
public static Field&lt;BigDecimal&gt; fAuthorExists(Field&lt;String&gt; authorName) { // [...]

// Create a field representing a function with a constant parameter
public static Field&lt;BigDecimal&gt; fAuthorExists(String authorName) { // [...]</fo:block>

							<fo:block font-size="11pt">Let's say, you have a T_PERSON table with persons' names in it, and
								you want to know whether there exists an author with precisely that
								name, you can reuse the above stored function in a SQL query: </fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT T_PERSON.NAME, F_AUTHOR_EXISTS(T_PERSON.NAME)
  FROM T_PERSON

-- OR:

SELECT T_PERSON.NAME
  FROM T_PERSON
 WHERE F_AUTHOR_EXISTS(T_PERSON.NAME) = 1</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(T_PERSON.NAME, Functions.fAuthorExists(T_PERSON.NAME))
      .from(T_PERSON);

// OR: Note, the static import of Functions.*
create.select(T_PERSON.NAME)
      .from(T_PERSON)
      .where(fAuthorExists(T_PERSON.NAME));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Stored procedures</fo:block>
							<fo:block font-size="11pt">The notion of a stored procedure is implemented in most RDBMS by the
								fact, that the procedure has no RETURN VALUE (like void in Java), but
								it may well have OUT parameters. Since there is not a standard way how
								to embed stored procedures in SQL, they cannot be integrated in jOOQ's
								DSL either. </fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="ARITHMETIC">
<fo:marker marker-class-name="section">
<fo:block>3.10. Arithmetic operations and concatenation</fo:block>
</fo:marker>3.10. Arithmetic operations and concatenation</fo:block>
<fo:block font-size="11pt">
							Your database can do the math for you. Most arithmetic operations are
							supported, but also string concatenation can be very efficient if done
							already in the database.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Mathematical operations</fo:block>
							<fo:block font-size="11pt">Arithmetic operations are implemented just like
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="FUNCTIONS">functions</fo:basic-link>, with
								similar limitations as far as type restrictions are concerned. You can
								use any of these operators: </fo:block>

							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">  +  -  *  /  %</fo:block>

							<fo:block font-size="11pt">In order to express a SQL query like this one: </fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT ((1 + 2) * (5 - 3) / 2) % 10 FROM DUAL</fo:block>
							<fo:block font-size="11pt">You can write something like this in jOOQ: </fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(create.val(1).add(2).mul(create.val(5).sub(3)).div(2).mod(10));	</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Datetime arithmetic</fo:block>
							<fo:block font-size="11pt">jOOQ also supports the Oracle-style syntax for adding days to a Field&lt;? extends java.util.Date&gt; </fo:block>
							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT SYSDATE + 3 FROM DUAL;</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(create.currentTimestamp().add(3));</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">String concatenation</fo:block>
							<fo:block font-size="11pt">This is not really an arithmetic expression, but it's still an
								expression with operators: The string concatenation. jOOQ
								provides you with the Field's concat() method:</fo:block>
							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT 'A' || 'B' || 'C' FROM DUAL

-- Or in MySQL:
SELECT concat('A', 'B', 'C')</fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"> 
// For all RDBMS, including MySQL:
create.select(concat("A", "B", "C"));

</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="CASE">
<fo:marker marker-class-name="section">
<fo:block>3.11. The CASE clause</fo:block>
</fo:marker>3.11. The CASE clause</fo:block>
<fo:block font-size="11pt">
							The SQL standard supports a CASE clause, which works very similar to
							Java's if-else statement. In complex SQL, this is very useful for value
							mapping
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">The two flavours of CASE</fo:block>
							<fo:block font-size="11pt">The CASE clause is part of the standard SQL syntax. While some RDBMS
								also offer an IF clause, or a DECODE function, you can always rely on
								the two types of CASE syntax: </fo:block>

							<fo:table width="100%" table-layout="fixed">
<fo:table-column column-width="88mm"/>
<fo:table-column column-width="88mm"/>
<fo:table-body>
<fo:table-row>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">CASE WHEN T_AUTHOR.FIRST_NAME = 'Paulo'  THEN 'brazilian'
     WHEN T_AUTHOR.FIRST_NAME = 'George' THEN 'english'
                                         ELSE 'unknown'
END

-- OR:

CASE T_AUTHOR.FIRST_NAME WHEN 'Paulo'  THEN 'brazilian'
                         WHEN 'George' THEN 'english'
                                       ELSE 'unknown'
END </fo:block>
</fo:block>
</fo:table-cell>
<fo:table-cell>
<fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.decode()
      .when(T_AUTHOR.FIRST_NAME.equal("Paulo"), "brazilian")
      .when(T_AUTHOR.FIRST_NAME.equal("George"), "english")
      .otherwise("unknown");

// OR:

create.decode().value(T_AUTHOR.FIRST_NAME)
               .when("Paulo", "brazilian")
               .when("George", "english")
               .otherwise("unknown");</fo:block>
</fo:block>
</fo:table-cell>
</fo:table-row>
</fo:table-body>
</fo:table>

							<fo:block font-size="11pt">
								In jOOQ, both syntaxes are supported (although, Derby only knows the
								first one, which is more general). Unfortunately, both case and else
								are reserved words in Java. jOOQ chose to use decode() from the Oracle
								DECODE function, and otherwise(), which means the same as else. Please
								note that in the above examples, all values were always constants. You
								can of course also use Field instead of the various constants.
							</fo:block>
							<fo:block font-size="11pt">A CASE clause can be used anywhere where you can place a Field. For
								instance, you can SELECT the above expression, if you're selecting
								from T_AUTHOR: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT T_AUTHOR.FIRST_NAME, [... CASE EXPR ...] AS nationality
  FROM T_AUTHOR</fo:block>


  							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">CASE clauses in an ORDER BY clause</fo:block>
							<fo:block font-size="11pt">Sort indirection is often implemented with a CASE clause of a
								SELECT's ORDER BY clause. In SQL, this reads: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT *
FROM T_AUTHOR
ORDER BY CASE FIRST_NAME WHEN 'Paulo'  THEN 1
                         WHEN 'George' THEN 2
                                       ELSE null
         END</fo:block>

							<fo:block font-size="11pt">This will order your authors such that all 'Paulo' come first, then
								all 'George' and everyone else last (depending on your RDBMS' handling
								of NULL values in sorting). This is a very common task, such that jOOQ
								simplifies its use: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select()
      .from(T_AUTHOR)
      .orderBy(T_AUTHOR.FIRST_NAME.sortAsc("Paulo", "George"))
      .execute();</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="CAST">
<fo:marker marker-class-name="section">
<fo:block>3.12. Type casting</fo:block>
</fo:marker>3.12. Type casting</fo:block>
<fo:block font-size="11pt">
							Many RDBMS allow for implicit or explicit conversion between types.
							Apart from true type conversion, this is most often done with casting.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Enforcing a specific type when you need it</fo:block>
							<fo:block font-size="11pt">jOOQ's source code generator tries to find the most accurate type
								mapping between your vendor-specific data types and a matching Java
								type. For instance, most VARCHAR, CHAR, CLOB types will map to String.
								Most BINARY, BYTEA, BLOB types will map to byte[]. NUMERIC types will
								default to java.math.BigDecimal, but can also be any of
								java.math.BigInteger, Long, Integer, Short, Byte, Double, Float. </fo:block>
							<fo:block font-size="11pt">Sometimes, this automatic mapping might not be what you needed, or
								jOOQ cannot know the type of a field (because you created it from a
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="NESTED">nested select</fo:basic-link>).
								In those cases you would write SQL type CASTs like
								this: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- Let's say, your Postgres column LAST_NAME was VARCHAR(30)
-- Then you could do this:
SELECT CAST(T_AUTHOR.LAST_NAME AS TEXT) FROM DUAL</fo:block>
							<fo:block font-size="11pt">in jOOQ, you can write something like that: </fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(TAuthor.LAST_NAME.cast(PostgresDataType.TEXT));</fo:block>
							<fo:block font-size="11pt">The same thing can be achieved by casting a Field directly to
								String.class, as TEXT is the default data type in Postgres to map to
								Java's String</fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(TAuthor.LAST_NAME.cast(String.class));</fo:block>
							<fo:block font-size="11pt">The complete CAST API in Field consists of these three methods: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">public interface Field&lt;T&gt; {
    &lt;Z&gt; Field&lt;Z&gt; cast(Field&lt;Z&gt; field);
    &lt;Z&gt; Field&lt;Z&gt; cast(DataType&lt;Z&gt; type);
    &lt;Z&gt; Field&lt;Z&gt; cast(Class&lt;? extends Z&gt; type);
}

// And additional convenience methods in the Factory:
public class Factory {
    &lt;T&gt; Field&lt;T&gt; cast(Object object, Field&lt;T&gt; field);
    &lt;T&gt; Field&lt;T&gt; cast(Object object, DataType&lt;T&gt; type);
    &lt;T&gt; Field&lt;T&gt; cast(Object object, Class&lt;? extends T&gt; type);
    &lt;T&gt; Field&lt;T&gt; castNull(Field&lt;T&gt; field);
    &lt;T&gt; Field&lt;T&gt; castNull(DataType&lt;T&gt; type);
    &lt;T&gt; Field&lt;T&gt; castNull(Class&lt;? extends T&gt; type);
}</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="SQL">
<fo:marker marker-class-name="section">
<fo:block>3.13. When it's just easier: Plain SQL</fo:block>
</fo:marker>3.13. When it's just easier: Plain SQL</fo:block>
<fo:block font-size="11pt">
							jOOQ cannot foresee all possible vendor-specific SQL features for your
							database. And sometimes, even jOOQ code becomes too verbose. Then, you
							shouldn't hesitate to provide jOOQ with plain SQL, as you'd do with
							JDBC
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Plain SQL in jOOQ</fo:block>
							<fo:block font-size="11pt">A DSL is a nice thing to have, it feels "fluent" and "natural",
								especially if it models a well-known language, such as SQL. But a DSL
								is always expressed in another language (Java in this case), which was
								not made for exactly that DSL. If it were, then jOOQ would be
								implemented on a compiler-level, similar to Linq in .NET. But it's
								not, and so, the DSL is limited. We have seen many functionalities
								where the DSL becomes verbose. This can be especially true for: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="ALIAS">aliasing</fo:basic-link>
</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="NESTED">nested selects</fo:basic-link>
</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="ARITHMETIC">arithmetic expressions</fo:basic-link>
</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">
<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="CAST">casting</fo:basic-link>
</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
							<fo:block font-size="11pt">You'll probably find other examples. If verbosity scares you off,
								don't worry. The verbose use-cases for jOOQ are rather rare, and when
								they come up, you do have an option. Just write SQL the way you're
								used to! </fo:block>
							<fo:block font-size="11pt">jOOQ allows you to embed SQL as a String in these contexts: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Plain SQL as a condition </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Plain SQL as a field </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Plain SQL as a function </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Plain SQL as a table </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Plain SQL as a query </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-size="11pt">To construct artefacts wrapping plain SQL, you should use any of
								these methods from the Factory class: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// A condition
Condition condition(String sql);
Condition condition(String sql, Object... bindings);

// A field with an unknown data type
Field<Object> field(String sql);
Field<Object> field(String sql, Object... bindings);

// A field with a known data type
<T> Field<T> field(String sql, Class<T> type);
<T> Field<T> field(String sql, Class<T> type, Object... bindings);
<T> Field<T> field(String sql, DataType<T> type);
<T> Field<T> field(String sql, DataType<T> type, Object... bindings);

// A function
<T> Field<T> function(String name, Class<T> type, Field<?>... arguments);
<T> Field<T> function(String name, DataType<T> type, Field<?>... arguments);

// A table
Table<?> table(String sql);
Table<?> table(String sql, Object... bindings);

// A query without results (update, insert, etc)
Query query(String sql);
Query query(String sql, Object... bindings);

// A query with results
ResultQuery<Record> resultQuery(String sql);
ResultQuery<Record> resultQuery(String sql, Object... bindings);

// A query with results. This is the same as resultQuery(...).fetch();
Result<Record> fetch(String sql);
Result<Record> fetch(String sql, Object... bindings);]]></fo:block>

							<fo:block font-size="11pt">Apart from the general factory methods, plain SQL is useful also in
								various other contexts. For instance, when adding a .where("a = b")
								clause to a query. Hence, there exist several convenience methods
								where plain SQL can be inserted usefully. This is an example
								displaying all various use-cases in one single query: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// You can use your table aliases in plain SQL fields
// As long as that will produce syntactically correct SQL
Field<?> LAST_NAME    = create.field("a.LAST_NAME");

// You can alias your plain SQL fields
Field<?> COUNT1       = create.field("count(*) x");

// If you know a reasonable Java type for your field, you
// can also provide jOOQ with that type
Field<Integer> COUNT2 = create.field("count(*) y", Integer.class);

       // Use plain SQL as select fields
create.select(LAST_NAME, COUNT1, COUNT2)

       // Use plain SQL as aliased tables (be aware of syntax!)
      .from("t_author a")
      .join("t_book b")

       // Use plain SQL for conditions both in JOIN and WHERE clauses
      .on("a.id = b.author_id")

       // Bind a variable in plain SQL
      .where("b.title != ?", "Brida")

       // Use plain SQL again as fields in GROUP BY and ORDER BY clauses
      .groupBy(LAST_NAME)
      .orderBy(LAST_NAME);]]></fo:block>

							<fo:block font-size="11pt">There are some important things to keep in mind when using plain
								SQL: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">jOOQ doesn't know what you're doing. You're on your own again!
								</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">You have to provide something that will be syntactically correct.
									If it's not, then jOOQ won't know. Only your JDBC driver or your
									RDBMS will detect the syntax error. </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">You have to provide consistency when you use variable binding. The
									number of ? must match the number of variables </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Your SQL is inserted into jOOQ queries without further checks.
									Hence, jOOQ can't prevent SQL injection. </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>
						<fo:block break-after="page"/>
<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="ADVANCED">
<fo:marker marker-class-name="section">
<fo:block>4. Advanced topics</fo:block>
</fo:marker>4. Advanced topics</fo:block>
<fo:block font-size="11pt">In these sections you will learn about advanced concepts that
					you might not use every day</fo:block>
					<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Overview</fo:block>
					<fo:block font-size="11pt">This section covers some advanced topics and features that don't fit into any other section. </fo:block>
				<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="MasterData">
<fo:marker marker-class-name="section">
<fo:block>4.1. Master data generation. Enumeration tables</fo:block>
</fo:marker>4.1. Master data generation. Enumeration tables</fo:block>
<fo:block font-size="11pt">Enumerations are a powerful concept. Unfortunately, almost no
							RDBMS supports them, leaving you to create numerous tables for your
							enumerated values. But these values are still enumerations!</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Enumeration tables</fo:block>
							<fo:block font-size="11pt">Only MySQL and Postgres databases support true ENUM types natively.
								Some other RDBMS allow you to map the concept of an ENUM data type to
								a CHECK constraint, but those constraints can contain arbitrary SQL.
								 With jOOQ, you
								can "simulate" ENUM types by declaring a table as a "master data
								table" in the configuration. At code-generation time, this table will
								be treated specially, and a Java enum type is generated from its data.
							</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Configure master data tables</fo:block>
							<fo:block font-size="11pt">As previously discussed in the
							  <fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="Configuration">configuration and setup</fo:basic-link>
							   section, you can configure master data tables as follows: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">#Generate a master data table enum classes (several Java regular expressions, separated by comma)
generator.generate.master-data-tables=[a list of tables]

#For every master data table, specify two special columns
generator.generate.master-data-table-literal.[master data table]=[column used for enum literals]
generator.generate.master-data-table-description.[master data table]=[column used for documentation]</fo:block>

							<fo:block font-size="11pt">The results of this will be a Java enum that looks similar to this: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[public enum TLanguage implements MasterDataType<Integer> {

  /**
   * English
   */
  en(1, "en", "English"),

  /**
   * Deutsch
   */
  de(2, "de", "Deutsch"),

  /**
   * Français
   */
  fr(3, "fr", "Français"),

  /**
   * null
   */
  pt(4, "pt", null),
  ;

  private final Integer id;
  private final String cd;
  private final String description;

  // [ ... constructor and getters for the above properties ]
}]]></fo:block>

							<fo:block font-size="11pt">In the above example, you can see how the configured primary key is
								mapped to the id member, the configured literal column is mapped to
								the cd member and the configured description member is mapped to the
								description member and output as Javadoc. In other words, T_LANGUAGE
								is a table with 4 rows and at least three columns. </fo:block>
							<fo:block font-size="11pt">The general contract (with jOOQ 1.6.2+) is that there must be </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid"> A single-column primary key column of character or integer type
								</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">An optional unique literal column of character or integer type
									(otherwise, the primary key is used as enum literal) </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">An optional description column of any type </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Using MasterDataTypes</fo:block>
							<fo:block font-size="11pt">The point of MasterDataTypes in jOOQ is that they behave exactly
								like true ENUM types. When the above T_LANGUAGE table is referenced by
								T_BOOK, instead of generating foreign key navigation methods and a
								LANGUAGE_ID Field&lt;Integer&gt;, a Field&lt;TLanguage&gt; is
								generated: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[public class TBook extends UpdatableTableImpl<TBookRecord> {

  // [...]
  public static final TableField<TBookRecord, TLanguage> LANGUAGE_ID =
                  new TableFieldImpl<TBookRecord, TLanguage>( /* ... */ );
}]]></fo:block>

							<fo:block font-size="11pt">Which can then be used in the TBookRecord directly: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[public class TBookRecord extends UpdatableRecordImpl<TBookRecord> {

  // [...]
  public TLanguage getLanguageId() { // [...]
  public void setLanguageId(TLanguage value) { // [...]
}]]></fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">When to use MasterDataTypes</fo:block>
							<fo:block font-size="11pt">You can use master data types when you're actually mapping master
								data to a Java enum. When the underlying table changes frequently,
								those updates will not be reflected by the statically generated code.
								Also, be aware that it will be difficult to perform actual JOIN
								operations on the underlying table with jOOQ, once the master data
								type is generated. </fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="SchemaMapping">
<fo:marker marker-class-name="section">
<fo:block>4.2. Mapping generated schemata and tables</fo:block>
</fo:marker>4.2. Mapping generated schemata and tables</fo:block>
<fo:block font-size="11pt">
							Sometimes, you cannot control productive schema names, because your
							application is deployed on a shared host, and you only get one schema
							to work with.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Mapping your DEV schema to a productive environment</fo:block>
							<fo:block font-size="11pt">You may wish to design your database in a way that you have several
								instances of your schema. This is useful when you want to cleanly
								separate data belonging to several customers / organisation units /
								branches / users and put each of those entities' data in a separate
								database or schema. </fo:block>
							<fo:block font-size="11pt">In our T_AUTHOR example this would mean that you provide a book
								reference database to several companies, such as My Book World and
								Books R Us. In that case, you'll probably have a schema setup like
								this: </fo:block>
							<fo:block padding-top="16pt" padding-bottom="16pt" page-break-inside="avoid">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">DEV: Your development schema. This will be the schema that you
									base code generation upon, with jOOQ </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">MY_BOOK_WORLD: The schema instance for My Book World </fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">-</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">BOOKS_R_US: The schema instance for Books R Us </fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Mapping DEV to MY_BOOK_WORLD with jOOQ</fo:block>
							<fo:block font-size="11pt">When a user from My Book World logs in, you want them to access the
								MY_BOOK_WORLD schema using classes generated from DEV. This can be
								achieved with the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SchemaMapping.java')">org.jooq.SchemaMapping</fo:basic-link>
								class, that you can equip your Factory
								with. Take the following example: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SchemaMapping mapping = new SchemaMapping();
mapping.add(DEV, "MY_BOOK_WORLD");

// Add the mapping to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, mapping);

// Run queries with the "mapped" factory
create.selectFrom(T_AUTHOR).fetch();</fo:block>

							<fo:block font-size="11pt">The query executed with a Factory equipped with the above mapping
								will in fact produce this SQL statement: </fo:block>
							<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT * FROM MY_BOOK_WORLD.T_AUTHOR</fo:block>
							<fo:block font-size="11pt">Even if T_AUTHOR was generated from DEV. </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Mapping several schemata</fo:block>
							<fo:block font-size="11pt">Your development database may not be restricted to hold only one DEV
								schema. You may also have a LOG schema and a MASTER schema. Let's say
								the MASTER schema is shared among all customers, but each customer has
								their own LOG schema instance. Then you can enhance your SchemaMapping
								like this: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SchemaMapping mapping = new SchemaMapping();
mapping.add(DEV, "MY_BOOK_WORLD");
mapping.add(LOG, "MY_BOOK_WORLD_LOG");</fo:block>

							<fo:block font-size="11pt">This will map generated classes from DEV to MY_BOOK_WORLD, from LOG
								to MY_BOOK_WORLD_LOG, but leave the MASTER schema alone. Whenever you
								want to change your mapping configuration, you will have to create a
								new Factory</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Using a default schema</fo:block>
							<fo:block font-size="11pt">Another option to switch schema names is to use a default schema for
								the Factory's underlying Connection. Many RDBMS support a USE or SET
								SCHEMA command, which you can call like this: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Set the default schema
Schema MY_BOOK_WORLD = ...
create.use(MY_BOOK_WORLD);

// Run queries with factory having a default schema
create.selectFrom(T_AUTHOR).fetch();</fo:block>
							<fo:block font-size="11pt">Queries generated from the above Factory will produce this kind of SQL statement: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- the schema name is omitted from all SQL constructs.
SELECT * FROM T_AUTHOR</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Mapping of tables</fo:block>
							<fo:block font-size="11pt">Not only schemata can be mapped, but also tables. If you are not the
								owner of the database your application connects to, you might need to
								install your schema with some sort of prefix to every table. In our
								examples, this might mean that you will have to map DEV.T_AUTHOR to
								something MY_BOOK_WORLD.MY_APP__T_AUTHOR, where MY_APP__ is a prefix
								applied to all of your tables. This can be achieved by creating the
								following mapping: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SchemaMapping mapping = new SchemaMapping();
mapping.add(DEV, "MY_BOOK_WORLD");
mapping.add(T_AUTHOR, "MY_APP__T_AUTHOR");

// Add the mapping to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, mapping);

// Run queries with the "mapped" factory
create.selectFrom(T_AUTHOR).fetch();</fo:block>

							<fo:block font-size="11pt">The query executed with a Factory equipped with the above mapping will in fact produce this SQL statement: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT * FROM MY_BOOK_WORLD.MY_APP__T_AUTHOR</fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Mapping at code generation time</fo:block>
							<fo:block font-size="11pt">
								Note that you can also hard-wire schema mapping in generated artefacts
								at code generation time, e.g. when you have 5 developers with their own
								dedicated developer databases, and a common integration database. In the
								code generation configuration, you would then write.
							</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">#Use this as the developer's schema:
generator.database.input-schema=LUKAS_DEV_SCHEMA

#Use this as the integration / production database:
generator.database.output-schema=PROD
</fo:block>
							<fo:block font-size="11pt">
								See the manual's section about
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" internal-destination="META">jooq-codegen configuration</fo:basic-link>
								for more details
							</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="OracleHints">
<fo:marker marker-class-name="section">
<fo:block>4.3. Adding Oracle hints to queries</fo:block>
</fo:marker>4.3. Adding Oracle hints to queries</fo:block>
<fo:block font-size="11pt">
							Oracle has a powerful syntax to add hints as comments directly in your SQL
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">How to embed Oracle hints in SELECT</fo:block>
							<fo:block font-size="11pt">If you are closely coupling your application to an Oracle database,
								you might need to be able to pass hints of the form /*+HINT*/ with
								your SQL statements to the Oracle database. For example: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">SELECT /*+ALL_ROWS*/ FIRST_NAME, LAST_NAME
  FROM T_AUTHOR</fo:block>

  							<fo:block font-size="11pt">This can be done in jOOQ using the .hint() clause in your SELECT statement: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">create.select(FIRST_NAME, LAST_NAME)
      .hint("/*+ALL_ROWS*/")
      .from(T_AUTHOR);</fo:block>

							<fo:block font-size="11pt">Note that you can pass any string in the .hint() clause. If you use
								that clause, the passed string will always be put in between the
								SELECT [DISTINCT] keywords and the actual projection list </fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="CONNECTBY">
<fo:marker marker-class-name="section">
<fo:block>4.4. The Oracle CONNECT BY clause</fo:block>
</fo:marker>4.4. The Oracle CONNECT BY clause</fo:block>
<fo:block font-size="11pt">
							Hierarchical queries are supported by many RDBMS using the WITH clause.
							Oracle has a very neat and much less verbose syntax for hierarchical
							queries: CONNECT BY .. STARTS WITH
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">CONNECT BY .. STARTS WITH</fo:block>
							<fo:block font-size="11pt">If you are closely coupling your application to an Oracle database,
								you can take advantage of some Oracle-specific features, such as the
								CONNECT BY clause, used for hierarchical queries. The formal syntax
								definition is as follows: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">--   SELECT ..
--     FROM ..
--    WHERE ..
 CONNECT BY [NOCYCLE] condition [AND condition, ...] [START WITH condition]
-- GROUP BY ..</fo:block>
							<fo:block font-size="11pt">This can be done in jOOQ using the .connectBy(Condition) clauses in your SELECT statement: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Some Oracle-specific features are only available
// from the OracleFactory
OracleFactory create = new OracleFactory(connection);

// Get a table with elements 1, 2, 3, 4, 5
create.select(create.rownum())
      .connectBy(create.level().lessOrEqual(5))
      .fetch();</fo:block>

							<fo:block font-size="11pt">Here's a more complex example where you can recursively fetch
								directories in your database, and concatenate them to a path:</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[ OracleFactory ora = new OracleFactory(connection);

 List<?> paths =
 ora.select(ora.sysConnectByPath(DIRECTORY.NAME, "/").substring(2))
    .from(DIRECTORY)
    .connectBy(ora.prior(DIRECTORY.ID).equal(DIRECTORY.PARENT_ID))
    .startWith(DIRECTORY.PARENT_ID.isNull())
    .orderBy(ora.literal(1))
    .fetch(0);]]></fo:block>

    						<fo:block font-size="11pt">The output might then look like this</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">+------------------------------------------------+
|substring                                       |
+------------------------------------------------+
|C:                                              |
|C:/eclipse                                      |
|C:/eclipse/configuration                        |
|C:/eclipse/dropins                              |
|C:/eclipse/eclipse.exe                          |
+------------------------------------------------+
|...21 record(s) truncated...
</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="PIVOT">
<fo:marker marker-class-name="section">
<fo:block>4.5. The Oracle 11g PIVOT clause</fo:block>
</fo:marker>4.5. The Oracle 11g PIVOT clause</fo:block>
<fo:block font-size="11pt">
				    	    Oracle 11g has formally introduced the very powerful PIVOT clause, which
				    	    allows to specify a pivot column, expected grouping values for pivoting,
				    	    as well as a set of aggregate functions
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">PIVOT (aggregate FOR column IN (columns))</fo:block>
							<fo:block font-size="11pt">If you are closely coupling your application to an Oracle database,
								you can take advantage of some Oracle-specific features, such as the
								PIVOT clause, used for statistical analyses. The formal syntax
								definition is as follows: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">-- SELECT ..
     FROM table PIVOT (aggregateFunction [, aggregateFunction] FOR column IN (expression [, expression]))
--  WHERE ..</fo:block>

							<fo:block font-size="11pt">
								The PIVOT clause is available from the
								<fo:basic-link font-size="11pt" color="#882222" font-weight="bold" text-shadow="0 1px 2px #666666" external-destination="url('https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Table.java')">org.jooq.Table</fo:basic-link>
								type, as pivoting is done directly on a table.
								Currently, only Oracle's PIVOT clause is supported. Support for SQL Server's
								PIVOT clause will be added later. Also, jOOQ may simulate PIVOT for other
								dialects in the future.
							</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Export">
<fo:marker marker-class-name="section">
<fo:block>4.6. Exporting to XML, CSV, JSON, HTML, Text</fo:block>
</fo:marker>4.6. Exporting to XML, CSV, JSON, HTML, Text</fo:block>
<fo:block font-size="11pt">
							Get your data out of the Java world. Stream your data using any of the supported, wide-spread formats
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Exporting with jOOQ</fo:block>
							<fo:block font-size="11pt">If you are using jOOQ for scripting purposes or in a slim, unlayered
								application server, you might be interested in using jOOQ's exporting
								functionality (see also importing functionality). You can export any
								Result&lt;Record&gt; into any of these formats: </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">XML</fo:block>
							<fo:block font-size="11pt">Export your results as XML: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Fetch books and format them as XML
String xml = create.selectFrom(T_BOOK).fetch().formatXML();</fo:block>

							<fo:block font-size="11pt">The above query will result in an XML document looking like the following one: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[<!-- Find the XSD definition on www.jooq.org: -->
<jooq-export:result xmlns:jooq-export="http://www.jooq.org/xsd/jooq-export-1.6.2.xsd">
  <fields>
    <field name="ID"/>
    <field name="AUTHOR_ID"/>
    <field name="TITLE"/>
  </fields>
  <records>
    <record>
      <value field="ID">1</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">1984</value>
    </record>
    <record>
      <value field="ID">2</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">Animal Farm</value>
    </record>
  </records>
</jooq-export:result>]]></fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">CSV</fo:block>
							<fo:block font-size="11pt">Export your results as CSV: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Fetch books and format them as CSV
String csv = create.selectFrom(T_BOOK).fetch().formatCSV();</fo:block>

							<fo:block font-size="11pt">The above query will result in a CSV document looking like the following one: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">ID;AUTHOR_ID;TITLE
1;1;1984
2;1;Animal Farm</fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">JSON</fo:block>
							<fo:block font-size="11pt">Export your results as JSON: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Fetch books and format them as JSON
String json = create.selectFrom(T_BOOK).fetch().formatJSON();</fo:block>
							<fo:block font-size="11pt">The above query will result in a JSON document looking like the following one: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">{fields:["ID","AUTHOR_ID","TITLE"],
 records:[[1,1,"1984"],[2,1,"Animal Farm"]]}</fo:block>

 							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">HTML </fo:block>
 							<fo:block font-size="11pt">Export your results as HTML: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Fetch books and format them as HTML
String html = create.selectFrom(T_BOOK).fetch().formatHTML();</fo:block>
							<fo:block font-size="11pt">The above query will result in an HTML document looking like the following one: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>AUTHOR_ID</th>
      <th>TITLE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1984</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1</td>
      <td>Animal Farm</td>
    </tr>
  </tbody>
</table>]]></fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Text</fo:block>
							<fo:block font-size="11pt">Export your results as text: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Fetch books and format them as text
String text = create.selectFrom(T_BOOK).fetch().format();</fo:block>

							<fo:block font-size="11pt">The above query will result in a text document looking like the following one: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">+---+---------+-----------+
| ID|AUTHOR_ID|TITLE      |
+---+---------+-----------+
|  1|        1|1984       |
|  2|        1|Animal Farm|
+---+---------+-----------+</fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Import">
<fo:marker marker-class-name="section">
<fo:block>4.7. Importing data from XML, CSV</fo:block>
</fo:marker>4.7. Importing data from XML, CSV</fo:block>
<fo:block font-size="11pt">
							Use jOOQ to easily merge imported data into your database.
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">Importing with jOOQ</fo:block>
							<fo:block font-size="11pt">If you are using jOOQ for scripting purposes or in a slim, unlayered
								application server, you might be interested in using jOOQ's importing
								functionality (see also exporting functionality). You can import data
								directly into a table from any of these formats: </fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">CSV</fo:block>
							<fo:block font-size="11pt">The below CSV data represents two author records that may have been
								exported previously, by jOOQ's exporting functionality, and then
								modified in Microsoft Excel or any other spreadsheet tool: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">ID;AUTHOR_ID;TITLE
1;1;1984
2;1;Animal Farm</fo:block>

							<fo:block font-size="11pt">With jOOQ, you can load this data using various parameters from the
								loader API. A simple load may look like this: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">Factory create = new Factory(connection, SQLDialect.ORACLE);

// Load data into the T_AUTHOR table from an input stream
// holding the CSV data.
create.loadInto(T_AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, AUTHOR_ID, TITLE)
      .execute();</fo:block>

      						<fo:block font-size="11pt">Here are various other examples: </fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid">// Ignore the AUTHOR_ID column from the CSV file when inserting
create.loadInto(T_AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour for duplicate records.
create.loadInto(T_AUTHOR)

      // choose any of these methods
      .onDuplicateKeyUpdate()
      .onDuplicateKeyIgnore()
      .onDuplicateKeyError() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour when errors occur.
create.loadInto(T_AUTHOR)

      // choose any of these methods
      .onErrorIgnore()
      .onErrorAbort() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify transactional behaviour where this is possible
// (e.g. not in container-managed transactions)
create.loadInto(T_AUTHOR)

      // choose any of these methods
      .commitEach()
      .commitAfter(10)
      .commitAll()
      .commitNone() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();</fo:block>

							<fo:block font-size="11pt">Any of the above configuration methods can be combined to achieve
								the type of load you need. Please refer to the API's Javadoc to learn
								about more details. Errors that occur during the load are reported by
								the execute method's result: </fo:block>

<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[Loader<TAuthor> loader = /* .. */ .execute();

// The number of processed rows
int processed = loader.processed();

// The number of stored rows (INSERT or UPDATE)
int stored = loader.stored();

// The number of ignored rows (due to errors, or duplicate rule)
int ignored = loader.ignored();

// The errors that may have occurred during loading
List<LoaderError> errors = loader.errors();
LoaderError error = errors.get(0);

// The exception that caused the error
SQLException exception = error.exception();

// The row that caused the error
int rowIndex = error.rowIndex();
String[] row = error.row();

// The query that caused the error
Query query = error.query();]]></fo:block>

							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">XML </fo:block>
							<fo:block font-size="11pt">This will be implemented soon... </fo:block>
						<fo:block font-family="Georgia" font-size="18pt" padding-top="12pt" padding-bottom="12pt" page-break-after="avoid" id="Batch">
<fo:marker marker-class-name="section">
<fo:block>4.8. Using JDBC batch operations</fo:block>
</fo:marker>4.8. Using JDBC batch operations</fo:block>
<fo:block font-size="11pt">
							Some JDBC drivers have highly optimised means of executing batch
							operations. The JDBC interface for those operations is a bit verbose.
							jOOQ abstracts that by re-using the existing query API's
						</fo:block>
							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">JDBC batch operations</fo:block>
							<fo:block font-size="11pt">With JDBC, you can easily execute several statements at once using
								the addBatch() method. Essentially, there are two modes in JDBC</fo:block>

							<fo:block padding-top="16pt" padding-bottom="16pt">
<fo:list-block>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">o</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Execute several queries without bind values</fo:block>
</fo:list-item-body>
</fo:list-item>
								<fo:list-item>
<fo:list-item-label>
<fo:block font-size="11pt" page-break-inside="avoid">o</fo:block>
</fo:list-item-label>
<fo:list-item-body start-indent="body-start()">
<fo:block font-size="11pt" page-break-inside="avoid">Execute one query several times with bind values</fo:block>
</fo:list-item-body>
</fo:list-item>
							</fo:list-block>
</fo:block>

							<fo:block font-size="11pt">In code, this looks like the following snippet:</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// 1. several queries
// ------------------
Statement stmt = connection.createStatement();
stmt.addBatch("INSERT INTO author VALUES (1, 'Erich Gamma')");
stmt.addBatch("INSERT INTO author VALUES (2, 'Richard Helm')");
stmt.addBatch("INSERT INTO author VALUES (3, 'Ralph Johnson')");
stmt.addBatch("INSERT INTO author VALUES (4, 'John Vlissides')");
int[] result = stmt.executeBatch();

// 2. a single query
// -----------------
PreparedStatement stmt = connection.prepareStatement("INSERT INTO autho VALUES (?, ?)");
stmt.setInt(1, 1);
stmt.setString(2, "Erich Gamma");
stmt.addBatch();

stmt.setInt(1, 2);
stmt.setString(2, "Richard Helm");
stmt.addBatch();

stmt.setInt(1, 3);
stmt.setString(2, "Ralph Johnson");
stmt.addBatch();

stmt.setInt(1, 4);
stmt.setString(2, "John Vlissides");
stmt.addBatch();

int[] result = stmt.executeBatch();]]></fo:block>


							<fo:block font-family="Georgia" font-size="16pt" padding-top="10pt" padding-bottom="10pt" page-break-after="avoid">This will also be supported by jOOQ</fo:block>
							<fo:block font-size="11pt">Version 1.6.9 of jOOQ now supports executing queries in batch
								mode as follows:</fo:block>
<fo:block font-family="Courier" linefeed-treatment="preserve" white-space-collapse="false" white-space-treatment="preserve" font-size="6pt" margin="12pt" padding="4pt" border="2px solid #882222" background-color="#FFEEDD" page-break-inside="avoid"><![CDATA[// 1. several queries
// ------------------
create.batch(
	create.insertInto(AUTHOR, ID, NAME).values(1, "Erich Gamma"),
	create.insertInto(AUTHOR, ID, NAME).values(2, "Richard Helm"),
	create.insertInto(AUTHOR, ID, NAME).values(3, "Ralph Johnson"),
	create.insertInto(AUTHOR, ID, NAME).values(4, "John Vlissides"))
.execute();

// 2. a single query
// -----------------
create.batch(create.insertInto(AUTHOR, ID, NAME).values("?", "?"))
	  .bind(1, "Erich Gamma")
	  .bind(2, "Richard Helm")
	  .bind(3, "Ralph Johnson")
	  .bind(4, "John Vlissides")
	  .execute();]]></fo:block>
						<fo:block id="last-page"/>
</fo:flow>
</fo:page-sequence>
</fo:root>
