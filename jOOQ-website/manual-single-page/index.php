
<?php 
// The following content has been XSL transformed from manual.xml using html-page.xsl
// Please do not edit this content manually
require '../frame.php';
function getH1() {
    return "The jOOQ User Manual. Single Page";
}
function getActiveMenu() {
	return "manual";
}
function getSlogan() {
	return "The manual is the central reference for most of jOOQ's functionality.";
}
function printContent() {
    global $root;
?>

			
				<h3>All manuals</h3>
				<ul>
					
<li>
<a href="<?=$root?>/manual-single-page" title="The jOOQ Manual on one single page">A single-paged HTML manual</a>
</li>
					
<li>
<a href="<?=$root?>/manual" title="The jOOQ Manual on multiple pages">A multi-paged HTML manual</a>
</li>
					
<li>
<a href="<?=$root?>/manual-pdf/jOOQ-manual.pdf" title="The jOOQ Manual as a PDF">A downloadable PDF manual</a>
</li>
				
</ul>
			
			<h3>Overview</h3>
			<p>This manual is divided into four main sections:</p>
			<ul>
				
<li>
					
<a href="#JOOQ" title="jOOQ Manual reference: jOOQ classes and their usage">jOOQ classes and their usage</a>
					
<p>
						See these chapters for an overview of the jOOQ internal architecture
						and all types that are involved with jOOQ's query creation and
						execution. This is the important part for you, also, if you wish to
						extend jOOQ
					</p>
				
</li>
				
<li>
					
<a href="#META" title="jOOQ Manual reference: Meta model code generation">Meta model code generation</a>
					
<p>
						See these chapters to understand how you can use jOOQ as a source code
						generator, and what type of artefacts are generated by jOOQ
					</p>
				
</li>
				
<li>
					
<a href="#DSL" title="jOOQ Manual reference: DSL or fluent API. Where SQL meets Java">DSL or fluent API. Where SQL meets Java</a>
					
<p>
						See these chapters to learn about how to use jOOQ in every day's work. The
						jOOQ DSL is the main way to create and execute jOOQ queries almost as
						if SQL was embedded in Java directly
					</p>
				
</li>
				
<li>
					
<a href="#ADVANCED" title="jOOQ Manual reference: Advanced topics">Advanced topics</a>
					
<p>
						Some advanced topics including not-everyday functionality
					</p>
				
</li>
			
</ul>
		<h3>Table of contents</h3><ol>
<li>
<a title="jOOQ classes and their usage" href="#JOOQ">jOOQ classes and their usage</a>
<ol>
<li>
<a title="The example database" href="#ExampleDatabase">The example database</a>
</li>
<li>
<a title="The Factory class" href="#Factory">The Factory class</a>
</li>
<li>
<a title="Tables and Fields" href="#Table">Tables and Fields</a>
</li>
<li>
<a title="Results and Records" href="#Result">Results and Records</a>
</li>
<li>
<a title="Updatable Records" href="#UpdatableRecord">Updatable Records</a>
</li>
<li>
<a title="The Query and its various subtypes" href="#Query">The Query and its various subtypes</a>
</li>
<li>
<a title="ResultQuery and various ways of fetching data" href="#ResultQuery">ResultQuery and various ways of fetching data</a>
</li>
<li>
<a title="QueryParts and the global architecture" href="#QueryPart">QueryParts and the global architecture</a>
</li>
<li>
<a title="Serializability of QueryParts and Results" href="#Serializability">Serializability of QueryParts and Results</a>
</li>
<li>
<a title="Extend jOOQ with custom types" href="#Extend">Extend jOOQ with custom types</a>
</li>
</ol>
</li>
<li>
<a title="Meta model code generation" href="#META">Meta model code generation</a>
<ol>
<li>
<a title="Configuration and setup of the generator" href="#Configuration">Configuration and setup of the generator</a>
</li>
<li>
<a title="The schema, top-level generated artefact" href="#SCHEMA">The schema, top-level generated artefact</a>
</li>
<li>
<a title="Tables, views and their corresponding records" href="#TABLE">Tables, views and their corresponding records</a>
</li>
<li>
<a title="Procedures and packages" href="#PROCEDURE">Procedures and packages</a>
</li>
<li>
<a title="UDT's including ARRAY and ENUM types" href="#UDT">UDT's including ARRAY and ENUM types</a>
</li>
<li>
<a title="Sequences" href="#SEQUENCE">Sequences</a>
</li>
</ol>
</li>
<li>
<a title="DSL or fluent API. Where SQL meets Java" href="#DSL">DSL or fluent API. Where SQL meets Java</a>
<ol>
<li>
<a title="Complete SELECT syntax" href="#SELECT">Complete SELECT syntax</a>
</li>
<li>
<a title="Conditions" href="#CONDITION">Conditions</a>
</li>
<li>
<a title="Aliased tables and fields" href="#ALIAS">Aliased tables and fields</a>
</li>
<li>
<a title="Nested SELECT using the IN operator" href="#IN">Nested SELECT using the IN operator</a>
</li>
<li>
<a title="Nested SELECT using the EXISTS operator" href="#EXISTS">Nested SELECT using the EXISTS operator</a>
</li>
<li>
<a title="Other types of nested SELECT" href="#NESTED">Other types of nested SELECT</a>
</li>
<li>
<a title="UNION and other set operations" href="#UNION">UNION and other set operations</a>
</li>
<li>
<a title="Functions and aggregate operators" href="#FUNCTIONS">Functions and aggregate operators</a>
</li>
<li>
<a title="Stored procedures and functions" href="#PROCEDURES">Stored procedures and functions</a>
</li>
<li>
<a title="Arithmetic operations and concatenation" href="#ARITHMETIC">Arithmetic operations and concatenation</a>
</li>
<li>
<a title="The CASE clause" href="#CASE">The CASE clause</a>
</li>
<li>
<a title="Type casting" href="#CAST">Type casting</a>
</li>
<li>
<a title="When it's just easier: Plain SQL" href="#SQL">When it's just easier: Plain SQL</a>
</li>
</ol>
</li>
<li>
<a title="Advanced topics" href="#ADVANCED">Advanced topics</a>
<ol>
<li>
<a title="Master data generation. Enumeration tables" href="#MasterData">Master data generation. Enumeration tables</a>
</li>
<li>
<a title="Mapping generated schemata and tables" href="#SchemaMapping">Mapping generated schemata and tables</a>
</li>
<li>
<a title="Adding Oracle hints to queries" href="#OracleHints">Adding Oracle hints to queries</a>
</li>
<li>
<a title="The Oracle CONNECT BY clause" href="#CONNECTBY">The Oracle CONNECT BY clause</a>
</li>
<li>
<a title="Exporting to XML, CSV, JSON, HTML, Text" href="#Export">Exporting to XML, CSV, JSON, HTML, Text</a>
</li>
<li>
<a title="Importing data from XML, CSV" href="#Import">Importing data from XML, CSV</a>
</li>
<li>
<a title="Using JDBC batch operations" href="#Batch">Using JDBC batch operations</a>
</li>
</ol>
</li>
</ol><h1 id="JOOQ">
<a name="JOOQ"></a>1. jOOQ classes and their usage</h1><p>
					In these sections, you will learn about how to use jOOQ object
					factories and the jOOQ query model, to express
					your SQL in jOOQ
				</p>
					<h2>Overview</h2>
					<p>jOOQ essentially has two packages:</p>
					<ul>
						
<li>org.jooq: the jOOQ API. Here you will find interfaces for all
							SQL concepts
						</li>
						
<li>org.jooq.impl: the jOOQ implementation and factories. Most
							implementation classes are package private, you can only access
							them using the <a href="#Factory" title="jOOQ Manual reference: The Factory class">org.jooq.impl.Factory</a> 
						
</li>
					
</ul>
					<p>
						This section is about the main jOOQ classes and the global
						architecture. Most of the time, however, you will be using the
						<a href="#DSL" title="jOOQ Manual reference: DSL or fluent API. Where SQL meets Java">DSL or fluent API. Where SQL meets Java</a>
						in order to create queries
						the way you're used to in SQL
					</p>
				<h1 id="ExampleDatabase">
<a name="ExampleDatabase"></a>1.1. The example database</h1><p>
							For the examples in this manual, the same database will always be
							referred to. It essentially consists of these entities created using
							the Oracle dialect
						</p>
							<h2>Example CREATE TABLE statements</h2>
<pre class="prettyprint lang-sql">CREATE TABLE t_language (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  cd CHAR(2) NOT NULL,
  description VARCHAR2(50)
)

CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50) NOT NULL,
  date_of_birth DATE,
  year_of_birth NUMBER(7)
)

CREATE TABLE t_book (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  author_id NUMBER(7) NOT NULL,
  title VARCHAR2(400) NOT NULL,
  published_in NUMBER(7) NOT NULL,
  language_id NUMBER(7) NOT NULL,
  FOREIGN KEY (AUTHOR_ID) REFERENCES T_AUTHOR(ID),
  FOREIGN KEY (LANGUAGE_ID) REFERENCES T_LANGUAGE(ID)
)

CREATE TABLE t_book_store (
  name VARCHAR2(400) NOT NULL UNIQUE
)

CREATE TABLE t_book_to_book_store (
  book_store_name VARCHAR2(400) NOT NULL,
  book_id INTEGER NOT NULL,
  stock INTEGER,
  PRIMARY KEY(book_store_name, book_id),
  CONSTRAINT b2bs_book_store_id
    FOREIGN KEY (book_store_name)
    REFERENCES t_book_store (name)
    ON DELETE CASCADE,
  CONSTRAINT b2bs_book_id
    FOREIGN KEY (book_id)
    REFERENCES t_book (id)
    ON DELETE CASCADE
)</pre>
							<p>
								More entities, types (e.g. UDT's, ARRAY types, ENUM types, etc),
								stored procedures and packages are introduced for specific examples
							</p>
						<h1 id="Factory">
<a name="Factory"></a>1.2. The Factory class</h1><p>
							jOOQ hides most implementation facts from you by letting you
							use the jOOQ Factory as a single entry point to all of the jOOQ API.
							This way, you can discover all of the API using syntax auto-completion, for
							instance. 
						</p>
							<h2>The Factory and the jOOQ API</h2>
							<p>
								jOOQ exposes a lot of interfaces and hides most implementation facts 
								from client code. The reasons for this are: 
							</p>
							<ul>
								
<li>Interface-driven design. This allows for modelling queries in a fluent API most efficiently</li>
								
<li>Reduction of complexity for client code.</li>
								
<li>API guarantee. You only depend on the exposed interfaces, not concrete (potentially dialect-specific) implementations.</li>
							
</ul>
							<p>
								The <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/Factory.java" title="Internal API reference: org.jooq.impl.Factory">org.jooq.impl.Factory</a> 
								class is the main class from where you will create all jOOQ objects. 
								The Factory implements <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Configuration.java" title="Internal API reference: org.jooq.Configuration">org.jooq.Configuration</a> 
								and needs to be instanciated with the Configuration's properties: 
							</p>
							<ul>
								
<li>
<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SQLDialect.java" title="Internal API reference: org.jooq.SQLDialect">org.jooq.SQLDialect</a> : 
								The dialect of your database. This may be any of the currently
								supported database types</li>
								
<li>
<a href="http://download.oracle.com/javase/6/docs/api/java/sql/Connection.html" title="External API reference: java.sql.Connection">java.sql.Connection</a> : 
								A JDBC Connection that will be re-used for the whole
    							lifecycle of your Factory</li>
    							
<li>
<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SchemaMapping.java" title="Internal API reference: org.jooq.SchemaMapping">org.jooq.SchemaMapping</a> : 
    							An optional mapping of schemata. Check out the 
    							<a href="#SchemaMapping" title="jOOQ Manual reference: Mapping generated schemata and tables">SchemaMapping</a>
    							page for details</li> 
							
</ul>
							<p>If you are planning on using several RDBMS (= SQLDialects) or
								several distinct JDBC Connections in your software, this will mean
								that you have to create a new Factory every time. </p>
							
							<h3>Factory subclasses</h3>
							<p>
								There are a couple of subclasses for the general Factory. Each SQL
								dialect has its own dialect-specific factory. For instance, if you're
								only using the MySQL dialect, you can choose to create a new Factory
								using any of the following types: 
							</p>
<pre class="prettyprint lang-java">// A general, dialect-unspecific factory
Factory create = new Factory(connection, SQLDialect.MYSQL);

// A MySQL-specific factory
MySQLFactory create = new MySQLFactory(connection);</pre>
							<p>
								The advantage of using a dialect-specific Factory lies in the fact,
								that you have access to more proprietary RDMBS functionality. This may
								include: 
							</p>
							<ul>
								
<li>Oracle's <a href="#CONNECTBY" title="jOOQ Manual reference: The Oracle CONNECT BY clause">CONNECT BY</a>
								    pseudo columns and functions</li>
    							
<li>MySQL's encryption functions</li>
    							
<li>PL/SQL constructs, pgplsql, or any other dialect's ROUTINE-language (maybe in the future)</li>
							
</ul>
							<p>
								Another type of Factory subclasses are each generated schema's
								factories. If you generate your schema TEST, then you will have access
								to a TestFactory. This will be useful in the future, when access to
								schema artefacts will be unified. Currently, this has no use. 
							</p>
							
							<h3>Static Factory methods</h3>
							<p>
								With jOOQ 2.0, static factory methods have been introduced in order to
								make your code look more like SQL. Ideally, when working with jOOQ, you
								will simply static import all methods from the Factory class:
							</p>
							<pre class="prettyprint lang-java">import static org.jooq.impl.Factory.*;</pre>
							<p>
								This will allow to access functions even more fluently:
							</p>
							
<pre class="prettyprint lang-java">concat(trim(FIRST_NAME), trim(LAST_NAME));
// ... which is in fact the same as:
Factory.concat(Factory.trim(FIRST_NAME), Factory.trim(LAST_NAME));</pre>
							<p>
								Objects created statically from the Factory do not need a reference to
								any factory, as they can be constructed independently from your Configuration 
								(connection, dialect, schema mapping). They will access that information at
								render / bind time. See 
								<a href="#QueryPart" title="jOOQ Manual reference: QueryParts and the global architecture">more details on the QueryParts' internals</a>
							
</p>
							
							<h3>Potential problems</h3>
							<p>
								The jOOQ Factory expects its underlying
								<a href="http://download.oracle.com/javase/6/docs/api/java/sql/Connection.html" title="External API reference: java.sql.Connection">java.sql.Connection</a>
								to be <strong>open and ready</strong>
								for
								<a href="http://download.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html" title="External API reference: java.sql.PreparedStatement">java.sql.PreparedStatement</a>
								creation. You are responsible yourself for the
								lifecycle dependency between Factory and Connection. This means: 
							</p>
							<ul>
								
<li>jOOQ will never close the Connection.</li>
								
<li>jOOQ will never commit or rollback on the Connection 
									(Except for CSV-imports, if explicitly configured in the <a href="#Import" title="jOOQ Manual reference: Importing data from XML, CSV">Import API</a>)</li>
								
<li>jOOQ will never start any transactions.</li>
								
<li>
									jOOQ does not know the concept of a session as for instance
									<a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/architecture.html#architecture-current-session">Hibernate</a>
								
</li>
								
<li>jOOQ does not know the concept of a second-level cache. SQL is
									executed directly on the underlying RDBMS.</li>
								
<li>jOOQ does not make assumptions about the origin of the Connection.
									If it is container managed, that is fine.</li> 
							
</ul>
							<p>
								So if you want your queries to run in separate transactions, if you
								want to roll back a transaction, if you want to close a Connection and
								return it to your container, you will have to take care of that
								yourself. jOOQ's Factory will always expect its Connection to be in a
								ready state for creating new PreparedStatements. If it is not, you have
								to create a new Factory. 
							</p>
							<p>
								Please keep in mind that many jOOQ objects will reference your Factory
								for their whole lifecycle. This is especially interesting, when dealing
								with <a href="#UpdatableRecord" title="jOOQ Manual reference: Updatable Records">Updatable Records</a>,
								that can perform CRUD operations on the
								Factory's underlying Connection.
							</p>
						<h1 id="Table">
<a name="Table"></a>1.3. Tables and Fields</h1><p>
							Tables and their Fields are probably the most important objects in
							jOOQ. Tables represent any entity in your underlying RDBMS, that holds
							data for selection, insertion, updates, and deletion. In other words,
							views are also considered tables by jOOQ. 
						</p>
							<h2>The Table</h2>
							<p>The formal definition of a <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Table.java" title="Internal API reference: org.jooq.Table">org.jooq.Table</a> starts with </p>
							<pre class="prettyprint lang-java">public interface Table&lt;R extends Record&gt; // [...]</pre>
							<p>
								This means that every table is associated with a subtype of the
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Record.java" title="Internal API reference: org.jooq.Record">org.jooq.Record</a>
								class (see also
								<a href="#Result" title="jOOQ Manual reference: Results and Records">Results and Records</a>
								). For anonymous or ad-hoc tables,
								&lt;R&gt; will always bind to Record itself. 
							</p>
							<p>
								Unlike in the
								<a href="http://download.oracle.com/javaee/6/tutorial/doc/gjitv.html" title="Tutorial about JPA CriteriaQuery">JPA CriteriaQuery API</a>,
								this generic type
								&lt;R&gt;
								is not given so much importance as far as
								type-safety is concerned.
								SQL itself is highly typesafe. You have
								incredible flexibility of creating anonymous or ad-hoc
								types and
								reusing them from
								<a href="#NESTED" title="jOOQ Manual reference: Other types of nested SELECT">NESTED SELECT statements</a>
								or from many other
								use-cases. There is no way that this typesafety can be
								mapped to the Java world in a convenient way. If
								&lt;R&gt; would play a role as important
								as in JPA, jOOQ would suffer from the same verbosity, or inflexibility
								that JPA CriteriaQueries may have. 
							</p>
							
							<h2>The Field</h2>
							<p>The formal definition of a Field starts with </p>
							<pre class="prettyprint lang-java">public interface Field&lt;T&gt; // [...]</pre>
							<p>
								Fields are generically parameterised with a Java type
								&lt;T&gt;
								that reflects the closest match to the RDMBS's underlying datatype for that
								field. For instance, if you have a VARCHAR2 type Field in Oracle,
								&lt;T&gt;
								would bind to
								<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html" title="External API reference: java.lang.String">java.lang.String</a>
								for that Field in jOOQ. Oracle's NUMBER(7) would
								let
								&lt;T&gt;
								bind to
								<a href="http://download.oracle.com/javase/6/docs/api/java/lang/Integer.html" title="External API reference: java.lang.Integer">java.lang.Integer</a>,
								etc. This generic type is useful for two purposes:
							</p>
							<ul>
								
<li>It allows you to write type safe queries. For instance, you cannot
									compare Field
									&lt;String&gt;
									with Field
									&lt;Integer&gt;</li>
						
								
<li>It
									allows you to fetch correctly cast and converted values from
									your database result set. This is especially useful when &lt;T&gt; binds
									to
									advanced data types, such as
									<a href="#UDT" title="jOOQ Manual reference: UDT's including ARRAY and ENUM types">UDT's, ARRAY or ENUM types</a>
									, where jOOQ
									does the difficult non-standardised JDBC data type conversions for you.
								</li>
							
</ul> 
							
							<h2>Fields and tables put into action</h2>
							<p>The Field itself is a very broad concept. Other tools, or databases
								refer to it as expression or column. When you just want to </p>
								
							<pre class="prettyprint lang-sql">SELECT 1 FROM DUAL</pre>
							<p>
								Then 1 is considered a Field or more explicitly, a
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/Constant.java" title="Internal API reference: org.jooq.impl.Constant">org.jooq.impl.Constant</a>, 
								which implements Field, and DUAL is considered a Table or more explicitly 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/Dual.java" title="Internal API reference: org.jooq.impl.Dual">org.jooq.impl.Dual</a>, which implements Table
							</p>
							<p>
								More advanced uses become clear quickly, when you do things like 
							</p>
							<pre class="prettyprint lang-sql">SELECT 1 + 1 FROM DUAL</pre>
							<p>
								Where 1 + 1 itself is a Field or more explicitly, an 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/Expression.java" title="Internal API reference: org.jooq.impl.Expression">org.jooq.impl.Expression</a> 
								joining two Constants together. 
							</p>
							<p>
								See some details about how to create these queries in the
								<a href="#Query" title="jOOQ Manual reference: The Query and its various subtypes">Query section</a> of the manual 
							</p>
							
							<h2>TableFields</h2>
							<p>
								A specific type of field is the
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/TableField.java" title="Internal API reference: org.jooq.TableField">org.jooq.TableField</a>,
								which represents a physical
								Field in a physical Table. Both the
								TableField and its referenced Table
								know each other. The physical aspect
								of their nature is represented in
								jOOQ by
								<a href="#TABLE" title="jOOQ Manual reference: Tables, views and their corresponding records">meta model code generation</a>,
								where every entity in your database
								schema will be generated into a
								corresponding Java class.
							</p>
							<p>
								TableFields join both &lt;R&gt; and &lt;T&gt; generic parameters into their specification: 
							</p>
							<pre class="prettyprint lang-java">public interface TableField&lt;R extends Record, T&gt; // [...]</pre>
							<p>
								This can be used for additional type safety in the future, or by client code.
							</p>
						<h1 id="Result">
<a name="Result"></a>1.4. Results and Records</h1><p>
							Results and their Records come into play, when SELECT statements are
							executed. There are various ways to fetch data from a jOOQ SELECT
							statement. Essentially, the query results are always provided in the
							Result API
						</p>
							<h2>The Result</h2>
							<p>
								The
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Result.java" title="Internal API reference: org.jooq.Result">Result</a>&lt;R extends <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Record.java" title="Internal API reference: org.jooq.Record">Record</a>&gt;
								is essentially a wrapper for a List&lt;R extends Record&gt;
								providing
								many convenience methods for accessing single elements in
								the result
								set. Depending on the type of SELECT statement,
								&lt;R&gt; can be bound
								to a sub-type of Record, for instance to an
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/UpdatableRecord.java" title="Internal API reference: org.jooq.UpdatableRecord">org.jooq.UpdatableRecord</a>. 
								See the section on
								<a href="#UpdatableRecord" title="jOOQ Manual reference: Updatable Records">Updatable Records</a>
								for further details. 
							</p>
							
							<h2>The Cursor</h2>
							<p>
								A similar object is the 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Cursor.java" title="Internal API reference: org.jooq.Cursor">Cursor</a>&lt;R extends Record&gt;. 
								Unlike the Result, the cursor has not fetched all data from the database yet. 
								This means, you save memory (and potentially speed), but you can only access 
								data sequentially and you have to keep a JDBC ResultSet alive. Cursors behave 
								very much like the <a href="http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html" title="External API reference: java.util.Iterator">java.util.Iterator</a>, 
								by providing a very simple API. Some sample methods are: 
							</p>
<pre class="prettyprint lang-java">// Check whether there are any more records to be fetched
boolean hasNext() throws SQLException;

// Fetch the next record from the underlying JDBC ResultSet
R fetchOne() throws SQLException;

// Close the underlying JDBC ResultSet. Don't forget to call this, before disposing the Cursor.
void close() throws SQLException;</pre>

							<h2>The Record</h2>
							<p>
								The Record itself holds all the data from your selected tuple. If it is
								a <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/TableRecord.java" title="Internal API reference: org.jooq.TableRecord">org.jooq.TableRecord</a>, then it corresponds exactly to the type of one of your
								physical tables in your database. But any anonymous or ad-hoc tuple can
								be represented by the plain Record. A record mainly provides access to
								its data and adds convenience methods for data type conversion. These
								are the main access ways: 
							</p>
<pre class="prettyprint lang-java">// If you can keep a reference of the selected field, then you can get the corresponding value type-safely
&lt;T&gt; T getValue(Field&lt;T&gt; field);

// If you know the name of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(String fieldName);

// If you know the index of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(int index);</pre>
							<p>
								In some cases, you will not be able to reference the selected Fields
								both when you create the SELECT statement and when you fetch data from
								Records. Then you might use field names or indexes, as with JDBC.
								However, of course, the type information will then be lost as well. If
								you know what type you want to get, you can always use the Record's
								convenience methods for type conversion, however. Some examples: 
							</p>
<pre class="prettyprint lang-java">// These methods will try to convert a value to a BigDecimal.
// This will work for all numeric types and for CHAR/VARCHAR types, if they contain numeric values:
BigDecimal getValueAsBigDecimal(String fieldName);
BigDecimal getValueAsBigDecimal(int fieldIndex);

// This method can perform arbitrary conversions
&lt;T&gt; T getValue(String fieldName, Class&lt;? extends T&gt; type);
&lt;T&gt; T getValue(int fieldIndex, Class&lt;? extends T&gt; type);</pre>

							<p>
								For more information about the type conversions that are supported by
								jOOQ, read the Javadoc on 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/tools/Convert.java" title="Internal API reference: org.jooq.tools.Convert">org.jooq.tools.Convert</a>
							
</p>
						<h1 id="UpdatableRecord">
<a name="UpdatableRecord"></a>1.5. Updatable Records</h1><p>
							UpdatableRecords are a specific subtype of TableRecord that have
							primary key information associated with them.
						</p>
							<h2>CRUD Operations</h2>
							<p>As of jOOQ 1.5, the UpdatableRecord essentially contains three additional
							 methods <a href="http://de.wikipedia.org/wiki/CRUD">CRUD</a> 
							 (Create Read Update Delete) operations: </p>
<pre class="prettyprint lang-java">// Store any changes made to this record to the database.
// The record executes an INSERT if the PRIMARY KEY is NULL or has been changed. Otherwise, an UPDATE is performed.
int store();

// Deletes the record from the database.
int delete();

// Reflects changes made in the database to this Record
void refresh();</pre>
							<p>An example lifecycle of a book can be implemented as such:</p>
<pre class="prettyprint lang-java">// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.store();

// Update it with new values
book.setPublishedIn(2010);
book.store();

// Delete it
book.delete();</pre>
							<p>These operations are very simple utilities. They do not 
							reflect the functionality offered by <a href="http://www.hibernate.org/">Hibernate</a> 
							or other persistence managers. </p>
							
							<h2>Performing CRUD on non-updatable records</h2>
							<p>
								If the jOOQ code-generator cannot detect any PRIMARY KEY, or UNIQUE KEY
								on your tables, then the generated artefacts implement TableRecord,
								instead of UpdatableRecord. A TableRecord can perform the same CRUD
								operations as we have seen before, if you provide it with the necessary
								key fields. The API looks like this: 
							</p>
							
<pre class="prettyprint lang-java">// INSERT or UPDATE the record using the provided keys
int storeUsing(TableField&lt;R, ?&gt;... keys)

// DELETE a record using the provided keys
int deleteUsing(TableField&lt;R, ?&gt;... keys);

// Reflects changes made in the database to this Record
void refreshUsing(TableField&lt;R, ?&gt;... keys);</pre>
						
							<p>
								This is useful if your RDBMS does not support referential constraints (e.g. MySQL's 
								<a href="http://en.wikipedia.org/wiki/MyISAM">MyISAM</a>), or if you want to 
								store records to an unconstrained view. An example lifecycle of a book without 
								any keys can then be implemented as such: 
							</p>
<pre class="prettyprint lang-java">// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.storeUsing(TBook.ID);

// Update it with new values
book.setPublishedIn(2010);
book.storeUsing(TBook.ID);

// Delete it
book.deleteUsing(TBook.ID);</pre>
						<h1 id="Query">
<a name="Query"></a>1.6. The Query and its various subtypes</h1><p>
							The Query type hierarchy is what you use to execute queries. It has the
							following subtypes for each kind of operation
						</p>
							<h2>SELECT statements</h2>
							<p>
								There are essentially two ways of creating SELECT statements in jOOQ.
								For historical reasons, you can create 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SimpleSelectQuery.java" title="Internal API reference: org.jooq.SimpleSelectQuery">org.jooq.SimpleSelectQuery</a> or 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectQuery.java" title="Internal API reference: org.jooq.SelectQuery">org.jooq.SelectQuery</a>
								objects and add additional query clauses, such as 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Condition.java" title="Internal API reference: org.jooq.Condition">Conditions</a> or
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SortField.java" title="Internal API reference: org.jooq.SortField">SortFields</a> to it. 
								Since jOOQ 1.3, there is also the possibility to
								create SELECT statements using jOOQ's 
								<a href="#DSL" title="jOOQ Manual reference: DSL or fluent API. Where SQL meets Java">DSL API</a> in a much more intuitive
								and SQL-like way. 
							</p>
							<p>Use the DSL API when: </p>
							<ul>
								
<li>You want your code to look like SQL</li>
								
<li>You want your IDE to help you with auto-completion (you will not be able to write select .. order by .. where .. join or any of that stuff) </li>
							
</ul>
							<p>Use the regular API when: </p>
							<ul>
								
<li>You want to create your query step-by-step, creating query parts one-by-one</li>
							    
<li>You need to assemble your query from various places, passing the query around, adding new conditions and joins on the way </li>
							
</ul>
							<p>In any case, all API's will construct the same underlying
								implementation object, and in many cases, you can combine the two
								approaches. Let's check out the various SELECT statement types: </p>
								
							<ul>
								
<li>
<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java" title="Internal API reference: org.jooq.Select">org.jooq.Select</a>: 
								    This Query subtype stands for a general type of SELECT statement. 
								    It is also the main Select type for the 
								    <a href="#DSL" title="jOOQ Manual reference: DSL or fluent API. Where SQL meets Java">DSL API</a>. When executed, this object 
								    will hold a <a href="#Result" title="jOOQ Manual reference: Results and Records">Result containing the resulting Records</a>. 
								    This type is further subtyped for the various uses of a SELECT statement as such:</li> 
								
<li>
<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SimpleSelectQuery.java" title="Internal API reference: org.jooq.SimpleSelectQuery">org.jooq.SimpleSelectQuery</a>:
									This Query will allow for selecting from single physical Tables only.
									It therefore has access to the Table's generic type parameter 
									&lt;R extends Record&gt; and will provide a matching Result&lt;R&gt;. 
									This is especially useful if &lt;R&gt; is a subtype of 
									<a href="#UpdatableRecord" title="jOOQ Manual reference: Updatable Records">UpdatableRecord</a>.
									Then you will be able to perform updates on your result set immediately.</li>
								
<li>
<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectQuery.java" title="Internal API reference: org.jooq.SelectQuery">org.jooq.SelectQuery</a>:
									This Query will allow for selecting a subset of Fields from several 
									Tables. Because the results of such a query are considered of an anonymous
									or ad-hoc type, this Query will bind &lt;R&gt; to the general type Record 
									itself. The purpose of this Query type is to allow for full SQL support, 
									including SELECT, JOIN and GROUP BY clauses. </li>
							
</ul>
							
							<h3>Example: SQL query and DSL query</h3>
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">-- Select all books by authors born after 1920, named "Paulo" 
-- from a catalogue consisting of authors and books:


SELECT * 
  FROM t_author  
  JOIN t_book  
    ON t_author.id = t_book.author_id 
 WHERE t_author.year_of_birth &gt; 1920 
   AND t_author.first_name = 'Paulo'
 ORDER BY t_book.title</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">// Instanciate your factory using a JDBC connection.
Factory create = new Factory(connection, SQLDialect.ORACLE);

// Execute the query "on a single line"
Result&lt;Record&gt; result = create.select()
    .from(T_AUTHOR)
    .join(T_BOOK)
    .on(T_AUTHOR.ID.equal(T_BOOK.AUTHOR_ID))
    .where(T_AUTHOR.YEAR_OF_BIRTH.greaterThan(1920)
    .and(T_AUTHOR.FIRST_NAME.equal("Paulo")))
    .orderBy(T_BOOK.TITLE).fetch();</pre>
</td>
</tr>
</table>
							
							<p>
								In the above example, some generated artefacts are used for querying. 
								In this case, T_AUTHOR and T_BOOK are instances of types 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ-test/src/org/jooq/test/oracle/generatedclasses/tables/TAuthor.java" title="Internal API reference: org.jooq.test.oracle.generatedclasses.tables.TAuthor">TAuthor</a> and 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ-test/src/org/jooq/test/oracle/generatedclasses/tables/TBook.java" title="Internal API reference: org.jooq.test.oracle.generatedclasses.tables.TBook">TBook</a> respectively. 
								Their full qualification would read TAuthor.T_AUTHOR and TBook.T_BOOK, but in many cases, 
								it's useful to static import elements involved with queries, in order to decrease verbosity:
								<pre class="prettyprint lang-java">import static com.example.jooq.Tables.*;</pre> 
							
</p>
							
							<p>
								Apart from the singleton Table instances TAuthor.T_AUTHOR and
								TBook.T_BOOK, these generated classes also contain one member
								for every physical field, such as TAuthor.ID or TBook.TAUTHOR_ID, etc.
								Depending on your configuration, those members can be static members
								(better for static imports) or instance members (better for aliasing) 
							</p>
							
							<ul>
								
<li>For more information about code generation, check out the manual's section about 
									<a href="#META" title="jOOQ Manual reference: Meta model code generation">Meta model source code generation</a>.</li>
    							
<li>For more DSL examples, please consider the manual's section about the 
    								<a href="#DSL" title="jOOQ Manual reference: DSL or fluent API. Where SQL meets Java">DSL API</a>.</li>
							
</ul>
							
							<h3>Example: Non-DSL query</h3>
							<p>
								If you choose not to use the DSL API (for instance, because you don't
								want to add Query parts in the order SQL expects them), you can use
								this syntax: 
							</p>
<pre class="prettyprint lang-java">// Re-use the factory to create a SelectQuery. This example will not make use of static imports...
SelectQuery q = create.selectQuery();
q.addFrom(T_AUTHOR);

// This example shows some "mixed" API usage, where the JOIN is added with the standard API, and the 
// Condition is created using the DSL API
q.addJoin(T_BOOK, T_AUTHOR.ID.equal(T_BOOK.AUTHOR_ID));

// The AND operator between Conditions is implicit here
q.addConditions(T_AUTHOR.YEAR_OF_BIRTH.greaterThan(1920));
q.addConditions(T_AUTHOR.FIRST_NAME.equal("Paulo"));
q.addOrderBy(T_BOOK.TITLE);</pre>

							<h3>Fetching data</h3>
							<p>
								The <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java" title="Internal API reference: org.jooq.Select">org.jooq.Select</a> interface extends 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/ResultQuery.java" title="Internal API reference: org.jooq.ResultQuery">org.jooq.ResultQuery</a>, 
								which provides a range of methods to fetch data from the database. 
								Once you have constructed your SELECT query (see examples above), you 
								may choose to either simply execute() it, or use a variety of convenience
								fetchXXX() methods. 
							</p>
							<p>
								See the manual's 
								<a href="#ResultQuery" title="jOOQ Manual reference: ResultQuery and various ways of fetching data">section on the ResultQuery</a>
								for more details. 
							</p>
							
							
							<h2>INSERT Statements</h2>
							<p>jOOQ supports two modes for INSERT statements. 
							The INSERT VALUES and the INSERT SELECT syntax</p>
							
							<h3>Example: SQL query and DSL query</h3>
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">INSERT INTO T_AUTHOR 
    (ID, FIRST_NAME, LAST_NAME)
VALUES 
    (100, 'Hermann', 'Hesse'),
    (101, 'Alfred', 'D&ouml;blin');</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.insertInto(T_AUTHOR, 
        T_AUTHOR.ID, T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .values(100, "Hermann", "Hesse")
      .values(101, "Alfred", "D&ouml;blin")
      .execute();</pre>
</td>
</tr>
</table>

							<p>The DSL syntax tries to stay close to actual SQL. In detail,
								however, Java is limited in its possibilities. That's why the
								.values() clause is repeated for every record in multi-record inserts. 
								Some RDBMS support
								inserting several records at the same time. This is also supported in
								jOOQ, and simulated using UNION clauses for those RDBMS that don't 
								support this syntax.
								<pre class="prettyprint lang-sql">INSERT INTO .. SELECT .. UNION ALL SELECT ..</pre>
							
</p>
							<p>Note: Just like in SQL itself, you can have syntax errors when you
								don't have matching numbers of fields/values. Also, you can run into
								runtime problems, if your field/value types don't match. </p>
								
							<h3>Example: DSL Query, alternative syntax</h3>
							<p>MySQL (and some other RDBMS) allow for using an UPDATE-like syntax
								for INSERT statements. This is also supported in jOOQ, should you
								prefer that syntax. The above INSERT statement can also be expressed
								as follows: </p>
<pre class="prettyprint lang-java">create.insertInto(T_AUTHOR)
      .set(T_AUTHOR.ID, 100)
      .set(T_AUTHOR.FIRST_NAME, "Hermann")
      .set(T_AUTHOR.LAST_NAME, "Hesse")
      .newRecord()
      .set(T_AUTHOR.ID, 101)
      .set(T_AUTHOR.FIRST_NAME, "Alfred")
      .set(T_AUTHOR.LAST_NAME, "D&ouml;blin")
      .execute();</pre>
							<p>As you can see, this syntax is a bit more verbose, but also more
								type-safe, as every field can be matched with its value.</p>
								
							<h3>Example: ON DUPLICATE KEY UPDATE clause</h3>
							<p>The MySQL database supports a very convenient way to INSERT or
								UPDATE a record. This is a non-standard extension to the SQL syntax,
								which is supported by jOOQ and simulated in other RDBMS, where this is
								possible. Here is an example how to use the ON DUPLICATE KEY UPDATE
								clause: </p>
<pre class="prettyprint lang-java">// Add a new author called "Koontz" with ID 3.
// If that ID is already present, update the author's name
create.insertInto(T_AUTHOR, T_AUTHOR.ID, T_AUTHOR.LAST_NAME)
      .values(3, "Koontz")
      .onDuplicateKeyUpdate()
      .set(T_AUTHOR.LAST_NAME, "Koontz")
      .execute();</pre>
      
      						<h3>Example: INSERT .. RETURNING clause</h3>
							<p>The Postgres database has native support for an INSERT .. RETURNING
								clause. This is a very powerful concept that is simulated for all
								other dialects using JDBC's 
								<a href="http://download.oracle.com/javase/6/docs/api/java/sql/Statement.html#getGeneratedKeys()" title="External API reference: java.sql.Statement">getGeneratedKeys()</a> 
								method. Take this example:</p>
								
<pre class="prettyprint lang-java">// Add another author, with a generated ID
Record&lt;?&gt; record =
create.insertInto(T_AUTHOR, T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .values("Charlotte", "Roche")
      .returning(T_AUTHOR.ID)
      .fetchOne();

System.out.println(record.getValue(T_AUTHOR.ID));

// For some RDBMS, this also works when inserting several values
// The following should return a 2x2 table
Result&lt;?&gt; result =
create.insertInto(T_AUTHOR, T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .values("Johann Wolfgang", "von Goethe")
      .values("Friedrich", "Schiller")
      // You can request any field. Also trigger-generated values
      .returning(T_AUTHOR.ID, T_AUTHOR.CREATION_DATE)
      .fetch();</pre>
      					
      						<p>
      							Be aware though, that this can lead to race-conditions
      							in those databases that cannot properly return generated
      							ID values.
      						</p>
      							
      						<h3>Example: Non-DSL Query</h3>
      						<p>You can always use the more verbose regular syntax of the InsertQuery, if you need more control: </p>
<pre class="prettyprint lang-java">// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(T_AUTHOR.ID, 100);
i.addValue(T_AUTHOR.FIRST_NAME, "Hermann");
i.addValue(T_AUTHOR.LAST_NAME, "Hesse");

i.newRecord();
i.addValue(T_AUTHOR.ID, 101);
i.addValue(T_AUTHOR.FIRST_NAME, "Alfred");
i.addValue(T_AUTHOR.LAST_NAME, "D&ouml;blin");
i.execute();</pre>

							<h3>Example: INSERT Query combined with SELECT statements</h3>
							<p>The InsertQuery.addValue() method is overloaded, such that you can
								also provide a Field, potentially containing an expression: </p>
<pre class="prettyprint lang-java">// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(T_AUTHOR.ID, create.select(max(T_AUTHOR.ID).add(1)).from(T_AUTHOR).asField())
i.addValue(T_AUTHOR.FIRST_NAME, "Hermann");
i.addValue(T_AUTHOR.LAST_NAME, "Hesse");
i.execute();</pre>
							<p>Note that especially MySQL (and some other RDBMS) has some
								limitations regarding that syntax. You may not be able to
								select from the same table you're inserting into</p>
								
							<h3>Example: INSERT SELECT syntax support</h3>
							<p>In some occasions, you may prefer the INSERT SELECT syntax, for instance, when 
								you copy records from one table to another: </p>
<pre class="prettyprint lang-java">Insert i = create.insertInto(T_AUTHOR_ARCHIVE,
           create.selectFrom(T_AUTHOR).where(T_AUTHOR.DECEASED.equal(1)));
i.execute();</pre>

							
							<h2>UPDATE Statements</h2>
							<p>UPDATE statements are only possible on single tables. Support for 
							multi-table updates will be implemented in the near future. </p>
							
							<h3>Example: SQL query and DSL query</h3>
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">UPDATE T_AUTHOR
   SET FIRST_NAME = 'Hermann',
       LAST_NAME = 'Hesse'
 WHERE ID = 3;
 </pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.update(T_AUTHOR)
      .set(T_AUTHOR.FIRST_NAME, "Hermann")
      .set(T_AUTHOR.LAST_NAME, "Hesse")
      .where(T_AUTHOR.ID.equal(3))
      .execute();</pre>
</td>
</tr>
</table>
							
							<h3>Example: Non-DSL Query</h3>
							<p>Using the <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/UpdateQuery.java" title="Internal API reference: org.jooq.UpdateQuery">org.jooq.UpdateQuery</a> class, 
							this is how you could express an UPDATE statement:</p> 
<pre class="prettyprint lang-java">UpdateQuery&lt;TAuthorRecord&gt; u = create.updateQuery(T_AUTHOR);
u.addValue(T_AUTHOR.FIRST_NAME, "Hermann");
u.addValue(T_AUTHOR.FIRST_NAME, "Hesse");
u.addConditions(T_AUTHOR.ID.equal(3));
u.execute();</pre>

							
							<h2>DELETE Statements</h2>
							<p>DELETE statements are only possible on single tables. Support for 
							multi-table deletes will be implemented in the near future. </p>
							
							<h3>Example: SQL query and DSL query</h3>
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">DELETE T_AUTHOR
 WHERE ID = 100;
 </pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.delete(T_AUTHOR)
      .where(T_AUTHOR.ID.equal(100))
      .execute();</pre>
</td>
</tr>
</table>
							
							<h3>Example: Non-DSL Query</h3>
							<p>Using the <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/DeleteQuery.java" title="Internal API reference: org.jooq.DeleteQuery">org.jooq.DeleteQuery</a> class, 
							this is how you could express a DELETE statement: </p> 
<pre class="prettyprint lang-java">DeleteQuery&lt;TAuthorRecord&gt; d = create.deleteQuery(T_AUTHOR);
d.addConditions(T_AUTHOR.ID.equal(100));
d.execute();</pre>


							<h2>MERGE Statement</h2>
							<p>
								The MERGE statement is one of the most advanced standardised SQL
								constructs, which is supported by DB2, HSQLDB, Oracle, SQL Server and
								Sybase (MySQL has the similar INSERT .. ON DUPLICATE KEY UPDATE
								construct. H2's MERGE variant is currently not supported.)
							</p>
							<p>
								The point of the standard MERGE statement is to take a TARGET table, and
								merge (INSERT, UPDATE) data from a SOURCE table into it. DB2, Oracle,
								SQL Server and Sybase also allow for DELETING some data and for adding
								many additional clauses. Those non-standard extensions are currently
								not supported. Here is an example:
							</p>
							
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">-- Check if there is already an author called 'Hitchcock'
-- If there is, rename him to John. If there isn't add him.

MERGE INTO T_AUTHOR
USING (SELECT 1 FROM DUAL)
ON (LAST_NAME = 'Hitchcock')
WHEN MATCHED THEN UPDATE SET FIRST_NAME = 'John'
WHEN NOT MATCHED THEN INSERT (LAST_NAME) 
                      VALUES ('Hitchcock')</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.mergeInto(T_AUTHOR)
      .using(create().selectOne())
      .on(T_AUTHOR.LAST_NAME.equal("Hitchcock"))
      .whenMatchedThenUpdate()
      .set(T_AUTHOR.FIRST_NAME, "John")
      .whenNotMatchedThenInsert(T_AUTHOR.LAST_NAME)
      .values("Hitchcock")
      .execute();

</pre>
</td>
</tr>
</table>
							
							
							<h2>TRUNCATE Statement</h2>
							<p>
								The syntax is trivial:
							</p>
							
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">TRUNCATE TABLE T_AUTHOR;</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.truncate(T_AUTHOR).execute();</pre>
</td>
</tr>
</table>
							<p>This is not supported by Ingres and SQLite. jOOQ will execute a DELETE FROM
								T_AUTHOR statement instead. </p>
						<h1 id="ResultQuery">
<a name="ResultQuery"></a>1.7. ResultQuery and various ways of fetching data</h1><p>
							Various jOOQ query type extend the ResultQuery which provides many means of
							fetching data. In general, fetching means executing and returning some
							sort of result.
						</p>
							<h2>The ResultQuery provides many convenience methods</h2>
<pre class="prettyprint lang-java">public interface ResultQuery&lt;R extends Record&gt; {

  // These methods allow for fetching a jOOQ Result
  // or parts of it.
  // ----------------------------------------------

  // Fetch the whole result
  Result&lt;R&gt; fetch();

  // Fetch a single field from the result
  &lt;T&gt; List&lt;T&gt; fetch(Field&lt;T&gt; field);
      List&lt;?&gt; fetch(int fieldIndex);
      List&lt;?&gt; fetch(String fieldName);

  // Fetch the first Record
  R fetchAny();

  // Fetch exactly one Record
  R fetchOne();

  // Fetch a single field of exactly one Record
  &lt;T&gt; T  fetchOne(Field&lt;T&gt; field);
  Object fetchOne(int fieldIndex);
  Object fetchOne(String fieldName);

  // These methods transform the result into another
  // form, if org.jooq.Result is not optimal
  // -----------------------------------------------

  // Fetch the resulting records as Maps
  List&lt;Map&lt;String, Object&gt;&gt; fetchMaps();
  Map&lt;String, Object&gt; fetchOneMap();

  // Fetch the result as a Map
  &lt;K&gt;    Map&lt;K, R&gt; fetchMap(Field&lt;K&gt; key);
  &lt;K, V&gt; Map&lt;K, V&gt; fetchMap(Field&lt;K&gt; key, Field&lt;V&gt; value);

  // Fetch the resulting records as arrays
  Object[][] fetchArrays();
  Object[] fetchOneArray();

  // Fetch a single field as an array
  &lt;T&gt; T[] fetchArray(Field&lt;T&gt; field);
  Object[] fetchArray(int fieldIndex);
  Object[] fetchArray(String fieldName);

  // These methods transform the result into a user-
  // defined form, if org.jooq.Result is not optimal
  // -----------------------------------------------

  // Fetch the resulting records into a custom POJO
  // type, which may or may not be JPA-annotated
  &lt;E&gt; List&lt;E&gt; fetchInto(Class&lt;? extends E&gt; type);

  // Fetch the resulting records into a custom
  // record handler, similar to how Spring JdbcTemplate's
  // RowMapper or the Ollin Framework works.
  &lt;H extends RecordHandler&lt;R&gt;&gt; H fetchInto(H handler);

  // These change the behaviour of fetching itself,
  // especially, when not all data should be
  // fetched at once
  // ----------------------------------------------

  // Fetch a Cursor for lazy iteration
  Cursor&lt;R&gt; fetchLazy();

  // Fetch data asynchronously and let client code
  // decide, when the data must be available.
  // This makes use of the java.util.concurrent API,
  // Similar to how Avaj&eacute; Ebean works.
  FutureResult&lt;R&gt; fetchLater();
  FutureResult&lt;R&gt; fetchLater(ExecutorService executor);
}</pre>
						<h1 id="QueryPart">
<a name="QueryPart"></a>1.8. QueryParts and the global architecture</h1><p>When constructing Query objects in jOOQ, everything is
							considered a QueryPart. The purpose of this quickly becomes clear when
							checking out the QueryPart API essentials</p>
							<h2>Everything is a QueryPart</h2>
							<p>
								A
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Query.java" title="Internal API reference: org.jooq.Query">org.jooq.Query</a>
								and all its contained objects is a
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/QueryPart.java" title="Internal API reference: org.jooq.QueryPart">org.jooq.QueryPart</a>.
								QueryParts essentially provide this functionality:
							</p>
							<ul>
								
<li>they can render SQL using the toSQL(RenderContext) method</li>
								
<li>they can bind variables using the bind(BindContext) method</li>
							
</ul>
							
							<p>Both of these methods are contained in jOOQ's internal API's
							   <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/QueryPartInternal.java" title="Internal API reference: org.jooq.QueryPartInternal">org.jooq.QueryPartInternal</a>, which is 
							   internally implemented by every QueryPart. QueryPart internals are best
							   illustrated with an example.</p>
							   
						   <h2>Example: CompareCondition</h2>
						   <p>A simple example can be provided by checking out jOOQ's internal
								representation of a 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/CompareCondition.java" title="Internal API reference: org.jooq.impl.CompareCondition">org.jooq.impl.CompareCondition</a>. 
								It is used for any condition
								comparing two fields as for example the T_AUTHOR.ID = T_BOOK.AUTHOR_ID
								condition here: </p>
<pre class="prettyprint lang-sql">-- [...]
FROM T_AUTHOR
JOIN T_BOOK ON T_AUTHOR.ID = T_BOOK.AUTHOR_ID
-- [...]</pre>

							<p>This is how jOOQ implements such a condition: </p>
							
<pre class="prettyprint lang-java">@Override
public final void bind(BindContext context) throws SQLException {
    // The CompareCondition itself does not bind any variables.
    // But the two fields involved in the condition might do so...
    context.bind(field1).bind(field2);
}

@Override
public final void toSQL(RenderContext context) {
    // The CompareCondition delegates rendering of the Fields to the Fields
    // themselves and connects them using the Condition's comparator operator:    
    context.sql(field1)
           .sql(" ");

    // If the second field is null, some convenience behaviour can be
    // implemented here
    if (field2.isNullLiteral()) {
        switch (comparator) {
            case EQUALS:
                context.sql("is null");
                break;

            case NOT_EQUALS:
                context.sql("is not null");
                break;

            default:
                throw new IllegalStateException("Cannot compare null with " + comparator);
        }
    }
    
    // By default, also delegate the right hand side's SQL rendering to the
    // underlying field
    else {
        context.sql(comparator.toSQL())
               .sql(" ")
               .sql(field2);
    }
}
</pre>
							<p>For more complex examples, please refer to the codebase, directly</p>
						<h1 id="Serializability">
<a name="Serializability"></a>1.9. Serializability of QueryParts and Results</h1><p>Most of the jOOQ API implements the Serializable interface.
							This helps storing queries and partial queries in files, transferring
							queries or result data over TCP/IP, etc. </p>
							<h2>Attaching QueryParts</h2>
							<p>
								The only transient element in any jOOQ object is the 
								<a href="#Factory" title="jOOQ Manual reference: The Factory class">The Factory class</a>'s
								underlying 
								<a href="http://download.oracle.com/javase/6/docs/api/java/sql/Connection.html" title="External API reference: java.sql.Connection">java.sql.Connection</a>. When you want to execute queries after
								de-serialisation, or when you want to store/refresh/delete 
								<a href="#UpdatableRecord" title="jOOQ Manual reference: Updatable Records">Updatable Records</a>, 
								you will have to "import" or "re-attach" them to a Factory
							</p>
<pre class="prettyprint lang-java">// Deserialise a SELECT statement
ObjectInputStream in = new ObjectInputStream(...);
Select&lt;?&gt; select = (Select&lt;?&gt;) in.readObject();

// This will throw a DetachedException:
select.execute();

// In order to execute the above select, attach it first
Factory create = new Factory(connection, SQLDialect.ORACLE);
create.attach(select);</pre>
					
					
							<h2>Automatically attaching QueryParts</h2>
							<p>In simple cases, you can register a ConfigurationProvider in jOOQ's ConfigurationRegistry</p>
<pre class="prettyprint lang-java">// Create your own custom ConfigurationProvider that will make
// your default Factory available to jOOQ
ConfigurationProvider provider = new CustomConfigurationProvider();

// Statically register the provider to jOOQ's ConfigurationRegistry
ConfigurationRegistry.setProvider(provider);</pre>

							<p>Once you have executed these steps, all subsequent deserialisations
								will try to access a Configuration (containing a JDBC Connection) from
								your ConfigurationProvider. This may be useful when </p>
							<ul>
								
<li>transporting jOOQ QueryParts or Records via TCP/IP, RMI, etc (e.g.
									between client and server), before immediately executing queries,
									storing UpdatableRecords</li>
								
<li>
									Using automatic mechanisms as known in
									<a href="http://wicket.apache.org/">Wicket</a>
								
</li>
							
</ul>
						<h1 id="Extend">
<a name="Extend"></a>1.10. Extend jOOQ with custom types</h1><p>Maybe jOOQ is missing functionality that you would like to see,
							or you can't wait for the next release... In this case, you can extend
							any of the following open jOOQ implementation classes</p>
							<h2>Write your own QueryPart implementations</h2>
							<p>If a SQL clause is too complex to express with jOOQ, you can extend
								either one of the following types for use directly in a jOOQ query:</p>
<pre class="prettyprint lang-java">public abstract class CustomField&lt;T&gt; extends AbstractField&lt;T&gt; {
  // [...]
}
public abstract class CustomCondition extends AbstractCondition {
  // [...]
}</pre>

							<p>These two classes are declared public and covered by integration
								tests. When you extend these classes, you will have to provide your
								own implementations for the <a href="#QueryPart" title="jOOQ Manual reference: QueryParts and the global architecture">QueryParts</a>' 
								bind(<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/BindContext.java" title="Internal API reference: org.jooq.BindContext">BindContext</a>) and 
								toSQL(<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/RenderContext.java" title="Internal API reference: org.jooq.RenderContext">RenderContext</a>) methods:</p>
<pre class="prettyprint lang-java">// This method must produce valid SQL. If your QueryPart contains other QueryParts, you may delegate SQL code generation to them
// in the correct order, passing the render context.
//
// If context.inline() is true, you must inline all bind variables
// If context.inline() is false, you must generate ? for your bind variables
public void toSQL(RenderContext context);

// This method must bind all bind variables to a PreparedStatement. If your QueryPart contains other QueryParts, you may delegate
// variable binding to them in the correct order, passing the bind context.
//
// Every QueryPart must ensure, that it starts binding its variables at context.nextIndex().
public void bind(BindContext context) throws DataAccessException;</pre>

							<p>The above contract may be a bit tricky to understand at first. The
								best thing is to check out jOOQ source code and have a look at a
								couple of QueryParts, to see how it's done.</p>
							<h2>Plain SQL as an alternative</h2>
							<p>If you don't need integration of rather complex QueryParts into
								jOOQ, then you might be safer using simple 
								<a href="#SQL" title="jOOQ Manual reference: When it's just easier: Plain SQL">Plain SQL</a> functionality,
								where you can provide jOOQ with a simple String representation of your
								embedded SQL. </p>
						<h1 id="META">
<a name="META"></a>2. Meta model code generation</h1><p>In these sections you will learn about how to configure and use
					jOOQ's source code generator</p>
					<h2>Overview</h2>
					<p>
						In the previous chapter, we have seen how to use the 
						<a href="#Factory" title="jOOQ Manual reference: The Factory class">Factory</a> in order to create 
						<a href="#Query" title="jOOQ Manual reference: The Query and its various subtypes">Queries</a> and fetch data in 
						<a href="#Result" title="jOOQ Manual reference: Results and Records">Results</a>. The strength of jOOQ not
						only lies in its object-oriented 
						<a href="#QueryPart" title="jOOQ Manual reference: QueryParts and the global architecture">Query model</a>, 
						but also in the fact
						that Java source code is generated from your database schema into the
						META data model. jOOQ follows the paradigm, that your database comes
						first (see also <a href="<?=$root?>/">home page</a>). 
						This means that you should not modify
						generated source code, but only adapt entities in your database. Every
						change in your database is reflected in a corresponding change in your
						generated meta-model.
					</p>
					<p>
						Artefacts, such as tables, views, user defined types, sequences, stored
						procedures, packages have a corresponding artefact in Java.
					</p>
				<h1 id="Configuration">
<a name="Configuration"></a>2.1. Configuration and setup of the generator</h1><p>jOOQ uses a simple configuration file to configure source code generation.</p>
							<h2>The deliverables</h2>
							<p>
								There are three binaries available with jOOQ, to be downloaded from
								<a href="https://sourceforge.net/projects/jooq/">SourceForge</a>
								or from Maven central:
							</p>
							<ul>
								
<li>
									
<strong>jOOQ.jar</strong>
									
<br>
									The main library that you will include in your application to run jOOQ
								</li>
								
<li>
									
<strong>jOOQ-meta.jar</strong>
									
<br>
									The utility that you will include in your build to navigate your
									database schema for code generation. This can be used as a schema
									crawler as well.
								</li>
								
<li>
									
<strong>jOOQ-codegen.jar</strong>
									
<br>
									The utility that you will include in your build to generate your
									database schema
								</li>
							
</ul>
							
							<h2>Dependencies</h2>
							<p>All of jOOQ's dependencies are "optional", i.e. you can run
								jOOQ without any of those libraries.
								For instance, jOOQ maintains an "optional" dependency on log4j and slf4j.
								This means, that jOOQ tries to find log4j (and /log4j.xml) or slf4j on the
								classpath. If they are not present, then java.util.logging.Logger is
								used instead.
							</p>
							<p>
								Other optional dependencies are the JPA API, and the Oracle JDBC driver,
								which is needed for Oracle's advanced data types, only
							</p>
							
							
							<h2>Configure jOOQ</h2>
							<p>You need to tell jOOQ some things about your database connection.
								Here's an example of how to do it for a MySQL database </p>
<pre class="prettyprint">#Configure the database connection here
jdbc.Driver=com.mysql.jdbc.Driver
jdbc.URL=jdbc:mysql://[your jdbc URL]
jdbc.User=[your database user]
jdbc.Password=[your database password]

#The default code generator. You can override this one, to generate your own code style
#Defaults to org.jooq.util.DefaultGenerator
generator=org.jooq.util.DefaultGenerator

#The database type. The format here is:
#generator.database=org.util.[database].[database]Database
generator.database=org.jooq.util.mysql.MySQLDatabase

#The schema that is used locally as a source for meta information. This could be your
#development schema or the production schema, etc:
generator.database.input-schema=[your database schema / owner / name]

#All elements that are generated from your schema (several Java regular expressions, separated by comma)
#Watch out for case-sensitivity. Depending on your database, this might be important!
generator.database.includes=.*

#All elements that are excluded from your schema (several Java regular expressions, separated by comma). Excludes match before includes
generator.database.excludes=

#Primary key / foreign key relations should be generated and used. 
#This will be a prerequisite for various advanced features
#Defaults to false
generator.generate.relations=true

#Generate deprecated code for backwards compatibility 
#Defaults to true
generator.generate.deprecated=false

#The destination package of your generated classes (within the destination directory)
generator.target.package=[org.jooq.your.package]

#The destination directory of your generated classes
generator.target.directory=[/path/to/your/dir]</pre>

							<p>And you can add some optional advanced configuration parameters: </p>
<pre class="prettyprint">#The schema that is used in generated source code. This will be the production schema
#Use this to override your local development schema name for source code generation
#If not specified, this will be the same as the input-schema.
generator.database.output-schema=[your database schema / owner / name]

#Generate instance fields in your tables, as opposed to static fields. This simplifies aliasing
#Defaults to true
generator.generate.instance-fields=true

#Generate jOOU data types for your unsigned data types, which are not natively supported in Java
#Defaults to true
generator.generate.unsigned-types=true

#Generate a master data table enum classes (several Java regular expressions, separated by comma)
generator.generate.master-data-tables=[a list of tables]

#For every master data table, specify two special columns
generator.generate.master-data-table-literal.[master data table]=[column used for enum literals]
generator.generate.master-data-table-description.[master data table]=[column used for documentation]</pre>
							<p>Check out the manual's section about 
								<a href="#MasterData" title="jOOQ Manual reference: Master data generation. Enumeration tables">master data</a>
								 to find out more
								about those advanced configuration parameters. </p>
								
							<h2>Run jOOQ code generation</h2>
							<p>Code generation works by calling this class with the above property file as argument.</p>
							<pre class="prettyprint">org.jooq.util.GenerationTool /jooq-config.properties</pre>
							<p>Be sure that these elements are located on the classpath: </p>
							<ul>
								
<li>The property file</li>
								
<li>jooq.jar, jooq-meta.jar, jooq-codegen.jar</li>
								
<li>The JDBC driver you configured</li>
							
</ul>

							<h3>A command-line example (For Windows, unix/linux/etc will be similar)</h3>
							<ul>
								
<li>Put the property file, jooq*.jar and the JDBC driver into 
									a directory, e.g. C:\temp\jooq</li>
							    
<li>Go to C:\temp\jooq</li>
							    
<li>Run java -cp jooq.jar;jooq-meta.jar;jooq-codegen.jar;[JDBC-driver].jar;. org.jooq.util.GenerationTool /[property file] </li>
							
</ul>
							<p>Note that the property file must be passed as a classpath resource</p>
							
							<h3>Run code generation from Eclipse</h3>
							<p>Of course, you can also run code generation from your IDE. In
								Eclipse, set up a project like this. Note that this example uses
								jOOQ's log4j support by adding log4j.xml and log4j.jar to the project
								classpath: </p>
							<div class="screenshot">
							
<img alt="Eclipse configuration" class="screenshot" src="<?=$root?>/img/eclipse-example-01.png">
							</div>
							
							<p>Once the project is set up correctly with all required artefacts on
								the classpath, you can configure an Eclipse Run Configuration for
								org.jooq.util.GenerationTool. </p>
							<div class="screenshot">
							
<img alt="Eclipse configuration" class="screenshot" src="<?=$root?>/img/eclipse-example-02.png">
							</div>
							
							<p>With the properties file as an argument </p>
							<div class="screenshot">
							
<img alt="Eclipse configuration" class="screenshot" src="<?=$root?>/img/eclipse-example-03.png">
							</div>
							
							<p>And the classpath set up correctly</p>
							<div class="screenshot">
							
<img alt="Eclipse configuration" class="screenshot" src="<?=$root?>/img/eclipse-example-04.png">
							</div>
							
							<p>Finally, run the code generation and see your generated artefacts</p>
							<div class="screenshot">
							
<img alt="Eclipse configuration" class="screenshot" src="<?=$root?>/img/eclipse-example-05.png">
							</div>
							
							<h3>Run generation with ant</h3>
							<p>
								You can also use an ant task to generate your classes. As a rule of thumb, 
								remove the dots "." and dashes "-" from the .properties file's property names to get the 
								ant task's arguments: 
							</p>
<pre class="prettyprint lang-xml">&lt;!-- Task definition --&gt;
&lt;taskdef name="generate-classes" classname="org.jooq.util.GenerationTask"&gt;
  &lt;classpath&gt;
    &lt;fileset dir="${path.to.jooq.distribution}"&gt;
      &lt;include name="jOOQ.jar"/&gt;
      &lt;include name="jOOQ-meta.jar"/&gt;
      &lt;include name="jOOQ-codegen.jar"/&gt;
    &lt;/fileset&gt;
    &lt;fileset dir="${path.to.mysql.driver}"&gt;
      &lt;include name="${mysql.driver}.jar"/&gt;
    &lt;/fileset&gt;
  &lt;/classpath&gt;
&lt;/taskdef&gt;

&lt;!-- Run the code generation task --&gt;
&lt;target name="generate-test-classes"&gt;
  &lt;generate-classes 
      jdbcurl="jdbc:mysql://localhost/test"
      jdbcuser="root"
      jdbcpassword=""
      generatordatabaseinputschema="test"
      generatortargetpackage="org.jooq.test.generatedclasses"
      generatortargetdirectory="${basedir}/src"/&gt;
&lt;/target&gt;</pre>
					
										
							<h3>Integrate generation with Maven</h3>
							<p>Using the official jOOQ-codegen-maven plugin, you can integrate
								source code generation in your Maven build process: </p>
							
<pre class="prettyprint lang-xml">&lt;plugin&gt;

  &lt;!-- Specify the maven code generator plugin --&gt;
  &lt;groupId&gt;org.jooq&lt;/groupId&gt;
  &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;
  &lt;version&gt;1.6.7&lt;/version&gt;
  
  &lt;!-- The plugin should hook into the generate goal --&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;goals&gt;
        &lt;goal&gt;generate&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  
  &lt;!-- Manage the plugin's dependency. In this example, we'll use a Postgres database --&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;postgresql&lt;/groupId&gt;
      &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
      &lt;version&gt;8.4-702.jdbc4&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  
  &lt;!-- Specify the plugin configuration --&gt;
  &lt;configuration&gt;
  
    &lt;!-- JDBC connection parameters --&gt;
    &lt;jdbc&gt;
      &lt;driver&gt;org.postgresql.Driver&lt;/driver&gt;
      &lt;url&gt;jdbc:postgresql:postgres&lt;/url&gt;
      &lt;user&gt;postgres&lt;/user&gt;
      &lt;password&gt;test&lt;/password&gt;
    &lt;/jdbc&gt;
    
    &lt;!-- Generator parameters --&gt;
    &lt;generator&gt;
      &lt;name&gt;org.jooq.util.DefaultGenerator&lt;/name&gt;
      &lt;database&gt;
        &lt;name&gt;org.jooq.util.postgres.PostgresDatabase&lt;/name&gt;
        &lt;includes&gt;.*&lt;/includes&gt;
        &lt;excludes&gt;&lt;/excludes&gt;
        &lt;inputSchema&gt;public&lt;/inputSchema&gt;
      &lt;/database&gt;
      &lt;generate&gt;
        &lt;relations&gt;true&lt;/relations&gt;
        &lt;deprecated&gt;false&lt;/deprecated&gt;
      &lt;/generate&gt;
      &lt;target&gt;
        &lt;packageName&gt;org.jooq.util.maven.example&lt;/packageName&gt;
        &lt;directory&gt;target/generated-sources/jooq&lt;/directory&gt;
      &lt;/target&gt;
      &lt;masterDataTables&gt;
        &lt;masterDataTable&gt;
          &lt;name&gt;t_language&lt;/name&gt;
          &lt;literal&gt;cd&lt;/literal&gt;
          &lt;description&gt;description&lt;/description&gt;
        &lt;/masterDataTable&gt;
      &lt;/masterDataTables&gt;
    &lt;/generator&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
</pre>
							<p>See the full example of a pom.xml including the jOOQ-codegen artefact here:
							<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ-codegen-maven-example/pom.xml" title="jOOQ-codegen-maven example pom.xml file">https://github.com/lukaseder/jOOQ/blob/master/jOOQ-codegen-maven-example/pom.xml</a>
</p>
									
							<h3>Use jOOQ generated classes in your application</h3>
							<p>Be sure, both jOOQ.jar and your generated package (see
								configuration) are located on your classpath. Once this is done, you
								can execute SQL statements with your generated classes.</p>
						<h1 id="SCHEMA">
<a name="SCHEMA"></a>2.2. The schema, top-level generated artefact</h1><p>The schema is the top-level generated object in jOOQ. In many 
							RDBMS, the schema coincides with the owner of tables and other objects
						</p>
							<h2>The Schema</h2>
							<p>
								As of jOOQ 1.5, the top-level generated object is the
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Schema.java" title="Internal API reference: org.jooq.Schema">org.jooq.Schema</a>.
								The Schema itself has no relevant functionality, except for holding
								the schema name for all dependent generated artefacts. jOOQ queries try
								to always fully qualify an entity within the database using that Schema
							</p>
							
							<p>
								Currently, it is not possible to link generated artefacts from various
								schemata. If you have a stored function from Schema A, which returns a
								UDT from Schema B, the types cannot be linked. This enhancement is on
								the roadmap, though: <a href="https://sourceforge.net/apps/trac/jooq/ticket/282" title="Trac ticket: #282">#282</a>.
							</p>
							
							<p>
								When you have several schemata that are logically equivalent (i.e. they
								contain identical entities, but the schemata stand for different
								users/customers/clients, etc), there is a solution for that. Check out
								the manual's section on support for 
								<a href="#SchemaMapping" title="jOOQ Manual reference: Mapping generated schemata and tables">multiple equivalent schemata</a> 
							
</p>

							<h3>Schema contents</h3>
							<p>The schema can be used to dynamically discover generate database
								artefacts. Tables, sequences, and other items are accessible from the
								schema. For example:</p>
<pre class="prettyprint lang-java">public final java.util.List&lt;org.jooq.Sequence&lt;?&gt;&gt; getSequences();
public final java.util.List&lt;org.jooq.Table&lt;?&gt;&gt; getTables();</pre>
						<h1 id="TABLE">
<a name="TABLE"></a>2.3. Tables, views and their corresponding records</h1><p>
							The most important generated artefacts are Tables and TableRecords.
							Every Table has a Record type associated with it that models a single tuple
							of that entity: Table&lt;R extends Record&gt;.
						</p>
							<h2>Tables and TableRecords</h2>
							<p>
								The most important generated artefacts are 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Table.java" title="Internal API reference: org.jooq.Table">Tables</a> and 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/TableRecord.java" title="Internal API reference: org.jooq.TableRecord">TableRecords</a>. As
								discussed in previous chapters about 
								<a href="#Table" title="jOOQ Manual reference: Tables and Fields">Tables</a> and 
								<a href="#Result" title="jOOQ Manual reference: Results and Records">Results</a>, jOOQ uses the
								Table class to model entities (both tables and views) in your database
								Schema. Every Table has a Record type associated with it that models a
								single tuple of that entity: Table&lt;R extends Record&gt;. This
								couple of Table&lt;R&gt; and R are generated as such:
							</p>
							<p>
								Suppose we have the tables as defined in the 
								<a href="#ExampleDatabase" title="jOOQ Manual reference: The example database">example database</a>. 
								Then, using a
								default configuration, these (simplified for the example) classes will
								be generated:
							</p>
							
							<h3>The Table as an entity meta model</h3>
<pre class="prettyprint lang-java">public class TAuthor extends UpdatableTableImpl&lt;TAuthorRecord&gt; {

    // The singleton instance of the Table
    public static final TAuthor T_AUTHOR = new TAuthor();

    // The Table's fields. 
    // Depending on your jooq-codegen configuraiton, they can also be static    
    public final TableField&lt;TAuthorRecord, Integer&gt; ID =            // [...]
    public final TableField&lt;TAuthorRecord, String&gt; FIRST_NAME =     // [...]
    public final TableField&lt;TAuthorRecord, String&gt; LAST_NAME =      // [...]
    public final TableField&lt;TAuthorRecord, Date&gt; DATE_OF_BIRTH =    // [...]
    public final TableField&lt;TAuthorRecord, Integer&gt; YEAR_OF_BIRTH = // [...]
    
    // When you don't choose the static meta model, you can typesafely alias your tables.
    // Aliased tables will then hold references to the above final fields, too
    public TAuthor as(String alias) {
      // [...]
    }
}</pre>

							<h3>The Table's associated TableRecord</h3>
							<p>If you use the 
								<a href="#Query" title="jOOQ Manual reference: The Query and its various subtypes">SimpleSelectQuery</a>
								 syntax (both in standard and DSL
								mode), then your SELECT statement will return the single Table&lt;R
								extends Record&gt;'s associated Record type &lt;R&gt;. In the case of
								the above TAuthor Table, this will be a TAuthorRecord. </p>
								
<pre class="prettyprint lang-java">public class TAuthorRecord extends UpdatableRecordImpl&lt;TAuthorRecord&gt; {

    // Getters and setters for the various fields
    public void setId(Integer value) {       // [...]
    public Integer getId() {                 // [...]
    public void setFirstName(String value) { // [...]
    public String getFirstName() {           // [...]
    public void setLastName(String value) {  // [...]
    public String getLastName() {            // [...]
    public void setDateOfBirth(Date value) { // [...]
    public Date getDateOfBirth() {           // [...]

    // Navigation methods for foreign keys
    public List&lt;TBookRecord&gt; fetchTBooks() { // [...]
}</pre>
						<h1 id="PROCEDURE">
<a name="PROCEDURE"></a>2.4. Procedures and packages</h1><p>
							Procedure support is one of the most important reasons why you should consider
							jOOQ. jOOQ heavily facilitates the use of stored procedures and
							functions via its source code generation.
						</p>
							<h2>Stored procedures in modern RDBMS</h2>
							<p>This is one of the most important reasons why you should consider
								jOOQ. Read also my 
								<a href="http://java.dzone.com/articles/2011-great-year-stored" title="Article on stored procedures and how to use them with jOOQ">article on dzone</a>
								about why stored procedures become
								more and more important in future versions of RDMBS. In this section
								of the manual, we will learn how jOOQ handles stored procedures in
								code generation. Especially before 
								<a href="#UDT" title="jOOQ Manual reference: UDT's including ARRAY and ENUM types">UDT and ARRAY support</a> was
								introduced to major RDBMS, these procedures tend to have dozens of
								parameters, with IN, OUT, IN OUT parameters mixed in all variations.
								JDBC only knows very basic, low-level support for those constructs.
								jOOQ heavily facilitates the use of stored procedures and functions
								via its source code generation. Essentially, it comes down to this:
							</p>
							
							<h3>"Standalone" stored procedures and functions</h3>
							<p>Let's say you have these stored procedures and functions in your Oracle database </p>
<pre class="prettyprint lang-sql">-- Check whether there is an author in T_AUTHOR by that name
CREATE OR REPLACE FUNCTION f_author_exists (author_name VARCHAR2) RETURN NUMBER;

-- Check whether there is an author in T_AUTHOR by that name
CREATE OR REPLACE PROCEDURE p_author_exists (author_name VARCHAR2, result OUT NUMBER);

-- Check whether there is an author in T_AUTHOR by that name and get his ID
CREATE OR REPLACE PROCEDURE p_author_exists_2 (author_name VARCHAR2, result OUT NUMBER, id OUT NUMBER);</pre>
							
							<p>jOOQ will essentially generate two artefacts for every procedure/function: </p>
							<ul>
								
<li>A class holding a formal Java representation of the procedure/function</li>
    							
<li>Some convenience methods to facilitate calling that procedure/function </li>
							
</ul>
							<p>Let's see what these things look like, in Java. The classes (simplified for the example): </p>
							
<pre class="prettyprint lang-java">// The function has a generic type parameter &lt;T&gt; bound to its return value
public class FAuthorExists extends org.jooq.impl.AbstractRoutine&lt;BigDecimal&gt; {

    // Much like Tables, functions have static parameter definitions
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]

    // And much like TableRecords, they have setters for their parameters
    public void setAuthorName(String value) { // [...]
    public void setAuthorName(Field&lt;String&gt; value) { // [...]
}

public class PAuthorExists extends org.jooq.impl.AbstractRoutine&lt;java.lang.Void&gt; {

    // In procedures, IN, OUT, IN OUT parameters are all represented
    // as static parameter definitions as well
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]
    public static final Parameter&lt;BigDecimal&gt; RESULT = // [...]

    // IN and IN OUT parameters have generated setters
    public void setAuthorName(String value) { // [...]

    // OUT and IN OUT parameters have generated getters
    public BigDecimal getResult() { // [...]
}

public class PAuthorExists_2 extends org.jooq.impl.AbstractRoutine&lt;java.lang.Void&gt; {
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]
    public static final Parameter&lt;BigDecimal&gt; RESULT = // [...]
    public static final Parameter&lt;BigDecimal&gt; ID = // [...]

    // the setters...
    public void setAuthorName(String value) { // [...]

    // the getters...
    public BigDecimal getResult() { // [...]
    public BigDecimal getId() { // [...]
}</pre>

							<p>An example invocation of such a stored procedure might look like this: </p>
							
<pre class="prettyprint lang-java">PAuthorExists p = new PAuthorExists();
p.setAuthorName("Paulo");
p.execute(configuration);
assertEquals(BigDecimal.ONE, p.getResult());</pre>

							<p>
								The above configuration is a
								<a href="#Factory" title="jOOQ Manual reference: The Factory class">Factory</a>,
								holding a reference to a JDBC connection, as discussed in a previous section.
								
								If you use the generated convenience methods, however, things are much simpler, still: 
							</p>
<pre class="prettyprint lang-java">// Every schema has a single Routines class with convenience methods
public final class Routines {

    // Convenience method to directly call the stored function
    public static BigDecimal fAuthorExists(Configuration configuration, String authorName) { // [...]

    // Convenience methods to transform the stored function into a
    // Field&lt;BigDecimal&gt;, such that it can be used in SQL
    public static Field&lt;BigDecimal&gt; fAuthorExists(Field&lt;String&gt; authorName) { // [...]
    public static Field&lt;BigDecimal&gt; fAuthorExists(String authorName) { // [...]

    // Procedures with 0 OUT parameters create void methods
    // Procedures with 1 OUT parameter create methods as such:
    public static BigDecimal pAuthorExists(Configuration configuration, String authorName) { // [...]

    // Procedures with more than 1 OUT parameter return the procedure
    // object (see above example)
    public static PAuthorExists_2 pAuthorExists_2(Configuration configuration, String authorName) { // [...]
}</pre>

							<p>An sample invocation, equivalent to the previous example:</p>
<pre class="prettyprint lang-java">assertEquals(BigDecimal.ONE, Procedures.pAuthorExists(configuration, "Paulo"));</pre>


							<h3>jOOQ's understanding of procedures vs functions</h3>
							<p>
								jOOQ does not formally distinguish procedures from functions.
								jOOQ only knows about routines, which can have return values
								and/or OUT parameters. This is the best option to handle the
								variety of stored procedure / function support across the
								various supported RDBMS. For more details, read on about this
								topic, here:
							</p>
							<p>
								
<a href="http://lukaseder.wordpress.com/2011/10/17/what-are-procedures-and-functions-after-all/" title="Blog post about the difference between procedures and functions in various RDBMS">lukaseder.wordpress.com/2011/10/17/what-are-procedures-and-functions-after-all/</a>
							
</p>
							
							<h3>Packages in Oracle</h3>
							<p>
								Oracle uses the concept of a PACKAGE to group several
								procedures/functions into a sort of namespace. The
								<a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt" title="SQL 92 standard">SQL standard</a>
								talks about "modules", to represent this concept, even if this is
								rarely implemented. This is reflected in jOOQ by the use of Java
								sub-packages in the source code generation destination package. Every
								Oracle package will be reflected by
							</p>
							<ul>
								
<li>A Java package holding classes for formal Java representations of
									the procedure/function in that package
								</li>
								
<li>A Java class holding convenience methods to facilitate calling
									those procedures/functions
								</li>
							
</ul>
							<p>
								Apart from this, the generated source code looks exactly like the
								one for
								standalone procedures/functions.
							</p>
							
							<h3>Member functions and procedures in Oracle</h3>
							<p>
								Oracle UDT's can have object-oriented structures including member functions
								and procedures. With Oracle, you can do things like this:
							</p>
<pre class="prettyprint lang-sql">CREATE OR REPLACE TYPE u_author_type AS OBJECT (
  id NUMBER(7),
  first_name VARCHAR2(50),
  last_name VARCHAR2(50),
  
  MEMBER PROCEDURE LOAD,
  MEMBER FUNCTION count_books RETURN NUMBER
)

-- The type body is omitted for the example
</pre>

							<p>
								These member functions and procedures can simply be mapped to Java
								methods:
							</p>
							
<pre class="prettyprint lang-java">
// Create an empty, attached UDT record from the Factory
UAuthorType author = create.newRecord(U_AUTHOR_TYPE);

// Set the author ID and load the record using the LOAD procedure
author.setId(1);
author.load();

// The record is now updated with the LOAD implementation's content
assertNotNull(author.getFirstName());
assertNotNull(author.getLastName());</pre>

							<p>For more details about UDT's see the Manual's section on
							<a href="#UDT" title="jOOQ Manual reference: UDT's including ARRAY and ENUM types">User Defined Types</a>
</p>
							
						<h1 id="UDT">
<a name="UDT"></a>2.5. UDT's including ARRAY and ENUM types</h1><p>
							Databases become more powerful when you can structure your data in user
							defined types. It's time for Java developers to give some credit to
							that.
						</p>
							<h2>Increased RDBMS support for UDT's</h2>
							<p>
								In recent years, most RDBMS have started to implement some support for
								advanced data types. This support has not been adopted very well by
								database users in the Java world, for several reasons: 
							</p>
							<ul>
								
<li>They are usually orthogonal to relational concepts. It is not easy
									to modify a UDT once it is referenced by a table column.</li>
								
<li>There is little standard support of accessing them from JDBC (and
									probably other database connectivity standards). </li>
							
</ul>
							<p>
								On the other hand, especially with stored procedures, these data types
								are likely to become more and more useful in the future. If you have a
								look at Postgres' capabilities of dealing with advanced data types
								(<a href="http://www.postgresql.org/docs/9.0/interactive/datatype-enum.html">ENUMs</a>,
								<a href="http://www.postgresql.org/docs/9.0/interactive/arrays.html">ARRAYs</a>,
								<a href="http://www.postgresql.org/docs/9.0/interactive/rowtypes.html">UDT's</a>),
								 this becomes more and more obvious.
							</p>
							<p>It is a central strategy for jOOQ, to standardise access to these
								kinds of types (as well as to 
								<a href="#PROCEDURE" title="jOOQ Manual reference: Procedures and packages">stored procedures</a>, of course) across all
								RDBMS, where these types are supported. </p>
								
							<h2>UDT types</h2>
							<p>User Defined Types (UDT) are helpful in major RDMBS with lots
							of proprietary functionality. The biggest player is clearly Oracle.
							Currently, jOOQ provides UDT support for only two databases: </p>
							<ul>
								
<li>Oracle</li>
								
<li>Postgres</li>
							
</ul>
							<p>Apart from that, </p>
							<ul>
								
<li>
									DB2 UDT's are not supported as they are very tough to
									serialise/deserialise. We don't think that this is a big enough
									requirement to put more effort in those, right now (see also the
									developers' discussion on
									<a href="https://sourceforge.net/apps/trac/jooq/ticket/164" title="Trac ticket: #164">#164</a>)
								</li>
							
</ul>
							
							<p>In Oracle, you would define UDTs like this: </p>
<pre class="prettyprint lang-sql">CREATE TYPE u_street_type AS OBJECT (
  street VARCHAR2(100),
  no VARCHAR2(30)
)

CREATE TYPE u_address_type AS OBJECT (
  street u_street_type,
  zip VARCHAR2(50),
  city VARCHAR2(50),
  country VARCHAR2(50),
  since DATE,
  code NUMBER(7)
)</pre>

							<p>These types could then be used in tables and/or stored procedures like such: </p>
<pre class="prettyprint lang-sql">CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  -- [...]
  address u_address_type
)

CREATE OR REPLACE PROCEDURE p_check_address (address IN OUT u_address_type);</pre>

							<p>
								Standard JDBC UDT support encourages JDBC-driver developers to implement
								interfaces such as 
								<a href="http://download.oracle.com/javase/6/docs/api/java/sql/SQLData.html" title="External API reference: java.sql.SQLData">java.sql.SQLData</a>, 
								<a href="http://download.oracle.com/javase/6/docs/api/java/sql/SQLInput.html" title="External API reference: java.sql.SQLInput">java.sql.SQLInput</a> and
								<a href="http://download.oracle.com/javase/6/docs/api/java/sql/SQLOutput.html" title="External API reference: java.sql.SQLOutput">java.sql.SQLOutput</a>. 
								Those interfaces are non-trivial to implement, or
								to hook into. Also access to 
								<a href="http://download.oracle.com/javase/6/docs/api/java/sql/Struct.html" title="External API reference: java.sql.Struct">java.sql.Struct</a> 
								is not really simple. Due
								to the lack of a well-defined JDBC standard, Oracle's JDBC driver
								rolls their own proprietary methods of dealing with these types. jOOQ
								goes a different way, it hides those facts from you entirely. With
								jOOQ, the above UDT's will be generated in simple 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/UDT.java" title="Internal API reference: org.jooq.UDT">UDT meta-model classes</a> and 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/UDTRecord.java" title="Internal API reference: org.jooq.UDTRecord">UDT record classes</a> as such:
							</p>
<pre class="prettyprint lang-java">// There is an analogy between UDT/Table and UDTRecord/TableRecord...
public class UAddressType extends UDTImpl&lt;UAddressTypeRecord&gt; {

    // The UDT meta-model singleton instance
    public static final UAddressType U_ADDRESS_TYPE = new UAddressType();

    // UDT attributes are modeled as static members. Nested UDT's
    // behave similarly
    public static final UDTField&lt;UAddressTypeRecord, UStreetTypeRecord&gt; STREET = // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; ZIP =               // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; CITY =              // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; COUNTRY =           // [...]
    public static final UDTField&lt;UAddressTypeRecord, Date&gt; SINCE =               // [...]
    public static final UDTField&lt;UAddressTypeRecord, Integer&gt; CODE =             // [...]
}</pre>

							<p>Now, when you interact with entities or procedures that hold UDT's, that's very simple as well. Here is an example: </p>
<pre class="prettyprint lang-java">// Fetch any author from the T_AUTHOR table
TAuthorRecord author = create.selectFrom(T_AUTHOR).fetchAny();

// Print out the author's address's house number
System.out.println(author.getAddress().getStreet().getNo());</pre>

							<p>A similar thing can be achieved when interacting with the example stored procedure: </p>
<pre class="prettyprint lang-java">// Create a new UDTRecord of type U_ADDRESS_TYPE
UAddressTypeRecord address = new UAddressTypeRecord();
address.setCountry("Switzerland");

// Call the stored procedure with IN OUT parameter of type U_ADDRESS_TYPE
address = Procedures.pCheckAddress(connection, address);</pre>


							<h2>ARRAY types</h2>
							<p>
								The notion of ARRAY types in RDBMS is not standardised at all. Very
								modern databases (especially the Java-based ones) have implemented
								ARRAY types exactly as what they are. "ARRAYs of something". In other
								words, an ARRAY OF VARCHAR would be something very similar to Java's
								notion of String[]. An ARRAY OF ARRAY OF VARCHAR would then be a
								String[][] in Java. Some RDMBS, however, enforce stronger typing and
								need the explicit creation of types for every ARRAY as well. These are
								example String[] ARRAY types in various SQL dialects supported by jOOQ
								1.5.4:
							</p>
							<ul>
								
<li>Oracle: VARRAY OF VARCHAR2. A strongly typed object encapsulating an ARRAY of a given type. See the <a href="http://download.oracle.com/docs/cd/B19306_01/appdev.102/b14261/collection_definition.htm">documentation.</a>
</li>
								
<li>Postgres: text[]. Any data type can be turned into an array by suffixing it with []. See the <a href="http://www.postgresql.org/docs/9.0/interactive/arrays.html">documentation</a>
</li>
								
<li>HSQLDB: VARCHAR ARRAY. Any data type can be turned into an array by suffixing it with ARRAY. See the <a href="http://hsqldb.org/doc/2.0/guide/sqlgeneral-chapt.html#N1070F">documentation</a>
</li>
								
<li>H2: ARRAY. H2 does not know of typed arrays. All ARRAYs are mapped to Object[]. See the <a href="http://www.h2database.com/html/datatypes.html#array_type">documentation</a>
</li>
							
</ul>
							<p>Soon to be supported: </p>
							<ul>
								
<li>DB2: Knows a similar strongly-typed ARRAY type, like Oracle </li>
							
</ul>
							<p>
								From jOOQ's perspective, the ARRAY types fit in just like any other
								type wherever the
								&lt;T&gt; generic type parameter is existent. It integrates well with tables
									and stored procedures.
							</p>
							
							<h3>Example: General ARRAY types</h3>
							<p>An example usage of ARRAYs is given here for the Postgres dialect </p>
							
<pre class="prettyprint lang-sql">CREATE TABLE t_arrays (
  id integer not null primary key,
  string_array VARCHAR(20)[],
  number_array INTEGER[]
)

CREATE FUNCTION f_arrays(in_array IN text[]) RETURNS text[]</pre>

							<p>When generating source code from the above entities, these artefacts will be created in Java: </p>
<pre class="prettyprint lang-java">public class TArrays extends UpdatableTableImpl&lt;TArraysRecord&gt; {

    // The generic type parameter &lt;T&gt; is bound to an array of a matching type
    public static final TableField&lt;TArraysRecord, String[]&gt; STRING_ARRAY =  // [...]
    public static final TableField&lt;TArraysRecord, Integer[]&gt; NUMBER_ARRAY = // [...]
}

// The convenience class is enhanced with these methods
public final class Functions {
    public static String[] fArrays(Connection connection, String[] inArray) { // [...]
    public static Field&lt;String[]&gt; fArrays(String[] inArray) {                                     // [...]
    public static Field&lt;String[]&gt; fArrays(Field&lt;String[]&gt; inArray) {                              // [...]
}</pre>

							<h3>Example: Oracle VARRAY types</h3>
							<p>In Oracle, a VARRAY type is something slightly different than in
								other RDMBS. It is a type that encapsules the actual ARRAY and creates
								a new type from it. While all text[] types are equal and thus
								compatible in Postgres, this does not apply for all VARRAY OF VARCHAR2
								types. Hence, it is important to provide access to VARRAY types and
								generated objects from those types as well. The example above would
								read like this in Oracle: </p>
								
<pre class="prettyprint lang-sql">CREATE TYPE u_string_array AS VARRAY(4) OF VARCHAR2(20)
CREATE TYPE u_number_array AS VARRAY(4) OF NUMBER(7)

CREATE TABLE t_arrays (
  id NUMBER(7) not null primary key,
  string_array u_string_array,
  number_array u_number_array
)

CREATE OR REPLACE FUNCTION f_arrays (in_array u_string_array)
RETURN u_string_array</pre>

							<p>Note that it becomes clear immediately, that a mapping from
								U_STRING_ARRAY to String[] is obvious. But a mapping from String[] to
								U_STRING_ARRAY is not. These are the generated 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/ArrayRecord.java" title="Internal API reference: org.jooq.ArrayRecord">org.jooq.ArrayRecord</a> and other
								artefacts in Oracle: </p>
								
<pre class="prettyprint lang-java">public class UStringArrayRecord extends ArrayRecordImpl&lt;String&gt; {  // [...]
public class UNumberArrayRecord extends ArrayRecordImpl&lt;Integer&gt; { // [...]

public class TArrays extends UpdatableTableImpl&lt;TArraysRecord&gt; {
    public static final TableField&lt;TArraysRecord, UStringArrayRecord&gt; STRING_ARRAY = // [...]
    public static final TableField&lt;TArraysRecord, UNumberArrayRecord&gt; NUMBER_ARRAY = // [...]
}

public final class Functions {
    public static UStringArrayRecord fArrays3(Connection connection, UStringArrayRecord inArray) { // [...]
    public static Field&lt;UStringArrayRecord&gt; fArrays3(UStringArrayRecord inArray) {                 // [...]
    public static Field&lt;UStringArrayRecord&gt; fArrays3(Field&lt;UStringArrayRecord&gt; inArray) {          // [...]
}</pre>

							
							<h2>ENUM types</h2>
							<p>True ENUM types are a rare species in the RDBMS world. Currently,
								MySQL and Postgres are the only RDMBS supported by jOOQ, that provide
								ENUM types. </p>
								
							<ul>
								
<li>In MySQL, an ENUM type is declared directly upon a column. It cannot be reused as a type. See the <a href="http://dev.mysql.com/doc/refman/5.5/en/enum.html">documentation.</a> 
</li>
								
<li>In Postgres, the ENUM type is declared independently and can be reused among tables, functions, etc. See the <a href="http://www.postgresql.org/docs/9.0/interactive/datatype-enum.html">documentation.</a> 
</li>
								
<li>Other RDMBS know about "ENUM constraints", such as the Oracle CHECK constraint. These are not true ENUMS, however. jOOQ refrains from using their information for source code generation </li>
							
</ul>
							
							<p>Some examples: </p>
<pre class="prettyprint lang-sql">-- An example enum type
CREATE TYPE u_book_status AS ENUM ('SOLD OUT', 'ON STOCK', 'ORDERED')

-- An example useage of that enum type
CREATE TABLE t_book (
  id INTEGER NOT NULL PRIMARY KEY,

  -- [...]
  status u_book_status
)</pre>

							<p>The above Postgres ENUM type will be generated as </p>
<pre class="prettyprint lang-java">public enum UBookStatus implements EnumType {
    ORDERED("ORDERED"),
    ON_STOCK("ON STOCK"),
    SOLD_OUT("SOLD OUT");

    // [...]
}</pre>
							<p>Intuitively, the generated classes for the T_BOOK table in Postgres would look like this: </p>
<pre class="prettyprint lang-sql">// The meta-model class
public class TBook extends UpdatableTableImpl&lt;TBookRecord&gt; {

    // The TableField STATUS binds &lt;T&gt; to UBookStatus
    public static final TableField&lt;TBookRecord, UBookStatus&gt; STATUS = // [...]

    // [...]
}

// The record class
public class TBookRecord extends UpdatableRecordImpl&lt;TBookRecord&gt; {

    // Corresponding to the Table meta-model, also setters and getters
    // deal with the generated UBookStatus
    public void setStatus(UBookStatus value) { // [...]
    public UBookStatus getStatus() {           // [...]
}</pre>

							<p>Note that jOOQ allows you to simulate ENUM types where this makes
								sense in your data model. See the section on 
								<a href="#MasterData" title="jOOQ Manual reference: Master data generation. Enumeration tables">master data</a> for more
								details. </p>
						<h1 id="SEQUENCE">
<a name="SEQUENCE"></a>2.6. Sequences</h1><p>
							jOOQ also generates convenience artefacts for sequences, where this is
							supported: DB2, Derby, H2, HSQLDB, Oracle, Postgres, and more. 
						</p>
							<h2>Sequences as a source for identity values</h2>
							<p> Sequences implement the 
							<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Sequence.java" title="Internal API reference: org.jooq.Sequence">org.jooq.Sequence</a> interface, providing essentially this functionality:</p>
							
<pre class="prettyprint lang-java">// Get a field for the CURRVAL sequence property
Field&lt;T&gt; currval();

// Get a field for the NEXTVAL sequence property
Field&lt;T&gt; nextval();</pre>		
							<p>So if you have a sequence like this in Oracle: </p>
							<pre class="prettyprint lang-sql">CREATE SEQUENCE s_author_id</pre>		
							<p>This is what jOOQ will generate: </p>	
<pre class="prettyprint lang-java">public final class Sequences {

    // A static sequence instance
    public static final Sequence&lt;BigInteger&gt; S_AUTHOR_ID = // [...]
}</pre>		

							<p>Which you can use in a select statement as such: </p>
<pre class="prettyprint lang-java">Field&lt;BigInteger&gt; s = Sequences.S_AUTHOR_ID.nextval();
BigInteger nextID   = create.select(s).fetchOne(s);</pre>

							<p>Or directly fetch currval() and nextval() from the sequence using the Factory: </p>
<pre class="prettyprint lang-java">BigInteger currval = create.currval(Sequences.S_AUTHOR_ID);
BigInteger nextval = create.nextval(Sequences.S_AUTHOR_ID);</pre>
						<h1 id="DSL">
<a name="DSL"></a>3. DSL or fluent API. Where SQL meets Java</h1><p>
					In these sections you will learn about how jOOQ makes SQL available to
					Java as if Java natively supported SQL
				</p>
					<h2>Overview</h2>
					<p>jOOQ ships with its own DSL (or 
						<a href="http://en.wikipedia.org/wiki/Domain-specific_language" title="Domain Specific Language">Domain Specific Language</a>) that
						simulates SQL as good as possible in Java. This means, that you can
						write SQL statements almost as if Java natively supported that syntax
						just like .NET's C# does with <a href="http://msdn.microsoft.com/en-us/library/bb425822.aspx">LINQ to SQL.</a>
</p>
						
					<p>Here is an example to show you what that means. When you want to write a query like this in SQL: </p>
					<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">-- Select all books by authors born after 1920, 
-- named "Paulo" from a catalogue:
SELECT * 
  FROM t_author a 
  JOIN t_book b ON a.id = b.author_id 
 WHERE a.year_of_birth &gt; 1920 
   AND a.first_name = 'Paulo'
 ORDER BY b.title</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">Result&lt;Record&gt; result = 
create.select()
      .from(T_AUTHOR.as("a"))
      .join(T_BOOK.as("b")).on(a.ID.equal(b.AUTHOR_ID))
      .where(a.YEAR_OF_BIRTH.greaterThan(1920)
      .and(a.FIRST_NAME.equal("Paulo")))
      .orderBy(b.TITLE)
      .fetch();</pre>
</td>
</tr>
</table>
					
					<p>
						You couldn't come much closer to SQL itself in Java, without re-writing the compiler.
						We'll see how the aliasing works later in the section about
						<a href="#ALIAS" title="jOOQ Manual reference: Aliased tables and fields">aliasing</a>
					
</p>
				<h1 id="SELECT">
<a name="SELECT"></a>3.1. Complete SELECT syntax</h1><p>
							A SELECT statement is more than just the R in CRUD. It allows for
							transforming your relational data into any other form using concepts
							such as equi-join, semi-join, anti-join, outer-join and much more. jOOQ
							helps you think in precisely those relational concepts.
						</p>
							<h2>SELECT from anonymous or ad-hoc types</h2>
							<p>When you don't just perform CRUD (i.e. SELECT * FROM your_table WHERE ID = ?),
							you're usually generating new types using custom projections. With jOOQ, this is
							as intuitive, as if using SQL directly. A more or less complete example of the "standard" SQL syntax, plus
							some extensions, is provided by a query like this:
							</p>
							
<pre class="prettyprint lang-sql">-- get all authors' first and last names, and the number 
-- of books they've written in German, if they have written
-- more than five books in German in the last three years 
-- (from 2011), and sort those authors by last names
-- limiting results to the second and third row, locking
-- the rows for a subsequent update... whew!

  SELECT T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, COUNT(*)
    FROM T_AUTHOR
    JOIN T_BOOK ON T_AUTHOR.ID = T_BOOK.AUTHOR_ID
   WHERE T_BOOK.LANGUAGE = 'DE'
     AND T_BOOK.PUBLISHED &gt; '2008-01-01'
GROUP BY T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME
  HAVING COUNT(*) &gt; 5
ORDER BY T_AUTHOR.LAST_NAME ASC NULLS FIRST
   LIMIT 2 
  OFFSET 1
     FOR UPDATE</pre>			
     
     						<p>So that's daily business. How to do it with jOOQ: When you first create a SELECT statement using the Factory's select() methods </p>
<pre class="prettyprint lang-java">SelectFromStep select(Field&lt;?&gt;... fields);

// Example:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count());</pre>

							<p>
								jOOQ will return an "intermediary" type to you, representing the
								SELECT statement about to be created (by the way, check out the
								section on <a href="#FUNCTIONS" title="jOOQ Manual reference: Functions and aggregate operators">aggregate operators</a>
								 to learn more about the COUNT(*)
								function). This type is the 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectFromStep.java" title="Internal API reference: org.jooq.SelectFromStep">org.jooq.SelectFromStep</a>. 
								When you have a reference
								to this type, you may add a FROM clause, although that clause is
								optional. This is reflected by the fact, that the SelectFromStep type
								extends 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectJoinStep.java" title="Internal API reference: org.jooq.SelectJoinStep">org.jooq.SelectJoinStep</a>, 
								which allows for adding the subsequent
								clauses. Let's say you do decide to add a FROM clause, then you can
								use this method for instance:
							</p>			
<pre class="prettyprint lang-java">SelectJoinStep from(TableLike&lt;?&gt;... table);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR);</pre>

							<p>After adding the table-like structures (mostly just Tables) to
								select from, you may optionally choose to add a JOIN clause, as the
								type returned by jOOQ is the step where you can add JOINs. Again,
								adding these clauses is optional, as the 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectJoinStep.java" title="Internal API reference: org.jooq.SelectJoinStep">org.jooq.SelectJoinStep</a> extends
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectWhereStep.java" title="Internal API reference: org.jooq.SelectWhereStep">org.jooq.SelectWhereStep</a>. 
								But let's say we add a JOIN: </p>
<pre class="prettyprint lang-java">// These join types are supported
SelectOnStep                    join(Table&lt;?&gt; table);
SelectOnStep           leftOuterJoin(Table&lt;?&gt; table);
SelectOnStep          rightOuterJoin(Table&lt;?&gt; table);
SelectOnStep           fullOuterJoin(Table&lt;?&gt; table);
SelectJoinStep             crossJoin(Table&lt;?&gt; table);
SelectJoinStep           naturalJoin(Table&lt;?&gt; table);
SelectJoinStep  naturalLeftOuterJoin(Table&lt;?&gt; table);
SelectJoinStep naturalRightOuterJoin(Table&lt;?&gt; table);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK);</pre>

							<p>Now, if you do add a JOIN clause, you have to specify the JOIN .. ON
								condition before you can add more clauses. That's not an optional step
								for some JOIN types. This is reflected by the fact that 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectOnStep.java" title="Internal API reference: org.jooq.SelectOnStep">org.jooq.SelectOnStep</a>
								is a top-level interface. </p>
								
<pre class="prettyprint lang-java">// These join conditions are supported
SelectJoinStep    on(Condition... conditions);
SelectJoinStep using(Field&lt;?&gt;... fields);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID));</pre>

							<p>See the section about 
								<a href="#CONDITION" title="jOOQ Manual reference: Conditions">Conditions</a> 
								to learn more about the many ways
								to create Conditions in jOOQ. Now we're half way through. As you can
								see above, we're back to the SelectJoinStep. This means, we can
								re-iterate and add another JOIN clause, just like in SQL. Or we go on
								to the next step, adding conditions in the 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectWhereStep.java" title="Internal API reference: org.jooq.SelectWhereStep">org.jooq.SelectWhereStep</a>: </p>
<pre class="prettyprint lang-java">SelectConditionStep where(Condition... conditions);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"));</pre>

							<p>Now the returned type 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectConditionStep.java" title="Internal API reference: org.jooq.SelectConditionStep">org.jooq.SelectConditionStep</a> is a special one, where
								you can add more conditions to the already existing WHERE clause.
								Every time you add a condition, you will return to that
								SelectConditionStep, as the number of additional conditions is
								unlimited. Note that of course you can also just add a single combined
								condition, if that is more readable or suitable for your use-case.
								Here's how we add another condition: </p>
<pre class="prettyprint lang-java">SelectConditionStep and(Condition condition);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')));</pre>

							<p>Let's assume we have that method parseDate() creating a
								<a href="http://download.oracle.com/javase/6/docs/api/java/sql/Date.html" title="External API reference: java.sql.Date">java.sql.Date</a> for us. 
								Then we'll continue adding the GROUP BY clause
							</p>
<pre class="prettyprint lang-java">SelectHavingStep groupBy(Field&lt;?&gt;... fields);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME);</pre>
      
      						<p>and the HAVING clause: </p>
<pre class="prettyprint lang-java">SelectOrderByStep having(Condition... conditions);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5));</pre>

							<p>and the ORDER BY clause. Some RDBMS support NULLS FIRST and NULLS
								LAST extensions to the ORDER BY clause. If this is not supported by
								the RDBMS, then the behaviour is simulated with an additional CASE
								WHEN ... IS NULL THEN 1 ELSE 0 END clause. </p>
<pre class="prettyprint lang-java">SelectLimitStep orderBy(Field&lt;?&gt;... fields);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(T_AUTHOR.LAST_NAME.asc().nullsFirst());</pre>

							<p>and finally the LIMIT clause. Most dialects have a means of limiting
								the number of result records (except Oracle). Some even support having
								an OFFSET to the LIMIT clause. Even if your RDBMS does not support the
								full LIMIT ... OFFSET ... (or TOP ... START AT ..., or FETCH FIRST ... ROWS ONLY, etc) 
								clause, jOOQ will simulate the LIMIT clause using nested selects and filtering on
								ROWNUM (for Oracle), or on ROW_NUMBER() (for DB2 and SQL
								Server): </p>
<pre class="prettyprint lang-java">SelectFinalStep limit(int offset, int numberOfRows);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(T_AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(1, 2);</pre>

							<p>In the final step, there are some proprietary extensions available
								only in some RDBMS. One of those extensions are the FOR UPDATE
								(supported in most RDBMS) and FOR SHARE clauses (supported only in
								MySQL and Postgres): </p>
<pre class="prettyprint lang-java">SelectFinalStep forUpdate();

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(T_AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(1, 2)
      .forUpdate();</pre>

							<p>
								Now the most relevant super-type of the object we have just created is 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java" title="Internal API reference: org.jooq.Select">org.jooq.Select</a>. 
								This type can be reused in various expressions such as in the
								<a href="#UNION" title="jOOQ Manual reference: UNION and other set operations">UNION and other set operations</a>, 
								<a href="#EXISTS" title="jOOQ Manual reference: Nested SELECT using the EXISTS operator">Nested select statements using the EXISTS operator</a>, 
								etc. If you just want to execute this select
								statement, you can choose any of these methods as discussed in the 
								section about the <a href="#ResultQuery" title="jOOQ Manual reference: ResultQuery and various ways of fetching data">ResultQuery</a>:
							</p>
							
<pre class="prettyprint lang-java">// Just execute the query.
int execute();

// Execute the query and retrieve the results
Result&lt;Record&gt; fetch();

// Execute the query and retrieve the first Record
Record fetchAny();

// Execute the query and retrieve the single Record
// An Exception is thrown if more records were available
Record fetchOne();

// [...]</pre>


							<h2>SELECT from single physical tables</h2>
							<p>A very similar, but limited API is available, if you want to select from single
								physical tables in order to retrieve TableRecords or even
								UpdatableRecords (see also the manual's section on 
								<a href="#Query" title="jOOQ Manual reference: The Query and its various subtypes">SelectQuery vs SimpleSelectQuery</a>). 
								The decision, which type of select to create is
								already made at the very first step, when you create the SELECT
								statement with the Factory: </p>
								
							<pre class="prettyprint lang-java">public &lt;R extends Record&gt; SimpleSelectWhereStep&lt;R&gt; selectFrom(Table&lt;R&gt; table);</pre>
							<p>As you can see, there is no way to further restrict/project the selected
								fields. This just selects all known TableFields in the supplied Table,
								and it also binds &lt;R extends Record&gt; to your Table's associated
								Record. An example of such a Query would then be: </p>
<pre class="prettyprint lang-java">TBook book = create.selectFrom(T_BOOK)
                   .where(TBook.LANGUAGE.equal("DE"))
                   .orderBy(TBook.TITLE)
                   .fetchAny();</pre>
						<h1 id="CONDITION">
<a name="CONDITION"></a>3.2. Conditions</h1><p>
							The creation of conditions is the part of any database abstraction that
							attracts the most attention.
						</p>
							<h2>Conditions are the SELECT's core business</h2>
							<p>In your average application, you will typically have 3-4 SQL queries
								that have quite a long list of predicates (and possibly JOINs), such
								that you start to lose track over the overall boolean expression that
								you're trying to apply.</p>
							<p>In jOOQ, most Conditions can be created and combined almost as
								easily as in SQL itself. The two main participants for creating
								Conditions are the <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Field.java" title="Internal API reference: org.jooq.Field">Field</a>, 
								which is typically a participant of a
								condition, and the <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Condition.java" title="Internal API reference: org.jooq.Condition">Condition</a> 
								itself: </p>
<pre class="prettyprint lang-java">public interface Condition {
    Condition and(Condition other);
    Condition and(String sql);
    Condition and(String sql, Object... bindings);
    Condition andNot(Condition other);
    Condition andExists(Select&lt;?&gt; select);
    Condition andNotExists(Select&lt;?&gt; select);
    Condition or(Condition other);
    Condition or(String sql);
    Condition or(String sql, Object... bindings);
    Condition orNot(Condition other);
    Condition orExists(Select&lt;?&gt; select);
    Condition orNotExists(Select&lt;?&gt; select);
    Condition not();
}</pre>

							<p>The above example describes the essence of boolean logic in jOOQ. As
								soon as you have a Condition object, you can connect that to other
								Conditions, which will then give you a combined condition with exactly
								the same properties. There are also convenience methods to create an
								EXISTS clause and connect it to an existing condition. In order to
								create a new Condition you are going to depart from a Field in most
								cases. Here are some important API elements in the Field interface:
							</p>
							
<pre class="prettyprint lang-java">public interface Field&lt;T&gt; {
    Condition isNull();
    Condition isNotNull();
    Condition like(T value);
    Condition notLike(T value);
    Condition in(T... values);
    Condition in(Select&lt;?&gt; query);
    Condition notIn(Collection&lt;T&gt; values);
    Condition notIn(T... values);
    Condition notIn(Select&lt;?&gt; query);
    Condition in(Collection&lt;T&gt; values);
    Condition between(T minValue, T maxValue);
    Condition equal(T value);
    Condition equal(Field&lt;T&gt; field);
    Condition equal(Select&lt;?&gt; query);
    Condition equalAny(Select&lt;?&gt; query);
    Condition equalSome(Select&lt;?&gt; query);
    Condition equalAll(Select&lt;?&gt; query);
    Condition notEqual(T value);
    Condition notEqual(Field&lt;T&gt; field);
    Condition notEqual(Select&lt;?&gt; query);
    Condition notEqualAny(Select&lt;?&gt; query);
    Condition notEqualSome(Select&lt;?&gt; query);
    Condition notEqualAll(Select&lt;?&gt; query);
    Condition lessThan(T value);
    Condition lessOrEqual(T value);
    Condition greaterThan(T value);
    Condition greaterOrEqual(T value);
}</pre>

							<p>As you see in the partially displayed API above, you can compare a
								Field either with other Fields, with constant values (which is a
								shortcut for calling Factory.val(T value)), or with a nested SELECT
								statement. See some more 
								<a href="#NESTED" title="jOOQ Manual reference: Other types of nested SELECT">Examples of nested SELECTs</a>. </p>
							<p>Combining the API of Field and Condition you can express complex predicates like this: </p>
							
<pre class="prettyprint lang-sql">(T_BOOK.TYPE_CODE IN (1, 2, 5, 8, 13, 21)       AND T_BOOK.LANGUAGE = 'DE') OR
(T_BOOK.TYPE_CODE IN (2, 3, 5, 7, 11, 13)       AND T_BOOK.LANGUAGE = 'FR') OR
(T_BOOK.TYPE_CODE IN (SELECT CODE FROM T_TYPES) AND T_BOOK.LANGUAGE = 'EN')</pre>

							<p>Just write: </p>
<pre class="prettyprint lang-java">T_BOOK.TYPE_CODE.in(1, 2, 5, 8, 13, 21)                       .and(T_BOOK.LANGUAGE.equal("DE")).or(
T_BOOK.TYPE_CODE.in(2, 3, 5, 7, 11, 13)                       .and(T_BOOK.LANGUAGE.equal("FR")).or(
T_BOOK.TYPE_CODE.in(create.select(T_TYPES.CODE).from(T_TYPES)).and(T_BOOK.LANGUAGE.equal("EN"))));</pre>
						<h1 id="ALIAS">
<a name="ALIAS"></a>3.3. Aliased tables and fields</h1><p>
							Aliasing is at the core of SQL and relational algebra. When you join
							the same entity multiple times, you can rename it to distinguish the
							various meanings of the same entity
						</p>
							<h2>Aliasing Tables</h2>
							<p>A typical example of what you might want to do in SQL is this: </p>
<pre class="prettyprint lang-sql">SELECT a.ID, b.ID
  FROM T_AUTHOR a
  JOIN T_BOOK b on a.ID = b.AUTHOR_ID</pre>
  
  							<p>
  								In this example, we are aliasing Tables, calling them a and b.
  								The way aliasing works depends on how you generate your meta model
  								using jooq-codegen (see the manual's section about 
  								<a href="#TABLE" title="jOOQ Manual reference: Tables, views and their corresponding records">generating tables</a>). Things become
  								simpler when you choose the instance/dynamic model, instead of the
  								static one.
  								Here is how you can create Table aliases in jOOQ: 
  							</p>
  							
<pre class="prettyprint lang-java">Table&lt;TBookRecord&gt; book = T_BOOK.as("b");
Table&lt;TAuthorRecord&gt; author = T_AUTHOR.as("a");

// If you choose not to generate a static meta model, this becomes even better
TBook book = T_BOOK.as("b");
TAuthor author = T_AUTHOR.as("a");</pre>

							<p>Now, if you want to reference any fields from those Tables, you may
								not use the original T_BOOK or T_AUTHOR meta-model objects anymore.
								Instead, you have to get the fields from the new book and author Table
								aliases: </p>
								
<pre class="prettyprint lang-java">Field&lt;Integer&gt; bookID = book.getField(TBook.ID);
Field&lt;Integer&gt; authorID = author.getField(TAuthor.ID);

// Or with the instance field model:
Field&lt;Integer&gt; bookID = book.ID;
Field&lt;Integer&gt; authorID = author.ID;</pre>

							<p>
								So this is how the above SQL statement would read in jOOQ:
							</p>
<pre class="prettyprint lang-java">create.select(authorID, bookID)
      .from(author)
      .join(book).on(authorID.equal(book.getField(T_BOOK.AUTHOR_ID)));
      
// Or with the instance field model:
create.select(author.ID, book.ID)
      .from(author)
      .join(book).on(author.ID.equal(book.AUTHOR_ID))</pre>
      
      
      						<h3>Aliasing nested selects as tables</h3>
							<p>There is an interesting, more advanced example of how you can select
								from an aliased nested select in the manual's section about 
								<a href="#NESTED" title="jOOQ Manual reference: Other types of nested SELECT">nested selects</a>
</p>
								
								
							<h2>Aliasing fields</h2>
							<p>Fields can also be aliased independently from Tables. Most often,
								this is done when using functions or aggregate operators. Here is an
								example: </p>
<pre class="prettyprint lang-sql">  SELECT FIRST_NAME || ' ' || LAST_NAME author, COUNT(*) books
    FROM T_AUTHOR
    JOIN T_BOOK ON T_AUTHOR.ID = AUTHOR_ID
GROUP BY FIRST_NAME, LAST_NAME;</pre>
							<p>Here is how it's done with jOOQ: </p>
<pre class="prettyprint lang-java">Record record = create.select(
         concat(T_AUTHOR.FIRST_NAME, " ", T_AUTHOR.LAST_NAME).as("author"),
         count().as("books"))
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_AUTHOR.ID.equal(T_BOOK.AUTHOR_ID))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME).fetchAny();</pre>
      						<p>When you alias Fields like above, you can access those Fields' values using the alias name: </p>
<pre class="prettyprint lang-java">System.out.println("Author : " + record.getValue("author"));
System.out.println("Books  : " + record.getValue("books"));</pre>
						<h1 id="IN">
<a name="IN"></a>3.4. Nested SELECT using the IN operator</h1><p>
							Set equal operations are very common when you want to select multiple
							records. The IN operator can also be used for semi-joins, though
						</p>
							<h2>The IN operator for use in semi-joins or anti-joins</h2>
							<p>
								In addition to a list of constant values, the IN operator in 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Field.java" title="Internal API reference: org.jooq.Field">org.jooq.Field</a> 
								also supports a 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java" title="Internal API reference: org.jooq.Select">org.jooq.Select</a> as an argument. 
								This can be any type of select as
								discussed in the manual's section about 
								<a href="#Query" title="jOOQ Manual reference: The Query and its various subtypes">Query types</a>. 
								However, you must
								ensure yourself, that the provided Select will only select a single
								Field.
							</p>
							<p>Let's say you want to select books by authors born in 1920. Of
								course, this is possible with a plain JOIN as well, but let's say we
								want to use the IN operator. Then you have two possibilities: </p>
								
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT *
  FROM T_BOOK
 WHERE T_BOOK.AUTHOR_ID IN (
           SELECT ID FROM T_AUTHOR
            WHERE T_AUTHOR.BORN = 1920)

-- OR:

SELECT T_BOOK.*
  FROM T_BOOK
  JOIN T_AUTHOR ON (T_BOOK.AUTHOR_ID = T_AUTHOR.ID
                AND T_AUTHOR.BORN    = 1920)</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.select()
      .from(T_BOOK)
      .where(T_BOOK.AUTHOR_ID.in(
          create.select(T_AUTHOR.ID).from(T_AUTHOR)
                .where(T_AUTHOR.BORN.equal(1920))));

// OR:

create.select(T_BOOK.getFields())
      .from(T_BOOK)
      .join(T_AUTHOR).on(T_BOOK.AUTHOR_ID.equal(TAuthor.ID)
                     .and(T_AUTHOR.BORN.equal(1920)));</pre>
</td>
</tr>
</table>						
						<h1 id="EXISTS">
<a name="EXISTS"></a>3.5. Nested SELECT using the EXISTS operator</h1><p>The EXISTS operator is a bit different from all other SQL
							elements, as it cannot really be applied to any object in a DSL.
						</p>
							<h2>The EXISTS operator for use in semi-joins or anti-joins</h2>
							<p>The EXISTS operator is rather independent and can stand any place
								where there may be a new condition: </p>
							<ul>
								
<li>It may be placed right after a WHERE keyword </li>
								
<li>It may be the right-hand-side of a boolean operator</li>
								
<li>It may be placed right after a ON or HAVING keyword (although, this is less likely to be done...) </li>
							
</ul>

							<p>This is reflected by the fact that an EXISTS clause is usually
								created directly from the Factory: </p>
								
<pre class="prettyprint lang-java">Condition exists(Select&lt;?&gt; query);
Condition notExists(Select&lt;?&gt; query);</pre>

							<p>When you create such a Condition, it can then be connected to any
								other condition using AND, OR operators (see also the manual's section
								on 
								<a href="#CONDITION" title="jOOQ Manual reference: Conditions">Conditions</a>). There are also quite a few
								convenience methods, where they might be useful. For instance in the
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Condition.java" title="Internal API reference: org.jooq.Condition">org.jooq.Condition</a> itself: </p>
								
<pre class="prettyprint lang-java">Condition andExists(Select&lt;?&gt; select);
Condition andNotExists(Select&lt;?&gt; select);
Condition orExists(Select&lt;?&gt; select);
Condition orNotExists(Select&lt;?&gt; select);</pre>

							<p>Or in the <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectWhereStep.java" title="Internal API reference: org.jooq.SelectWhereStep">org.jooq.SelectWhereStep</a>:</p>
							
<pre class="prettyprint lang-java">SelectConditionStep whereExists(Select&lt;?&gt; select);
SelectConditionStep whereNotExists(Select&lt;?&gt; select);</pre>

							<p>Or in the <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SelectConditionStep.java" title="Internal API reference: org.jooq.SelectConditionStep">org.jooq.SelectConditionStep</a>: </p>
							
<pre class="prettyprint lang-java">SelectConditionStep andExists(Select&lt;?&gt; select);
SelectConditionStep andNotExists(Select&lt;?&gt; select);
SelectConditionStep orExists(Select&lt;?&gt; select);
SelectConditionStep orNotExists(Select&lt;?&gt; select);</pre>

							<p>An example of how to use it is quickly given. Get all authors that haven't written any books: </p>
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT *
  FROM T_AUTHOR
 WHERE NOT EXISTS (SELECT 1 
                     FROM T_BOOK 
                    WHERE T_BOOK.AUTHOR_ID = T_AUTHOR.ID)</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.select()
      .from(T_AUTHOR)
      .whereNotExists(create.selectOne()
            .from(T_BOOK)
            .where(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID)));</pre>
</td>
</tr>
</table>
						<h1 id="NESTED">
<a name="NESTED"></a>3.6. Other types of nested SELECT</h1><p>Apart from the most common IN and EXISTS clauses that encourage
							the use of nested selects, SQL knows a few more syntaxes to make use
							of such constructs. </p>
							<h2>Comparison with single-field SELECT clause</h2>
							<p>If you can ensure that a nested SELECT will only return one Record
								with one Field, then you can test for equality. This is how it is done
								in SQL: </p>
								
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT * 
  FROM T_BOOK
 WHERE T_BOOK.AUTHOR_ID = (
 		SELECT ID 
          FROM T_AUTHOR 
         WHERE LAST_NAME = 'Orwell')</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.select()
      .from(T_BOOK)
      .where(T_BOOK.AUTHOR_ID.equal(create
             .select(T_AUTHOR.ID)
             .from(T_AUTHOR)
             .where(T_AUTHOR.LAST_NAME.equal("Orwell"))));</pre>
</td>
</tr>
</table>
                            
                            <p>More examples like the above can be guessed from the 
                            <a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Field.java" title="Internal API reference: org.jooq.Field">org.jooq.Field</a> API, as documented in the manual's section about 
                            <a href="#CONDITION" title="jOOQ Manual reference: Conditions">Conditions</a>. For the = operator, the available comparisons are these:</p>
                            
<pre class="prettyprint lang-java">Condition equal(Select&lt;?&gt; query);
Condition equalAny(Select&lt;?&gt; query);
Condition equalSome(Select&lt;?&gt; query);
Condition equalAll(Select&lt;?&gt; query);</pre>
                            
                            
                            <h2>Selecting from a SELECT - SELECT acts as a Table</h2>
							<p>Often, you need to nest a SELECT statement simply because SQL is
								limited in power. For instance, if you want to find out which author
								has written the most books, then you cannot do this: </p>
								
<pre class="prettyprint lang-sql">  SELECT AUTHOR_ID, count(*) books
    FROM T_BOOK
GROUP BY AUTHOR_ID
ORDER BY books DESC</pre>

							<p>Instead, you have to do this (or something similar). For jOOQ, this
								is an excellent example, combining various SQL features into a single
								statement. Here's how to do it: </p>
								
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT nested.* FROM (
      SELECT AUTHOR_ID, count(*) books
        FROM T_BOOK
    GROUP BY AUTHOR_ID
) nested
ORDER BY nested.books DESC


</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">Table&lt;Record&gt; nested = 
    create.select(T_BOOK.AUTHOR_ID, count().as("books"))
          .from(T_BOOK)
          .groupBy(T_BOOK.AUTHOR_ID).asTable("nested");

create.select(nested.getFields())
      .from(nested)
      .orderBy(nested.getField("books"));</pre>
</td>
</tr>
</table>
							
							<p>You'll notice how some verbosity seems inevitable when you combine nested SELECT statements with aliasing. </p>
                    	
	                    	<h2>Selecting a SELECT - SELECT acts as a Field</h2>
							<p>Now SQL is even more powerful than that. You can also have SELECT
								statements, wherever you can have Fields. It get's harder and harder
								to find good examples, because there is always an easier way to
								express the same thing. But why not just count the number of books the
								really hard way? :-) But then again, maybe you want to take advantage
								of <a href="http://lukaseder.wordpress.com/2011/09/02/oracle-scalar-subquery-caching/" title="Oracle Scalar Subquery Caching with jOOQ">Oracle Scalar Subquery Caching</a>
</p>
							
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">  SELECT LAST_NAME, (
      SELECT COUNT(*) 
       FROM T_BOOK 
      WHERE T_BOOK.AUTHOR_ID = T_AUTHOR.ID) books
    FROM T_AUTHOR
ORDER BY books DESC



</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">// The type of books cannot be inferred from the Select&lt;?&gt;
Field&lt;Object&gt; books = 
    create.selectCount()
          .from(T_BOOK)
          .where(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
          .asField("books");
create.select(T_AUTHOR.ID, books)
      .from(T_AUTHOR)
      .orderBy(books, T_AUTHOR.ID));</pre>
</td>
</tr>
</table>
                    	<h1 id="UNION">
<a name="UNION"></a>3.7. UNION and other set operations</h1><p>Unions, differences and intersections are vital set operations taken from set theory.</p>
							<h2>jOOQ's set operation API</h2>
							<p>The 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/Select.java" title="Internal API reference: org.jooq.Select">org.jooq.Select</a> API directly supports the UNION 
								syntax for all types of Select as discussed in the manual's section about 
								<a href="#Query" title="jOOQ Manual reference: The Query and its various subtypes">Queries and Query subtypes</a>. 
								It consists of these methods: </p>
								
<pre class="prettyprint lang-java">public interface Select&lt;R extends Record&gt; {
    Select&lt;R&gt; union(Select&lt;R&gt; select);
    Select&lt;R&gt; unionAll(Select&lt;R&gt; select);
    Select&lt;R&gt; except(Select&lt;R&gt; select);
    Select&lt;R&gt; intersect(Select&lt;R&gt; select);
}</pre>

							<p>Hence, this is how you can write a simple UNION with jOOQ:</p>
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT TITLE 
  FROM T_BOOK 
 WHERE PUBLISHED_IN &gt; 1945
UNION
SELECT TITLE 
  FROM T_BOOK 
 WHERE AUTHOR_ID = 1</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.select(TBook.TITLE)
      .from(T_BOOK)
      .where(T_BOOK.PUBLISHED_IN.greaterThan(1945))
      .union(
create.select(T_BOOK.TITLE)
      .from(T_BOOK)
      .where(T_BOOK.AUTHOR_ID.equal(1)));</pre>
</td>
</tr>
</table>
							
							<h2>Nested UNIONs</h2>
							<p>In some SQL dialects, you can arbitrarily nest UNIONs to several
								levels. Be aware, though, that SQLite, Derby and MySQL have serious
								syntax limitations. jOOQ tries to render correct UNION SQL statements,
								but unfortunately, you can create situations that will cause syntax
								errors in the aforementioned dialects. </p>
								
							<p>An example of advanced UNION usage is the following statement in jOOQ: </p>
<pre class="prettyprint lang-java">// Create a UNION of several types of books
Select&lt;?&gt; union = 
    create.select(T_BOOK.TITLE, T_BOOK.AUTHOR_ID).from(T_BOOK).where(T_BOOK.PUBLISHED_IN.greaterThan(1945)).union(
    create.select(T_BOOK.TITLE, T_BOOK.AUTHOR_ID).from(T_BOOK).where(T_BOOK.AUTHOR_ID.equal(1)));

// Now, re-use the above UNION and order it by author
create.select(union.getField(T_BOOK.TITLE))
      .from(union)
      .orderBy(union.getField(T_BOOK.AUTHOR_ID).descending());</pre>

							<p>This example does not seem surprising, when you have read the
								previous chapters about 
								<a href="#NESTED" title="jOOQ Manual reference: Other types of nested SELECT">nested SELECT statements</a>. 
								But when you check
								out the rendered SQL: </p>
								
<pre class="prettyprint lang-sql">-- alias_38173 is an example of a generated alias, 
-- generated by jOOQ for union queries
SELECT alias_38173.TITLE FROM (
  SELECT T_BOOK.TITLE, T_BOOK.AUTHOR_ID FROM T_BOOK WHERE T_BOOK.PUBLISHED_IN &gt; 1945
  UNION
  SELECT T_BOOK.TITLE, T_BOOK.AUTHOR_ID FROM T_BOOK WHERE T_BOOK.AUTHOR_ID = 1
) alias_38173
ORDER BY alias_38173.AUTHOR_ID DESC</pre>

							<p>You can see that jOOQ takes care of many syntax pitfalls, when
								you're not used to the various dialects' unique requirements. The
								above automatic aliasing was added in order to be compliant with
								MySQL's requirements about aliasing nested selects. </p>
								
							<h2>Several UNIONs</h2>
							<p>It is no problem either for you to create SQL statements with several unions. Just write: </p>
<pre class="prettyprint lang-java">Select&lt;?&gt; part1;
Select&lt;?&gt; part2;
Select&lt;?&gt; part3;
Select&lt;?&gt; part4;

// [...]

part1.union(part2).union(part3).union(part4);</pre>

							<h2>UNION and the ORDER BY clause</h2>
							<p>
								Strictly speaking, in SQL, you cannot order a subselect that is part
								of a UNION operation. You can only order the whole set. In set theory,
								or relational algebra, it wouldn't make sense to order subselects
								anyway, as a set operation cannot guarantee order correctness. Often,
								you still want to do it, because you apply a LIMIT to every subselect.
								Let's say, you want to find the employees with the highest salary in
								every department in Postgres syntax:
							</p>
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT * FROM (
  SELECT * FROM emp WHERE dept = 'IT' 
  ORDER BY salary LIMIT 1
) UNION (
  SELECT * FROM emp WHERE dept = 'Marketing'
  ORDER BY salary LIMIT 1
) UNION (
  SELECT * FROM emp WHERE dept = 'R&amp;D'
  ORDER BY salary LIMIT 1
)</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.selectFrom(EMP).where(DEPT.equal("IT"))
      .orderBy(SALARY).limit(1)
      .union(
create.selectFrom(EMP).where(DEPT.equal("Marketing"))
      .orderBy(SALARY).limit(1))
      .union(
create.selectFrom(EMP).where(DEPT.equal("R&amp;D")
      .orderBy(SALARY).limit(1)))
      
      
</pre>
</td>
</tr>
</table>
							
							<p>There is a subtle difference between the above two queries. 
								In SQL, every UNION subselect is in fact a 
							<a href="#NESTED" title="jOOQ Manual reference: Other types of nested SELECT">nested SELECT</a>, wrapped in parentheses.
							In this example, the notion of "nested SELECT" and "subselect" are slightly
							different.</p>
						<h1 id="FUNCTIONS">
<a name="FUNCTIONS"></a>3.8. Functions and aggregate operators</h1><p>
							Highly effective SQL cannot do without functions. Operations on
							VARCHAR, DATE, and NUMERIC types in GROUP BY or ORDER BY clauses allow
							for very elegant queries.
						</p>
							<h2>jOOQ's strategy for supporting vendor-specific functions</h2>
							<p>jOOQ allows you to access native functions from your RDBMS. jOOQ
								follows two strategies: </p>
							<ul>
								
<li>Implement all SQL-92, SQL:1999, SQL:2003, and SQL:2008 standard
									functions, aggregate operators, and window functions. Standard
									functions could be 
									<a href="http://oreilly.com/catalog/sqlnut/chapter/ch04.html" title="O'Reilly listing of SQL-92 standard functions and deviations thereof">these functions as listed by O'Reilly</a>. </li>
								
<li>Take the most useful of vendor-specific functions and simulate
									them for other RDBMS, where they may not be supported. An example for
									this are 
									<a href="http://psoug.org/reference/analytic_functions.html" title="An example listing of Oracle Analytic Functions">Oracle Analytic Functions</a>
</li>
							
</ul>
							
							<h2>Functions </h2>
							<p>These are just a few functions in the Factory, so you get the idea: </p>
							
<pre class="prettyprint lang-java">Field&lt;String&gt; rpad(Field&lt;String&gt; field, Field&lt;? extends Number&gt; length);
Field&lt;String&gt; rpad(Field&lt;String&gt; field, int length);
Field&lt;String&gt; rpad(Field&lt;String&gt; field, Field&lt;? extends Number&gt; length, Field&lt;String&gt; c);
Field&lt;String&gt; rpad(Field&lt;String&gt; field, int length, char c);
Field&lt;String&gt; lpad(Field&lt;String&gt; field, Field&lt;? extends Number&gt; length);
Field&lt;String&gt; lpad(Field&lt;String&gt; field, int length);
Field&lt;String&gt; lpad(Field&lt;String&gt; field, Field&lt;? extends Number&gt; length, Field&lt;String&gt; c);
Field&lt;String&gt; lpad(Field&lt;String&gt; field, int length, char c);
Field&lt;String&gt; replace(Field&lt;String&gt; field, Field&lt;String&gt; search);
Field&lt;String&gt; replace(Field&lt;String&gt; field, String search);
Field&lt;String&gt; replace(Field&lt;String&gt; field, Field&lt;String&gt; search, Field&lt;String&gt; replace);
Field&lt;String&gt; replace(Field&lt;String&gt; field, String search, String replace);
Field&lt;Integer&gt; position(Field&lt;String&gt; field, String search);
Field&lt;Integer&gt; position(Field&lt;String&gt; field, Field&lt;String&gt; search);</pre>

							<h2>Aggregate operators</h2>
							<p>Aggregate operators work just like functions, even if they have a
								slightly different semantics. Here are some examples from
								Factory: </p>
								
<pre class="prettyprint lang-java">// Every-day functions
AggregateFunction&lt;Integer&gt; count(Field&lt;?&gt; field);
AggregateFunction&lt;Integer&gt; countDistinct(Field&lt;?&gt; field);
AggregateFunction&lt;T&gt; max(Field&lt;?&gt; field);
AggregateFunction&lt;T&gt; min(Field&lt;?&gt; field);
AggregateFunction&lt;BigDecimal&gt; sum(Field&lt;? extends Number&gt; field);
AggregateFunction&lt;BigDecimal&gt; avg(Field&lt;? extends Number&gt; field);

// Statistical functions
AggregateFunction&lt;BigDecimal&gt; median(Field&lt;? extends Number&gt; field);
AggregateFunction&lt;BigDecimal&gt; stddevPop(Field&lt;? extends Number&gt; field);
AggregateFunction&lt;BigDecimal&gt; stddevSamp(Field&lt;? extends Number&gt; field);
AggregateFunction&lt;BigDecimal&gt; varPop(Field&lt;? extends Number&gt; field);
AggregateFunction&lt;BigDecimal&gt; varSamp(Field&lt;? extends Number&gt; field);
</pre>

							<p>A typical example of how to use an aggregate operator is when
								generating the next key on insertion of an ID. When you want to
								achieve something like this </p>
								
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT MAX(ID) + 1 AS next_id 
  FROM T_AUTHOR</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.select(max(ID).add(1).as("next_id"))
      .from(T_AUTHOR);</pre>
</td>
</tr>
</table>
							
							<p>See also the section about 
								<a href="#ARITHMETIC" title="jOOQ Manual reference: Arithmetic operations and concatenation">Arithmetic operations</a>
</p>
								
							<h2>Window functions</h2>
							<p>Most major RDBMS support the concept of window functions. jOOQ knows
								of implementations in DB2, Oracle, Postgres, SQL Server, and Sybase
								SQL Anywhere,
								and supports most of their specific syntaxes. Window functions can be
								used for things like calculating a "running total". The following example
								fetches transactions and the running total for every transaction going
								back to the beginning of the transaction table (ordered by booked_at).
								
								They are accessible from the previously seen AggregateFunction type using
								the over() method:
							</p>
							
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT booked_at, amount,
   SUM(amount) OVER (PARTITION BY 1
                     ORDER BY booked_at
                     ROWS BETWEEN UNBOUNDED PRECEDING 
                     AND CURRENT ROW) AS total
  FROM transactions</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.select(t.BOOKED_AT, t.AMOUNT, 
         sum(t.AMOUNT).over().partitionByOne()
                      .orderBy(t.BOOKED_AT)
                      .rowsBetweenUnboundedPreceding()
                      .andCurrentRow().as("total")
      .from(TRANSACTIONS.as("t"));</pre>
</td>
</tr>
</table>
						<h1 id="PROCEDURES">
<a name="PROCEDURES"></a>3.9. Stored procedures and functions</h1><p>
							The full power of your database's vendor-specific extensions can hardly
							be obtained outside of the
							database itself. Most modern RDBMS support
							their own procedural language. With jOOQ, stored procedures are
							integrated easily
						</p>
							<h2>Interaction with stored procedures</h2>
							<p>The main way to interact with your RDBMS's stored procedures and
								functions is by using the generated artefacts. See the manual's
								section about 
								<a href="#PROCEDURE" title="jOOQ Manual reference: Procedures and packages">generating procedures and packages</a>
							    for more details
								about the source code generation for stored procedures and functions.
							</p>
							
							<h2>Stored functions</h2>
							<p>When it comes to DSL, stored functions can be very handy in SQL
								statements as well. Every stored function (this also applies to
								FUNCTIONS in Oracle PACKAGES) can generate a Field representing a call
								to that function. Typically, if you have this type of function in your
								database: </p>
								
<pre class="prettyprint lang-sql">CREATE OR REPLACE FUNCTION f_author_exists (author_name VARCHAR2)
RETURN NUMBER;</pre>

							<p>Then convenience methods like these are generated: </p>
<pre class="prettyprint lang-java">// Create a field representing a function with another field as parameter
public static Field&lt;BigDecimal&gt; fAuthorExists(Field&lt;String&gt; authorName) { // [...]

// Create a field representing a function with a constant parameter
public static Field&lt;BigDecimal&gt; fAuthorExists(String authorName) { // [...]</pre>

							<p>Let's say, you have a T_PERSON table with persons' names in it, and
								you want to know whether there exists an author with precisely that
								name, you can reuse the above stored function in a SQL query: </p>
								
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT T_PERSON.NAME, F_AUTHOR_EXISTS(T_PERSON.NAME)
  FROM T_PERSON

-- OR:

SELECT T_PERSON.NAME
  FROM T_PERSON
 WHERE F_AUTHOR_EXISTS(T_PERSON.NAME) = 1</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.select(T_PERSON.NAME, Functions.fAuthorExists(T_PERSON.NAME))
      .from(T_PERSON);

// OR: Note, the static import of Functions.*
create.select(T_PERSON.NAME)
      .from(T_PERSON)
      .where(fAuthorExists(T_PERSON.NAME));</pre>
</td>
</tr>
</table>
							
							<h2>Stored procedures</h2>
							<p>The notion of a stored procedure is implemented in most RDBMS by the
								fact, that the procedure has no RETURN VALUE (like void in Java), but
								it may well have OUT parameters. Since there is not a standard way how
								to embed stored procedures in SQL, they cannot be integrated in jOOQ's
								DSL either. </p>
						<h1 id="ARITHMETIC">
<a name="ARITHMETIC"></a>3.10. Arithmetic operations and concatenation</h1><p>
							Your database can do the math for you. Most arithmetic operations are
							supported, but also string concatenation can be very efficient if done
							already in the database.
						</p>
							<h2>Mathematical operations</h2>
							<p>Arithmetic operations are implemented just like 
								<a href="#FUNCTIONS" title="jOOQ Manual reference: Functions and aggregate operators">functions</a>, with
								similar limitations as far as type restrictions are concerned. You can
								use any of these operators: </p>
								
							<pre class="prettyprint">  +  -  *  /  %</pre>
							
							<p>In order to express a SQL query like this one: </p>
							<pre class="prettyprint lang-sql">SELECT ((1 + 2) * (5 - 3) / 2) % 10 FROM DUAL</pre>
							<p>You can write something like this in jOOQ: </p>
							<pre class="prettyprint lang-java">create.select(create.val(1).add(2).mul(create.val(5).sub(3)).div(2).mod(10));	</pre>
							
							<h2>Datetime arithmetic</h2>
							<p>jOOQ also supports the Oracle-style syntax for adding days to a Field&lt;? extends java.util.Date&gt; </p>
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT SYSDATE + 3 FROM DUAL;</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.select(create.currentTimestamp().add(3));</pre>
</td>
</tr>
</table>
							
							<h2>String concatenation</h2>
							<p>This is not really an arithmetic expression, but it's still an
								expression with operators: The string concatenation. jOOQ 
								provides you with the Field's concat() method:</p>
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">SELECT 'A' || 'B' || 'C' FROM DUAL

-- Or in MySQL:
SELECT concat('A', 'B', 'C')</pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">&nbsp;
// For all RDBMS, including MySQL:
create.select(concat("A", "B", "C"));

</pre>
</td>
</tr>
</table>
						<h1 id="CASE">
<a name="CASE"></a>3.11. The CASE clause</h1><p>
							The SQL standard supports a CASE clause, which works very similar to
							Java's if-else statement. In complex SQL, this is very useful for value
							mapping
						</p>
							<h2>The two flavours of CASE</h2>
							<p>The CASE clause is part of the standard SQL syntax. While some RDBMS
								also offer an IF clause, or a DECODE function, you can always rely on
								the two types of CASE syntax: </p>
								
							<table cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="left" width="50%">
<pre class="prettyprint lang-sql">CASE WHEN T_AUTHOR.FIRST_NAME = 'Paulo'  THEN 'brazilian'
     WHEN T_AUTHOR.FIRST_NAME = 'George' THEN 'english'
                                         ELSE 'unknown'
END

-- OR:

CASE T_AUTHOR.FIRST_NAME WHEN 'Paulo'  THEN 'brazilian'
                         WHEN 'George' THEN 'english'
                                       ELSE 'unknown'
END </pre>
</td><td class="right" width="50%">
<pre class="prettyprint lang-java">create.decode()
      .when(T_AUTHOR.FIRST_NAME.equal("Paulo"), "brazilian")
      .when(T_AUTHOR.FIRST_NAME.equal("George"), "english")
      .otherwise("unknown");

// OR:

create.decode().value(T_AUTHOR.FIRST_NAME)
               .when("Paulo", "brazilian")
               .when("George", "english")
               .otherwise("unknown");</pre>
</td>
</tr>
</table>

							<p>
								In jOOQ, both syntaxes are supported (although, Derby only knows the
								first one, which is more general). Unfortunately, both case and else
								are reserved words in Java. jOOQ chose to use decode() from the Oracle
								DECODE function, and otherwise(), which means the same as else. Please
								note that in the above examples, all values were always constants. You
								can of course also use Field instead of the various constants. 
							</p>
							<p>A CASE clause can be used anywhere where you can place a Field. For
								instance, you can SELECT the above expression, if you're selecting
								from T_AUTHOR: </p>
<pre class="prettyprint lang-sql">SELECT T_AUTHOR.FIRST_NAME, [... CASE EXPR ...] AS nationality
  FROM T_AUTHOR</pre>
  
  
  							<h2>CASE clauses in an ORDER BY clause</h2>
							<p>Sort indirection is often implemented with a CASE clause of a
								SELECT's ORDER BY clause. In SQL, this reads: </p>
								
<pre class="prettyprint lang-sql">SELECT *
FROM T_AUTHOR
ORDER BY CASE FIRST_NAME WHEN 'Paulo'  THEN 1
                         WHEN 'George' THEN 2
                                       ELSE null
         END</pre>
         
							<p>This will order your authors such that all 'Paulo' come first, then
								all 'George' and everyone else last (depending on your RDBMS' handling
								of NULL values in sorting). This is a very common task, such that jOOQ
								simplifies its use: </p>
<pre class="prettyprint lang-java">create.select()
      .from(T_AUTHOR)
      .orderBy(T_AUTHOR.FIRST_NAME.sortAsc("Paulo", "George"))
      .execute();</pre>
						<h1 id="CAST">
<a name="CAST"></a>3.12. Type casting</h1><p>
							Many RDBMS allow for implicit or explicit conversion between types.
							Apart from true type conversion, this is most often done with casting.
						</p>
							<h2>Enforcing a specific type when you need it</h2>
							<p>jOOQ's source code generator tries to find the most accurate type
								mapping between your vendor-specific data types and a matching Java
								type. For instance, most VARCHAR, CHAR, CLOB types will map to String.
								Most BINARY, BYTEA, BLOB types will map to byte[]. NUMERIC types will
								default to java.math.BigDecimal, but can also be any of
								java.math.BigInteger, Long, Integer, Short, Byte, Double, Float. </p>
							<p>Sometimes, this automatic mapping might not be what you needed, or
								jOOQ cannot know the type of a field (because you created it from a
								<a href="#NESTED" title="jOOQ Manual reference: Other types of nested SELECT">nested select</a>). 
								In those cases you would write SQL type CASTs like
								this: </p>
<pre class="prettyprint lang-sql">-- Let's say, your Postgres column LAST_NAME was VARCHAR(30)
-- Then you could do this:
SELECT CAST(T_AUTHOR.LAST_NAME AS TEXT) FROM DUAL</pre>
							<p>in jOOQ, you can write something like that: </p>
							<pre class="prettyprint lang-java">create.select(TAuthor.LAST_NAME.cast(PostgresDataType.TEXT));</pre>
							<p>The same thing can be achieved by casting a Field directly to
								String.class, as TEXT is the default data type in Postgres to map to
								Java's String</p>
							<pre class="prettyprint lang-java">create.select(TAuthor.LAST_NAME.cast(String.class));</pre>
							<p>The complete CAST API in Field consists of these three methods: </p>
<pre class="prettyprint lang-java">public interface Field&lt;T&gt; {
    &lt;Z&gt; Field&lt;Z&gt; cast(Field&lt;Z&gt; field);
    &lt;Z&gt; Field&lt;Z&gt; cast(DataType&lt;Z&gt; type);
    &lt;Z&gt; Field&lt;Z&gt; cast(Class&lt;? extends Z&gt; type);
}

// And additional convenience methods in the Factory:
public class Factory {
    &lt;T&gt; Field&lt;T&gt; cast(Object object, Field&lt;T&gt; field);
    &lt;T&gt; Field&lt;T&gt; cast(Object object, DataType&lt;T&gt; type);
    &lt;T&gt; Field&lt;T&gt; cast(Object object, Class&lt;? extends T&gt; type);
    &lt;T&gt; Field&lt;T&gt; castNull(Field&lt;T&gt; field);
    &lt;T&gt; Field&lt;T&gt; castNull(DataType&lt;T&gt; type);
    &lt;T&gt; Field&lt;T&gt; castNull(Class&lt;? extends T&gt; type);
}</pre>
						<h1 id="SQL">
<a name="SQL"></a>3.13. When it's just easier: Plain SQL</h1><p>
							jOOQ cannot foresee all possible vendor-specific SQL features for your
							database. And sometimes, even jOOQ code becomes too verbose. Then, you
							shouldn't hesitate to provide jOOQ with plain SQL, as you'd do with
							JDBC
						</p>
							<h2>Plain SQL in jOOQ</h2>
							<p>A DSL is a nice thing to have, it feels "fluent" and "natural",
								especially if it models a well-known language, such as SQL. But a DSL
								is always expressed in another language (Java in this case), which was
								not made for exactly that DSL. If it were, then jOOQ would be
								implemented on a compiler-level, similar to Linq in .NET. But it's
								not, and so, the DSL is limited. We have seen many functionalities
								where the DSL becomes verbose. This can be especially true for: </p>
							<ul>
								
<li>
<a href="#ALIAS" title="jOOQ Manual reference: Aliased tables and fields">aliasing</a>
</li>
								
<li>
<a href="#NESTED" title="jOOQ Manual reference: Other types of nested SELECT">nested selects</a>
</li>
								
<li>
<a href="#ARITHMETIC" title="jOOQ Manual reference: Arithmetic operations and concatenation">arithmetic expressions</a>
</li>
								
<li>
<a href="#CAST" title="jOOQ Manual reference: Type casting">casting</a>
</li>
							
</ul>
							<p>You'll probably find other examples. If verbosity scares you off,
								don't worry. The verbose use-cases for jOOQ are rather rare, and when
								they come up, you do have an option. Just write SQL the way you're
								used to! </p>
							<p>jOOQ allows you to embed SQL as a String in these contexts: </p>
							<ul>
								
<li>Plain SQL as a condition </li>
								
<li>Plain SQL as a field </li>
								
<li>Plain SQL as a function </li>
								
<li>Plain SQL as a table </li>
								
<li>Plain SQL as a query </li>
							
</ul>

							<p>To construct artefacts wrapping plain SQL, you should use any of
								these methods from the Factory class: </p>
								
<pre class="prettyprint lang-java">// A condition
Condition condition(String sql);
Condition condition(String sql, Object... bindings);

// A field with an unknown data type
Field&lt;Object&gt; field(String sql);
Field&lt;Object&gt; field(String sql, Object... bindings);

// A field with a known data type
&lt;T&gt; Field&lt;T&gt; field(String sql, Class&lt;T&gt; type);
&lt;T&gt; Field&lt;T&gt; field(String sql, Class&lt;T&gt; type, Object... bindings);
&lt;T&gt; Field&lt;T&gt; field(String sql, DataType&lt;T&gt; type);
&lt;T&gt; Field&lt;T&gt; field(String sql, DataType&lt;T&gt; type, Object... bindings);

// A function
&lt;T&gt; Field&lt;T&gt; function(String name, Class&lt;T&gt; type, Field&lt;?&gt;... arguments);
&lt;T&gt; Field&lt;T&gt; function(String name, DataType&lt;T&gt; type, Field&lt;?&gt;... arguments);

// A table
Table&lt;?&gt; table(String sql);
Table&lt;?&gt; table(String sql, Object... bindings);

// A query without results (update, insert, etc)
Query query(String sql);
Query query(String sql, Object... bindings);

// A query with results
Result&lt;Record&gt; fetch(String sql);
Result&lt;Record&gt; fetch(String sql, Object... bindings);</pre>

							<p>Apart from the general factory methods, plain SQL is useful also in
								various other contexts. For instance, when adding a .where("a = b")
								clause to a query. Hence, there exist several convenience methods
								where plain SQL can be inserted usefully. This is an example
								displaying all various use-cases in one single query: </p>
<pre class="prettyprint lang-java">// You can use your table aliases in plain SQL fields
// As long as that will produce syntactically correct SQL
Field&lt;?&gt; LAST_NAME    = create.field("a.LAST_NAME");

// You can alias your plain SQL fields
Field&lt;?&gt; COUNT1       = create.field("count(*) x");

// If you know a reasonable Java type for your field, you
// can also provide jOOQ with that type
Field&lt;Integer&gt; COUNT2 = create.field("count(*) y", Integer.class);

       // Use plain SQL as select fields
create.select(LAST_NAME, COUNT1, COUNT2)

       // Use plain SQL as aliased tables (be aware of syntax!)
      .from("t_author a")
      .join("t_book b")

       // Use plain SQL for conditions both in JOIN and WHERE clauses
      .on("a.id = b.author_id")

       // Bind a variable in plain SQL
      .where("b.title != ?", "Brida")

       // Use plain SQL again as fields in GROUP BY and ORDER BY clauses
      .groupBy(LAST_NAME)
      .orderBy(LAST_NAME);</pre>

							<p>There are some important things to keep in mind when using plain
								SQL: </p>
							<ul>
								
<li>jOOQ doesn't know what you're doing. You're on your own again!
								</li>
								
<li>You have to provide something that will be syntactically correct.
									If it's not, then jOOQ won't know. Only your JDBC driver or your
									RDBMS will detect the syntax error. </li>
								
<li>You have to provide consistency when you use variable binding. The
									number of ? must match the number of variables </li>
								
<li>Your SQL is inserted into jOOQ queries without further checks.
									Hence, jOOQ can't prevent SQL injection. </li>
							
</ul>
						<h1 id="ADVANCED">
<a name="ADVANCED"></a>4. Advanced topics</h1><p>In these sections you will learn about advanced concepts that
					you might not use every day</p>
					<h2>Overview</h2>
					<p>This section covers some advanced topics and features that don't fit into any other section. </p>
				<h1 id="MasterData">
<a name="MasterData"></a>4.1. Master data generation. Enumeration tables</h1><p>Enumerations are a powerful concept. Unfortunately, almost no
							RDBMS supports them, leaving you to create numerous tables for your
							enumerated values. But these values are still enumerations!</p>
							<h2>Enumeration tables</h2>
							<p>Only MySQL and Postgres databases support true ENUM types natively.
								Some other RDBMS allow you to map the concept of an ENUM data type to
								a CHECK constraint, but those constraints can contain arbitrary SQL.
								 With jOOQ, you
								can "simulate" ENUM types by declaring a table as a "master data
								table" in the configuration. At code-generation time, this table will
								be treated specially, and a Java enum type is generated from its data.
							</p>
							
							<h2>Configure master data tables</h2>
							<p>As previously discussed in the 
							  <a href="#Configuration" title="jOOQ Manual reference: Configuration and setup of the generator">configuration and setup</a>
							   section, you can configure master data tables as follows: </p>
<pre class="prettyprint">#Generate a master data table enum classes (several Java regular expressions, separated by comma)
generator.generate.master-data-tables=[a list of tables]

#For every master data table, specify two special columns
generator.generate.master-data-table-literal.[master data table]=[column used for enum literals]
generator.generate.master-data-table-description.[master data table]=[column used for documentation]</pre>

							<p>The results of this will be a Java enum that looks similar to this: </p>
<pre class="prettyprint lang-java">public enum TLanguage implements MasterDataType&lt;Integer&gt; {

  /**
   * English
   */
  en(1, "en", "English"),

  /**
   * Deutsch
   */
  de(2, "de", "Deutsch"),

  /**
   * Fran&ccedil;ais
   */
  fr(3, "fr", "Fran&ccedil;ais"),

  /**
   * null
   */
  pt(4, "pt", null),
  ;

  private final Integer id;
  private final String cd;
  private final String description;

  // [ ... constructor and getters for the above properties ]
}</pre>

							<p>In the above example, you can see how the configured primary key is
								mapped to the id member, the configured literal column is mapped to
								the cd member and the configured description member is mapped to the
								description member and output as Javadoc. In other words, T_LANGUAGE
								is a table with 4 rows and at least three columns. </p>
							<p>The general contract (with jOOQ 1.6.2+) is that there must be </p>
							<ul>
								
<li> A single-column primary key column of character or integer type
								</li>
								
<li>An optional unique literal column of character or integer type
									(otherwise, the primary key is used as enum literal) </li>
								
<li>An optional description column of any type </li>
							
</ul>
							
							<h2>Using MasterDataTypes</h2>
							<p>The point of MasterDataTypes in jOOQ is that they behave exactly
								like true ENUM types. When the above T_LANGUAGE table is referenced by
								T_BOOK, instead of generating foreign key navigation methods and a
								LANGUAGE_ID Field&lt;Integer&gt;, a Field&lt;TLanguage&gt; is
								generated: </p>
								
<pre class="prettyprint lang-java">public class TBook extends UpdatableTableImpl&lt;TBookRecord&gt; {

  // [...]
  public static final TableField&lt;TBookRecord, TLanguage&gt; LANGUAGE_ID = 
                  new TableFieldImpl&lt;TBookRecord, TLanguage&gt;( /* ... */ );
}</pre>

							<p>Which can then be used in the TBookRecord directly: </p>
<pre class="prettyprint lang-java">public class TBookRecord extends UpdatableRecordImpl&lt;TBookRecord&gt; {

  // [...]
  public TLanguage getLanguageId() { // [...]
  public void setLanguageId(TLanguage value) { // [...]
}</pre>

							<h2>When to use MasterDataTypes</h2>
							<p>You can use master data types when you're actually mapping master
								data to a Java enum. When the underlying table changes frequently,
								those updates will not be reflected by the statically generated code.
								Also, be aware that it will be difficult to perform actual JOIN
								operations on the underlying table with jOOQ, once the master data
								type is generated. </p>
						<h1 id="SchemaMapping">
<a name="SchemaMapping"></a>4.2. Mapping generated schemata and tables</h1><p>
							Sometimes, you cannot control productive schema names, because your
							application is deployed on a shared host, and you only get one schema
							to work with.
						</p>
							<h2>Mapping your DEV schema to a productive environment</h2>
							<p>You may wish to design your database in a way that you have several
								instances of your schema. This is useful when you want to cleanly
								separate data belonging to several customers / organisation units /
								branches / users and put each of those entities' data in a separate
								database or schema. </p>
							<p>In our T_AUTHOR example this would mean that you provide a book
								reference database to several companies, such as My Book World and
								Books R Us. In that case, you'll probably have a schema setup like
								this: </p>
							<ul>
								
<li>DEV: Your development schema. This will be the schema that you
									base code generation upon, with jOOQ </li>
								
<li>MY_BOOK_WORLD: The schema instance for My Book World </li>
								
<li>BOOKS_R_US: The schema instance for Books R Us </li>
							
</ul>
							
							
							<h2>Mapping DEV to MY_BOOK_WORLD with jOOQ</h2>
							<p>When a user from My Book World logs in, you want them to access the
								MY_BOOK_WORLD schema using classes generated from DEV. This can be
								achieved with the 
								<a href="https://github.com/lukaseder/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/SchemaMapping.java" title="Internal API reference: org.jooq.SchemaMapping">org.jooq.SchemaMapping</a>
								class, that you can equip your Factory
								with. Take the following example: </p>
								
<pre class="prettyprint lang-java">SchemaMapping mapping = new SchemaMapping();
mapping.add(DEV, "MY_BOOK_WORLD");

// Add the mapping to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, mapping);

// Run queries with the "mapped" factory
create.selectFrom(T_AUTHOR).fetch();</pre>

							<p>The query executed with a Factory equipped with the above mapping
								will in fact produce this SQL statement: </p>
							<pre class="prettyprint lang-sql">SELECT * FROM MY_BOOK_WORLD.T_AUTHOR</pre>
							<p>Even if T_AUTHOR was generated from DEV. </p>
							
							<h2>Mapping several schemata</h2>
							<p>Your development database may not be restricted to hold only one DEV
								schema. You may also have a LOG schema and a MASTER schema. Let's say
								the MASTER schema is shared among all customers, but each customer has
								their own LOG schema instance. Then you can enhance your SchemaMapping
								like this: </p>
								
<pre class="prettyprint lang-java">SchemaMapping mapping = new SchemaMapping();
mapping.add(DEV, "MY_BOOK_WORLD");
mapping.add(LOG, "MY_BOOK_WORLD_LOG");</pre>

							<p>This will map generated classes from DEV to MY_BOOK_WORLD, from LOG
								to MY_BOOK_WORLD_LOG, but leave the MASTER schema alone. Whenever you
								want to change your mapping configuration, you will have to create a
								new Factory</p>
								
								
							<h2>Using a default schema</h2>
							<p>Another option to switch schema names is to use a default schema for
								the Factory's underlying Connection. Many RDBMS support a USE or SET
								SCHEMA command, which you can call like this: </p>
								
<pre class="prettyprint lang-java">// Set the default schema
Schema MY_BOOK_WORLD = ...
create.use(MY_BOOK_WORLD);

// Run queries with factory having a default schema
create.selectFrom(T_AUTHOR).fetch();</pre>
							<p>Queries generated from the above Factory will produce this kind of SQL statement: </p>
							
<pre class="prettyprint lang-sql">-- the schema name is omitted from all SQL constructs.
SELECT * FROM T_AUTHOR</pre>


							<h2>Mapping of tables</h2>
							<p>Not only schemata can be mapped, but also tables. If you are not the
								owner of the database your application connects to, you might need to
								install your schema with some sort of prefix to every table. In our
								examples, this might mean that you will have to map DEV.T_AUTHOR to
								something MY_BOOK_WORLD.MY_APP__T_AUTHOR, where MY_APP__ is a prefix
								applied to all of your tables. This can be achieved by creating the
								following mapping: </p>
								
<pre class="prettyprint lang-java">SchemaMapping mapping = new SchemaMapping();
mapping.add(DEV, "MY_BOOK_WORLD");
mapping.add(T_AUTHOR, "MY_APP__T_AUTHOR");

// Add the mapping to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, mapping);

// Run queries with the "mapped" factory
create.selectFrom(T_AUTHOR).fetch();</pre>

							<p>The query executed with a Factory equipped with the above mapping will in fact produce this SQL statement: </p>
<pre class="prettyprint lang-sql">SELECT * FROM MY_BOOK_WORLD.MY_APP__T_AUTHOR</pre>

							<h2>Mapping at code generation time</h2>
							<p>
								Note that you can also hard-wire schema mapping in generated artefacts
								at code generation time, e.g. when you have 5 developers with their own
								dedicated developer databases, and a common integration database. In the
								code generation configuration, you would then write.
							</p>
<pre class="prettyprint">#Use this as the developer's schema:
generator.database.input-schema=LUKAS_DEV_SCHEMA

#Use this as the integration / production database:
generator.database.output-schema=PROD
</pre>
							<p>
								See the manual's section about
								<a href="#META" title="jOOQ Manual reference: Meta model code generation">jooq-codegen configuration</a>
								for more details
							</p>
						<h1 id="OracleHints">
<a name="OracleHints"></a>4.3. Adding Oracle hints to queries</h1><p>
							Oracle has a powerful syntax to add hints as comments directly in your SQL
						</p>
							<h2>How to embed Oracle hints in SELECT</h2>
							<p>If you are closely coupling your application to an Oracle database,
								you might need to be able to pass hints of the form /*+HINT*/ with
								your SQL statements to the Oracle database. For example: </p>
<pre class="prettyprint lang-sql">SELECT /*+ALL_ROWS*/ FIRST_NAME, LAST_NAME
  FROM T_AUTHOR</pre>
  
  							<p>This can be done in jOOQ using the .hint() clause in your SELECT statement: </p>
<pre class="prettyprint lang-java">create.select(FIRST_NAME, LAST_NAME)
      .hint("/*+ALL_ROWS*/")
      .from(T_AUTHOR);</pre>

							<p>Note that you can pass any string in the .hint() clause. If you use
								that clause, the passed string will always be put in between the
								SELECT [DISTINCT] keywords and the actual projection list </p>
						<h1 id="CONNECTBY">
<a name="CONNECTBY"></a>4.4. The Oracle CONNECT BY clause</h1><p>
							Hierarchical queries are supported by many RDBMS using the WITH clause.
							Oracle has a very neat and much less verbose syntax for hierarchical
							queries: CONNECT BY .. STARTS WITH
						</p>
							<h2>CONNECT BY .. STARTS WITH</h2>
							<p>If you are closely coupling your application to an Oracle database,
								you can take advantage of some Oracle-specific features, such as the
								CONNECT BY clause, used for hierarchical queries. The formal syntax
								definition is as follows: </p>
								
<pre class="prettyprint lang-sql">--   SELECT ..
--     FROM ..
--    WHERE ..
 CONNECT BY [NOCYCLE] condition [AND condition, ...] [START WITH condition]
-- GROUP BY ..</pre>
							<p>This can be done in jOOQ using the .connectBy(Condition) clauses in your SELECT statement: </p>
<pre class="prettyprint lang-java">// Some Oracle-specific features are only available
// from the OracleFactory
OracleFactory create = new OracleFactory(connection);

// Get a table with elements 1, 2, 3, 4, 5
create.select(create.rownum())
      .connectBy(create.level().lessOrEqual(5))
      .fetch();</pre>

							<p>Here's a more complex example where you can recursively fetch
								directories in your database, and concatenate them to a path:</p>
<pre class="prettyprint lang-java"> OracleFactory ora = new OracleFactory(connection);

 List&lt;?&gt; paths =
 ora.select(ora.sysConnectByPath(DIRECTORY.NAME, "/").substring(2))
    .from(DIRECTORY)
    .connectBy(ora.prior(DIRECTORY.ID).equal(DIRECTORY.PARENT_ID))
    .startWith(DIRECTORY.PARENT_ID.isNull())
    .orderBy(ora.literal(1))
    .fetch(0);</pre>
    
    						<p>The output might then look like this</p>
<pre>+------------------------------------------------+
|substring                                       |
+------------------------------------------------+
|C:                                              |
|C:/eclipse                                      |
|C:/eclipse/configuration                        |
|C:/eclipse/dropins                              |
|C:/eclipse/eclipse.exe                          |
+------------------------------------------------+
|...21 record(s) truncated...
</pre>
						<h1 id="Export">
<a name="Export"></a>4.5. Exporting to XML, CSV, JSON, HTML, Text</h1><p>
							Get your data out of the Java world. Stream your data using any of the supported, wide-spread formats
						</p>
							<h2>Exporting with jOOQ</h2>
							<p>If you are using jOOQ for scripting purposes or in a slim, unlayered
								application server, you might be interested in using jOOQ's exporting
								functionality (see also importing functionality). You can export any
								Result&lt;Record&gt; into any of these formats: </p>
								
							<h3>XML</h3>
							<p>Export your results as XML: </p>
<pre class="prettyprint lang-java">// Fetch books and format them as XML
String xml = create.selectFrom(T_BOOK).fetch().formatXML();</pre>

							<p>The above query will result in an XML document looking like the following one: </p>
<pre class="prettyprint lang-xml">&lt;!-- Find the XSD definition on www.jooq.org: --&gt;
&lt;jooq-export:result xmlns:jooq-export="http://www.jooq.org/xsd/jooq-export-1.6.2.xsd"&gt;
  &lt;fields&gt;
    &lt;field name="ID"/&gt;
    &lt;field name="AUTHOR_ID"/&gt;
    &lt;field name="TITLE"/&gt;
  &lt;/fields&gt;
  &lt;records&gt;
    &lt;record&gt;
      &lt;value field="ID"&gt;1&lt;/value&gt;
      &lt;value field="AUTHOR_ID"&gt;1&lt;/value&gt;
      &lt;value field="TITLE"&gt;1984&lt;/value&gt;
    &lt;/record&gt;
    &lt;record&gt;
      &lt;value field="ID"&gt;2&lt;/value&gt;
      &lt;value field="AUTHOR_ID"&gt;1&lt;/value&gt;
      &lt;value field="TITLE"&gt;Animal Farm&lt;/value&gt;
    &lt;/record&gt;
  &lt;/records&gt;
&lt;/jooq-export:result&gt;</pre>

							<h3>CSV</h3>
							<p>Export your results as CSV: </p>
<pre class="prettyprint lang-java">// Fetch books and format them as CSV
String csv = create.selectFrom(T_BOOK).fetch().formatCSV();</pre>

							<p>The above query will result in a CSV document looking like the following one: </p>
<pre>ID;AUTHOR_ID;TITLE
1;1;1984
2;1;Animal Farm</pre>


							<h3>JSON</h3>
							<p>Export your results as JSON: </p>
							
<pre class="prettyprint lang-java">// Fetch books and format them as JSON
String json = create.selectFrom(T_BOOK).fetch().formatJSON();</pre>
							<p>The above query will result in a JSON document looking like the following one: </p>
<pre>{fields:["ID","AUTHOR_ID","TITLE"],
 records:[[1,1,"1984"],[2,1,"Animal Farm"]]}</pre>
 
 							<h3>HTML </h3>
 							<p>Export your results as HTML: </p>
<pre class="prettyprint lang-java">// Fetch books and format them as HTML
String html = create.selectFrom(T_BOOK).fetch().formatHTML();</pre>
							<p>The above query will result in an HTML document looking like the following one: </p>
<pre class="prettyprint lang-xml">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ID&lt;/th&gt;
      &lt;th&gt;AUTHOR_ID&lt;/th&gt;
      &lt;th&gt;TITLE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1984&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Animal Farm&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</pre>

							<h3>Text</h3>
							<p>Export your results as text: </p>
<pre class="prettyprint lang-java">// Fetch books and format them as text
String text = create.selectFrom(T_BOOK).fetch().format();</pre>

							<p>The above query will result in a text document looking like the following one: </p>
<pre>+---+---------+-----------+
| ID|AUTHOR_ID|TITLE      |
+---+---------+-----------+
|  1|        1|1984       |
|  2|        1|Animal Farm|
+---+---------+-----------+</pre>
						<h1 id="Import">
<a name="Import"></a>4.6. Importing data from XML, CSV</h1><p>
							Use jOOQ to easily merge imported data into your database.
						</p>
							<h2>Importing with jOOQ</h2>
							<p>If you are using jOOQ for scripting purposes or in a slim, unlayered
								application server, you might be interested in using jOOQ's importing
								functionality (see also exporting functionality). You can import data
								directly into a table from any of these formats: </p>
								
							<h3>CSV</h3>
							<p>The below CSV data represents two author records that may have been
								exported previously, by jOOQ's exporting functionality, and then
								modified in Microsoft Excel or any other spreadsheet tool: </p>
								
<pre>ID;AUTHOR_ID;TITLE
1;1;1984
2;1;Animal Farm</pre>

							<p>With jOOQ, you can load this data using various parameters from the
								loader API. A simple load may look like this: </p>
								
<pre class="prettyprint lang-java">Factory create = new Factory(connection, SQLDialect.ORACLE);

// Load data into the T_AUTHOR table from an input stream
// holding the CSV data.
create.loadInto(T_AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, AUTHOR_ID, TITLE)
      .execute();</pre>
      
      						<p>Here are various other examples: </p>
<pre class="prettyprint lang-java">// Ignore the AUTHOR_ID column from the CSV file when inserting
create.loadInto(T_AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour for duplicate records.
create.loadInto(T_AUTHOR)

      // choose any of these methods
      .onDuplicateKeyUpdate()
      .onDuplicateKeyIgnore()
      .onDuplicateKeyError() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour when errors occur.
create.loadInto(T_AUTHOR)

      // choose any of these methods
      .onErrorIgnore()
      .onErrorAbort() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify transactional behaviour where this is possible
// (e.g. not in container-managed transactions)
create.loadInto(T_AUTHOR)

      // choose any of these methods
      .commitEach()
      .commitAfter(10)
      .commitAll()
      .commitNone() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();</pre>
      
							<p>Any of the above configuration methods can be combined to achieve
								the type of load you need. Please refer to the API's Javadoc to learn
								about more details. Errors that occur during the load are reported by
								the execute method's result: </p>
								
<pre class="prettyprint lang-java">Loader&lt;TAuthor&gt; loader = /* .. */ .execute();

// The number of processed rows
int processed = loader.processed();
 
// The number of stored rows (INSERT or UPDATE)
int stored = loader.stored();
 
// The number of ignored rows (due to errors, or duplicate rule)
int ignored = loader.ignored();
 
// The errors that may have occurred during loading
List&lt;LoaderError&gt; errors = loader.errors();
LoaderError error = errors.get(0);
 
// The exception that caused the error
SQLException exception = error.exception();
 
// The row that caused the error
int rowIndex = error.rowIndex();
String[] row = error.row();
 
// The query that caused the error
Query query = error.query();</pre>

							<h3>XML </h3>
							<p>This will be implemented soon... </p>
						<h1 id="Batch">
<a name="Batch"></a>4.7. Using JDBC batch operations</h1><p>
							Some JDBC drivers have highly optimised means of executing batch
							operations. The JDBC interface for those operations is a bit verbose.
							jOOQ abstracts that by re-using the existing query API's
						</p>
							<h2>JDBC batch operations</h2>
							<p>With JDBC, you can easily execute several statements at once using
								the addBatch() method. Essentially, there are two modes in JDBC</p>

							<ol>
								
<li>Execute several queries without bind values</li>
								
<li>Execute one query several times with bind values</li>
							
</ol>
	
							<p>In code, this looks like the following snippet:</p>
<pre class="prettyprint lang-java">// 1. several queries
// ------------------
Statement stmt = connection.createStatement();
stmt.addBatch("INSERT INTO author VALUES (1, 'Erich Gamma')");
stmt.addBatch("INSERT INTO author VALUES (2, 'Richard Helm')");
stmt.addBatch("INSERT INTO author VALUES (3, 'Ralph Johnson')");
stmt.addBatch("INSERT INTO author VALUES (4, 'John Vlissides')");
int[] result = stmt.executeBatch();

// 2. a single query
// -----------------
PreparedStatement stmt = connection.prepareStatement("INSERT INTO autho VALUES (?, ?)");
stmt.setInt(1, 1);
stmt.setString(2, "Erich Gamma");
stmt.addBatch();

stmt.setInt(1, 2);
stmt.setString(2, "Richard Helm");
stmt.addBatch();

stmt.setInt(1, 3);
stmt.setString(2, "Ralph Johnson");
stmt.addBatch();

stmt.setInt(1, 4);
stmt.setString(2, "John Vlissides");
stmt.addBatch();

int[] result = stmt.executeBatch();</pre>
								
								
							<h2>This will also be supported by jOOQ</h2>
							<p>Version 1.6.9 of jOOQ now supports executing queries in batch
								mode as follows:</p>
<pre class="prettyprint lang-java">// 1. several queries
// ------------------
create.batch(
	create.insertInto(AUTHOR, ID, NAME).values(1, "Erich Gamma"),
	create.insertInto(AUTHOR, ID, NAME).values(2, "Richard Helm"),
	create.insertInto(AUTHOR, ID, NAME).values(3, "Ralph Johnson"),
	create.insertInto(AUTHOR, ID, NAME).values(4, "John Vlissides"))
.execute();

// 2. a single query
// -----------------
create.batch(create.insertInto(AUTHOR, ID, NAME).values("?", "?"))
	  .bind(1, "Erich Gamma")
	  .bind(2, "Richard Helm")
	  .bind(3, "Ralph Johnson")
	  .bind(4, "John Vlissides")
	  .execute();</pre>
						
<?php 
}
?>
